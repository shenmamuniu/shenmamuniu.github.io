[{"title":"煎炖鸡","slug":"煎炖鸡","url":"/2024/09/07/jian-tun-ji/","content":"\n这次做了一道家常版的三黄鸡，口味偏中式，简单易做，但细节很重要！\n\n<!--more-->\n\n### 食材准备：\n- **三黄鸡500g**（切块）\n- 泡发香菇\n- 洋葱、蒜、青椒切段\n\n### 烹饪步骤：\n1. **处理鸡块**：用料酒腌制鸡块，去腥。\n2. **煎鸡块**：热锅放油，鸡块下锅后别急着翻动，等到鸡皮开始焦香、油崩时，再加入洋葱、蒜、香菇翻炒。\n3. **调味**：加入花椒、茴香、3颗白冰糖，耗油，2勺盐和一点南德提鲜。炒至香味四溢。\n4. **炖煮**：鸡块炒得差不多熟了，加一点水，别淹没鸡块，稍微炖煮。等汤汁快要收干时关火。\n\n### 成品反馈：\n整体味道还是挺不错的，鸡块很入味。只是有些部位的鸡肉略显柴，可能和选用的鸡部位有关。总体来说，这道菜简单却能轻松抓住味蕾，喜欢清淡家常味的朋友可以尝试！","tags":["做饭日记"],"categories":["做饭日记"]},{"title":"啤酒炖鸡","slug":"啤酒炖鸡","url":"/2024/08/31/pi-jiu-tun-ji/","content":"这次尝试了一道啤酒鸡，虽然过程顺利，但结果稍显平平，可能还需要在调味上再下点功夫。\n<!--more-->\n\n### 食材准备：\n- **鸡块**（提前腌制）\n- 泡发的干香菇\n- 洋葱、蒜切好\n- 一罐啤酒\n- 土豆、冰糖适量\n\n### 烹饪步骤：\n1. **煎鸡块**：先将腌好的鸡块煎至微微金黄，表皮锁住肉汁。\n2. **炒香料**：另起锅，加入洋葱和蒜炒香，再放入煎好的鸡块。\n3. **加入啤酒**：倒入一罐啤酒，没过鸡块，再加入土豆、香菇、冰糖。\n4. **焖煮**：中小火焖煮15分钟左右，直到食材熟透，汤汁浓稠。\n\n### 成品反馈：\n味道中规中矩，啤酒的香气没有完全融入鸡肉，调味略显单调，整体表现平淡。下次可以考虑加入更多调料，比如酱油、耗油或干辣椒，提升口感层次。","tags":["做饭日记"],"categories":["做饭日记"]},{"title":"初探GIS：在Unity游戏引擎中的地理信息系统体验","slug":"初探GIS：在Unity游戏引擎中的地理信息系统体验","url":"/2024/04/21/chu-tan-gis-zai-unity-you-xi-yin-qing-zhong-de-di-li-xin-xi-xi-tong-ti-yan/","content":"在数字时代的冲击下，地理信息系统（GIS）的应用范围正在迅速拓展。从城市规划到环境监测，从教育培训到旅游体验，GIS正成为解决现实世界问题的重要工具。\n\n<!--more-->\nCesium作为一个备受关注的平台，提供了强大的地理空间数据可视化能力，为开发者提供了丰富的工具和API来创建各种各样的地球应用程序。 然而，要真正释放GIS的潜力，我们需要更多的创新和交互性。而游戏引擎的强大功能和用户友好性，为实现这一目标提供了新的可能性。在本文中，我们将深入探讨游戏引擎与GIS的结合，以及这种结合如何为地理信息应用带来更丰富、更沉浸的体验，打开GIS应用的新视界。\n\n## Cesium是什么\n\nCesium是一个开源的JavaScript库，用于创建和展示三维地球上的地理空间数据。它提供了一种强大的方式来构建虚拟地球应用程序，可以在网页浏览器中运行，并且可以在桌面、移动设备和虚拟现实头戴式显示器等平台上使用。\n\nCesium的主要特点包括：\n\n1. **三维地球可视化：** Cesium可以将地球表面的地理空间数据以三维形式呈现，包括地形、地标、建筑物等。\n\n2. **实时数据：** 它支持实时数据的展示，如航空航天轨道、气象数据、传感器数据等。\n\n3. **跨平台兼容：** Cesium可以在各种平台上运行，包括桌面、移动设备和虚拟现实设备。\n\n4. **开放式标准：** Cesium遵循开放式标准，支持多种数据格式和协议，如3D Tiles、KML、GeoJSON、WMS、WMTS等，使得用户可以灵活地导入和展示不同来源的地理空间数据。\n\n5. **高度可定制性：** 它提供了丰富的API和功能，使得开发者可以定制地球的外观和行为，满足各种应用需求。\n\nCesium为开发者提供了一个强大而灵活的平台，用于构建基于三维地球的应用程序，从虚拟地球浏览器到地理信息系统（GIS）应用等各种场景都可以使用。\n\n## 在Unity中使用Cesium\n\nCesium for Unity是一个Unity插件，它将Cesium的强大的地理空间数据可视化能力与Unity引擎的游戏开发能力相结合。这个插件允许开发者在Unity中轻松地创建具有地理信息系统（GIS）功能的应用程序，同时利用Unity引擎的强大特性，如游戏开发、物理引擎等。\n\n主要功能和特点包括：\n\n1. **地理空间数据可视化：** 将Cesium的地理空间数据可视化功能整合到Unity中，使得开发者可以在Unity中展示三维地球、地形、地标、航线等地理信息数据。\n\n2. **跨平台开发：** Cesium for Unity支持在多个平台上进行开发，包括桌面、移动设备和虚拟现实设备。\n\n3. **高度可定制性：** 开发者可以使用Cesium for Unity的API和功能来定制地球的外观和行为，满足各种应用需求。\n\n4. **融合游戏开发功能：** 利用Unity引擎的游戏开发功能，开发者可以为地理信息应用添加游戏元素，如交互式控制、碰撞检测等。\n\n5. **支持地理空间数据格式：** Cesium for Unity支持多种地理空间数据格式，如3D Tiles、KML、GeoJSON等，使得开发者可以灵活地导入和展示不同来源的地理空间数据。\n\n总的来说，Cesium for Unity为开发者提供了一个强大而灵活的平台，用于在Unity中创建具有地理信息系统功能的应用程序，从虚拟地球浏览器到地理游戏等各种场景都可以使用。\nCesium for Unity 支持多个平台，包括 Windows、macOS、Android 和 VR 平台，如 Quest 2 和 Quest Pro,然而，直接发布为网页可能不是 Cesium for Unity 的原生功能,因此目前包括Cesium for Unreal Engine，都是采用像素流的技术来在服务端进行页面渲染，之后通过WebRTC在网页中访问。\n\n\n\n![Unity中使用Cesium](2024-04-21_164132.jpg)\n\n\n\n## Unity Render Streaming\n\nUnity Render Streaming是一项技术，允许您在网络上流式传输Unity场景的渲染内容。这意味着您可以将Unity应用程序的实时图形渲染传输到远程设备，例如网络浏览器或其他支持流媒体的平台。\n\n其原理主要包括以下几个步骤：\n\n1. **渲染捕捉**：Unity应用程序的渲染内容首先被捕捉到一张或多张图像。这通常通过使用Unity中的摄像机来渲染场景，然后将摄像机视图捕捉为图像。\n\n2. **编码压缩**：捕捉到的图像被编码并压缩，以便在网络上传输时减少带宽占用和延迟。常见的压缩算法包括H.264或VP8/VP9等。\n\n3. **流式传输**：压缩后的图像流通过网络传输到目标设备。这可以通过诸如WebRTC（Web实时通信）等流媒体协议来实现，这些协议旨在支持实时的音视频传输。\n\n4. **解码渲染**：接收端的设备接收到图像流后，进行解码并渲染到屏幕上。这可能涉及到对解码后的图像进行后处理以适应不同的显示器分辨率和设备特性。\n\n总的来说，Unity Render Streaming技术通过捕捉、压缩、传输和渲染这一系列步骤，实现了在网络上实时流式传输Unity应用程序的渲染内容，使得用户可以通过网络访问和体验Unity应用程序的视觉效果。\n\nUnity Render Streaming有几个应用场景：\n\n1. **远程游戏体验：** 使用Render Streaming，玩家可以通过网络在任何设备上体验Unity游戏或应用程序，而不必下载和安装本地应用。这使得游戏可以在低端设备或不支持Unity的设备上进行游玩，同时也提供了更广泛的游戏访问方式。\n\n2. **实时协作和演示：** 开发者可以使用Render Streaming来进行实时协作或者演示。例如，在教育领域，老师可以在一个设备上演示Unity场景，学生们则可以在他们自己的设备上观看并与其进行互动。这种方式可以促进远程教学和团队合作。\n\n3. **云游戏服务：** Render Streaming技术也为云游戏服务提供了基础。游戏开发者可以将他们的游戏部署到云端服务器上，然后通过Render Streaming将游戏的渲染内容流式传输到玩家的设备上，从而实现云端游戏服务。\n\n4. **虚拟现实（VR）和增强现实（AR）体验：** Render Streaming使得可以通过网络在VR和AR设备上体验Unity应用程序，而无需将应用程序直接安装到设备上。这样一来，用户可以在不同位置和设备上体验虚拟和增强现实内容，而不受设备性能的限制。\n\n![Unity Render Streaming效果图](2024-04-21_170110.jpg)\n\n总的来说，Unity Render Streaming为用户提供了更灵活的访问方式，并为开发者提供了在不同平台上发布和传播Unity应用程序的新途径。\n\n","tags":["GIS","Unity"],"categories":["GIS","Unity"]},{"title":"计算机视觉之数据集简介","slug":"计算机视觉之数据集简介","url":"/2024/04/21/ji-suan-ji-shi-jue-zhi-shu-ju-ji-jian-jie/","content":"\n数据集在计算机视觉和图像处理任务中起着至关重要的作用。下面我将介绍一些常用的图像处理数据集，包括它们的种类和主要区别：\n\n<!--more-->\n\n### 1. COCO (Common Objects in Context)\n\n- **类型**：多标签图像分类、目标检测、实例分割。\n- **特点**：COCO数据集包含超过80个常见对象类别，并为图像中的对象提供了精确的边界框和实例分割掩码。\n- **适用场景**：广泛应用于目标检测、实例分割和图像分类等任务。\n\n### 2. VOC (Visual Object Classes)\n\n- **类型**：多标签图像分类、目标检测、图像分割。\n- **特点**：VOC数据集主要包含20个对象类别，并提供每个对象的边界框和像素级别的标注。\n- **适用场景**：常用于目标检测、图像分割、物体识别等任务。\n\n### 3. ImageNet\n\n- **类型**：单标签图像分类。\n- **特点**：ImageNet是一个大规模的图像分类数据集，包含超过1000个对象类别。\n- **适用场景**：主要用于图像分类任务，如图像识别和物体识别。\n\n### 4. Cityscapes\n\n- **类型**：语义分割、实例分割。\n- **特点**：Cityscapes数据集专注于城市场景的语义和实例分割，包含大量的高分辨率图像，涵盖了复杂的城市环境。\n- **适用场景**：适用于道路、车辆、行人等城市场景的语义和实例分割任务。\n\n### 5. Pascal VOC (Visual Object Classes)\n\n- **类型**：多标签图像分类、目标检测、图像分割。\n- **特点**：Pascal VOC数据集包含多个版本，主要用于目标检测、图像分割和图像分类等任务，具有较为全面的标注。\n- **适用场景**：广泛应用于计算机视觉算法的评估和基准测试。\n\n### 区别总结\n\n- **数据规模**：数据集的大小和复杂性不同，从数千到数百万的图像和标注。\n- **任务类型**：不同的数据集支持不同的计算机视觉任务，包括图像分类、目标检测、实例分割和语义分割等。\n- **对象类别**：数据集包含的对象类别数量和种类也有所不同，从数十到数千的对象类别。\n- **标注详细性**：标注的精度和详细性也是选择数据集时需要考虑的重要因素，包括边界框、实例分割掩码和像素级别的标注等。\n\n这几个常用的数据集和与之相关的计算机视觉模型：\n\n| 数据集 (Dataset)                 | 主要任务 (Primary Tasks)     | 相关模型 (Related Models)     |\n| -------------------------------- | ---------------------------- | ----------------------------- |\n| COCO (Common Objects in Context) | 图像分类、目标检测、实例分割 | Mask R-CNN, Faster R-CNN      |\n| VOC (Visual Object Classes)      | 图像分类、目标检测、图像分割 | YOLO, SSD, RCNN, FCN          |\n| ImageNet                         | 图像分类                     | ResNet, Inception (GoogLeNet) |\n| Cityscapes                       | 语义分割、实例分割           | DeepLabv3+, U-Net             |\n| Pascal VOC                       | 图像分类、目标检测、图像分割 | RCNN, FCN                     |\n","tags":["计算机视觉"],"categories":["计算机视觉"]},{"title":"计算机视觉中的几个任务","slug":"计算机视觉中的几个任务","url":"/2024/04/21/ji-suan-ji-shi-jue-zhong-de-ji-ge-ren-wu/","content":"\n计算机视觉是一门研究如何使机器“看”的科学和技术，它涉及使机器能够自动地从图像或视频中理解、分析和解释视觉信息的过程。\n\n<!--more-->\n\n计算机视觉的目标是模拟人类视觉系统的功能，使机器能够感知和理解环境中的视觉内容，从而进行智能决策和执行各种任务。 \n\n计算机视觉结合了计算机科学、人工智能、机器学习和图像处理等多个领域的知识和技术，是现代信息技术中的一个重要研究领域，具有广泛的应用前景和深远的社会影响。\n\n# 主要组成部分\n\n1. **图像获取**：使用摄像头或其他设备从现实世界中捕获图像或视频。\n\n2. **预处理和图像增强**：对原始图像进行预处理，如去噪、增强对比度等，以改善图像质量。\n\n3. **特征提取**：从图像中提取有用的特征或模式，这些特征可以帮助识别、分类或定位对象。\n\n4. **图像分析和解释**：使用机器学习和深度学习算法对图像进行分析和解释，以实现各种视觉任务，如图像分类、目标检测、人脸识别、物体跟踪、场景分割等。\n\n5. **应用和决策**：根据图像分析的结果进行决策或执行特定的任务，如自动驾驶、机器人导航、安全监控、医学图像分析等。\n\n# 主要应用领域\n\n- **安全监控**：视频监控、入侵检测、人脸识别。\n  \n- **自动驾驶**：道路检测、障碍物识别、行人检测。\n  \n- **医疗图像分析**：医学影像识别、疾病检测、图像诊断。\n  \n- **工业检测和质量控制**：产品检测、缺陷检测、自动分类。\n  \n- **增强现实和虚拟现实**：交互式体验、模拟和仿真、虚拟导航。\n\n# 主要任务\n\n## 1. 图像分类 (Image Classification)\n\n- **任务描述**：将输入图像分配到预定义的类别或标签中。\n- **应用场景**：例如，识别图像中的动物、交通标志、食物等。\n\n## 2. 目标检测 (Object Detection)\n\n- **任务描述**：检测图像中的对象并确定它们的位置（通常使用边界框表示）。\n- **应用场景**：例如，检测图像中的人、车辆、动物等，并标注它们的位置。\n\n## 3. 实例分割 (Instance Segmentation)\n\n- **任务描述**：不仅检测图像中的对象，还为每个对象的每个像素分配一个类别标签，从而区分不同对象的不同实例。\n- **应用场景**：例如，对图像中的多个物体进行精确的分割和分类。\n\n## 4. 语义分割 (Semantic Segmentation)\n\n- **任务描述**：为图像的每个像素分配一个类别标签，以表示该像素属于的对象类别。\n- **应用场景**：例如，将图像中的每个像素标记为天空、道路、建筑等类别。\n\n## 5. 图像生成 (Image Generation)\n\n- **任务描述**：生成新的图像，以模拟或扩展现有的视觉内容。\n- **应用场景**：例如，生成艺术作品、图像增强、数据增强等。\n\n## 6. 人脸识别和检测 (Face Recognition and Detection)\n\n- **任务描述**：识别图像或视频中的人脸，并将其与已知的人脸进行匹配或验证。\n- **应用场景**：例如，身份验证、安全监控、社交媒体标签等。\n\n## 7. 姿态估计 (Pose Estimation)\n\n- **任务描述**：检测图像或视频中的人体姿态和关节位置。\n- **应用场景**：例如，体育分析、健身指导、人机交互等。\n\n## 8. 图像分割和修复 (Image Segmentation and Inpainting)\n\n- **任务描述**：分割图像中的对象并修复或填充缺失或损坏的区域。\n- **应用场景**：例如，图像修复、物体移除、艺术创作等。\n\n主要任务涵盖了计算机视觉的核心功能和应用领域，每个任务都有其独特的挑战和解决方案，通常需要结合深度学习、机器学习和传统图像处理技术来实现。\n\n# 图像分类、目标检测、语义分割和实例分割\n\n图像分类、目标检测、语义分割和实例分割都是计算机视觉中的核心概念，它们描述了不同的图像识别和分析任务。以下是这些概念的定义和它们之间的关系：\n\n##  **图像分类 (Image Classification)**：\n   - **定义**：图像分类是将输入图像分配到预定义的类别或标签中的一个任务。通常，这是一个监督学习任务，其中算法需要从标记的图像数据集中学习。\n\n##  **目标检测 (Object Detection)**：\n   - **定义**：目标检测不仅要识别图像中的对象，还要确定它们的位置。它会在图像中标记对象的边界框，并为每个边界框分配一个类别标签。通常，目标检测使用两步策略：首先检测图像中的候选对象区域（如使用区域提议网络），然后对这些区域进行分类。\n\n   - **相关模型**: Faster R-CNN、YOLO（You Only Look Once）或SSD（Single Shot Multibox Detector）。\n\n##  **实例分割 (Instance Segmentation)**：\n   - **定义**：实例分割不仅要识别图像中的对象，还要为每个对象的每个像素分配一个类别标签，从而区分不同对象的不同实例。这意味着它不仅要标记对象的边界框，还要标记对象内部的像素。\n   - **特点**：\n        - 对图像进行像素级别的分类。\n        - 区分同一类别内的不同对象实例。\n        - 通常用于复杂场景分析、物体检测与分割、自动驾驶等。\n\n   - **相关模型**: 如Mask R-CNN、DeepLabv3+或U-Net。\n\n##  **语义分割 (Semantic Segmentation)**：\n   - **定义**：语义分割是将图像的每个像素分类到预定义的类别中，但不区分不同对象的不同实例。这意味着所有同一类别的像素（如人、车、树等）都将被分配相同的标签，而不考虑它们是否属于同一个对象实例。\n   - **特点**：\n        - 对图像进行像素级别的分类。\n        - 不考虑同一类别内的不同对象实例。\n        - 通常用于场景理解、图像分割、医学图像分析等。\n\n   - **相关模型**:如DeepLab、U-Net或FCN（Fully Convolutional Network）。\n\n## 区别与联系\n\n- **图像分类**、**目标检测**、**实例分割**和**语义分割**可以看作是从粗到细、从简单到复杂的层次。\n- 在**图像分类**中，主要关注图像的整体内容，是识别图像中的整体内容并将其分类到预定义的类别中。\n- **目标检测**扩展了图像分类的功能，解决“有无”和“位置”问题，检测图像中的对象并确定其位置。\n- **语义分割**解决“是什么”的问题。\n- **实例分割** 结合了目标检测和语义分割的功能，不仅检测对象和确定位置，还为每个对象的每个像素提供精确的类别标签，以区分不同对象的不同实例。\n\n简单来说：目标检测只是检测有无和确定位置，而语义分割则解决的是是什么的问题，而实例分割，则不仅关注有无的问题，还有位置的问题，以及是什么的问题，因此可以说实例分割=目标检测+语义分割。\n\n下面通过一个简单的垃圾分类案例来区分：图像分类、目标检测、语义分割和实例分割。\n\n图像分类：识别图像中是否存在垃圾（例如，有垃圾或无垃圾）\n\n目标检测：检测图像中垃圾的位置并为其绘制边界框，指示其存在。\n\n语义分割：识别图像中是什么种类的垃圾\n\n实例分割：识别图像中的垃圾及其位置，以及确定是什么种类的垃圾","tags":["计算机视觉"],"categories":["计算机视觉"]},{"title":"WebSocket在多客户端应用中的主动推送","slug":"WebSocket在多客户端应用中的主动推送","url":"/2024/04/21/websocket-zai-duo-ke-hu-duan-ying-yong-zhong-de-zhu-dong-tui-song/","content":"\nWebSocket允许服务器和客户端之间建立持久的双向通信通道。在WebSocket中，服务器可以主动向客户端发送消息，而不仅仅是响应客户端发送的请求。 \n\n<!--more-->\n\n### WebSocket 概述\n\nWebSocket 是一种提供实时、双向通信的网络协议，允许客户端和服务器之间建立持久的连接，实现数据的实时交互。\n\n### WebSocket 优势\n\n1. **实时性**：提供实时的双向通信，支持服务器主动推送数据给客户端。\n2. **效率和性能**：减少不必要的 HTTP 请求和响应，提高数据传输效率和系统性能。\n3. **灵活性**：提供更灵活的数据推送机制，根据客户端需求动态地发送不同的数据。\n\n与Ajax轮询的区别：\n\n- **实时性**：WebSocket提供实时的双向通信，可以更快速地响应和处理地图范围的变化，而AJAX轮询可能会存在一定的延迟。\n\n- **效率和性能**：WebSocket减少了不必要的HTTP请求和响应，可以提供更高效和更低延迟的数据传输。\n\n- **灵活性**：WebSocket提供更灵活的数据推送机制，可以根据客户端需求动态地发送不同的数据。\n\n- **服务器和网络负载**：WebSocket可以减少服务器和网络的负载，因为它不需要频繁地处理和响应大量的轮询请求。\n\n在动态地图范围和实时数据更新的场景中，WebSocket通常能够提供更好的实时性、效率和灵活性，尤其是当地图范围频繁变化且需要实时更新时。虽然WebSocket需要处理复杂的订阅和过滤逻辑，但它提供了一个更强大和灵活的数据推送机制，有助于实现更高效和实时的数据交互。\n\n###  使用场景\n\nWebSocket适用于需要实时双向通信的场景，它提供了持久的连接，允许服务器和客户端之间实时、低延迟地交换数据。以下是一些适合使用WebSocket的常见场景：\n\n1. **即时通讯应用**：\n   - 聊天室、在线游戏、即时消息应用等需要实时双向通信的应用场景。\n\n2. **实时数据更新**：\n   - 股票市场、实时监控系统、实时协作工具等需要实时更新数据的应用。\n\n3. **实时通知和提醒**：\n   - 社交媒体通知、邮件通知、即时新闻推送等需要实时通知用户的场景。\n\n4. **在线协作和共享**：\n   - 实时协作文档编辑、在线白板、远程会议等需要多用户实时协作的场景。\n\n5.  **实时位置追踪和地理信息系统（GIS）**： ：\n   - 实时位置共享、车辆追踪、物流跟踪等需要实时位置更新的应用。\n\n6. **实时游戏和交互应用**：\n   - 实时多人在线游戏、虚拟现实应用、实时交互应用等需要高度实时响应的应用。\n\n7. **在线广播和直播**：\n   - 实时音频/视频广播、直播流处理等需要实时传输大量数据的应用。\n\n8. **实时客户支持和服务**：\n   - 在线客服聊天、远程协助、实时问题解决等需要即时响应的客户支持服务。\n\n9. **物联网（IoT）应用**：\n   - 远程设备监控、智能家居控制、工业自动化等需要实时控制和监控设备的应用。\n\nWebSocket提供了与传统HTTP请求/响应模型不同的实时双向通信能力，使得它成为上述场景中的理想选择。\n\n>  注意：在实际应用中，需要确保WebSocket连接的安全性和可靠性，可以使用WSS（WebSocket Secure）协议或其他安全措施来加密和保护通信数据。 \n\n### WebSocket 在多客户端应用中的应用\n\nWebSocket连接是一个持久的双向通信通道，每个客户端与服务器建立的WebSocket连接都有一个唯一的标识符，通常称为“WebSocket Session ID”或“WebSocket Connection ID”。通过这个标识符，服务器可以区分不同的客户端，并向特定的客户端发送消息。\n\n以下是如何在WebSocket服务器端向特定客户端发送消息的基本步骤：\n\n1. **建立WebSocket连接并保存连接信息**：\n   - 当客户端与服务器建立WebSocket连接时，服务器通常会为每个连接生成一个唯一的ID，并保存与该连接相关的信息（如连接ID、客户端IP地址等）。\n2. **发送消息到特定客户端**：\n   - 当服务器需要向特定客户端发送消息时，可以使用该客户端的连接ID来标识目标客户端，并通过其连接对象发送消息。\n\n这里需要关注的点就是连接id的存储，最简单的就是在服务端创建一个共享的字段或变量来存储客户端数据。这种方法简化了数据管理和交互过程，使得服务器能够根据客户端的需求实时地响应和推送数据。\n\n在实际应用中，根据具体的需求和场景，还可以进一步优化和扩展这种设计，例如：\n\n- **数据分区和缓存**：根据地图范围或其他条件对数据进行分区和缓存，提高数据检索和推送的效率。\n  \n- **状态管理和验证**：添加状态管理和验证机制，确保客户端的地图范围和数据状态的一致性和有效性。\n  \n- **客户端管理和扩展**：扩展客户端管理功能，包括连接管理、状态跟踪、异常处理等，以提高系统的稳定性和可靠性。\n\n总的来说，这种简单而直接的方法为 WebSocket 应用提供了一个灵活、实时和高效的数据管理和交互机制，适用于多种实时数据推送和通信场景。\n\n### Websocket在实时位置追踪中的应用\n\n在实时位置追踪应用中，WebSocket通常用于建立持久的双向通信通道，以实时更新和共享设备或用户的位置数据。其数据流向大致为：\n监控客户端(如大屏等)->websocket服务器->数据库<-IOT设备(或车辆等)。\n具体描述为：\n\n1. **客户端（如Web应用、移动应用等）**：\n   - 用户通过客户端与WebSocket服务器建立连接。\n   - 客户端可以发送命令、请求或其他消息到WebSocket服务器，如请求最新的设备位置、控制设备状态等。\n\n2. **WebSocket服务器**：\n   - WebSocket服务器负责与客户端建立和管理WebSocket连接。\n   - 当接收到客户端的消息时，WebSocket服务器可以进行处理、转发或存储，并根据业务逻辑执行相应的操作。\n\n3. **数据库**：\n   - WebSocket服务器可以与数据库进行交互，读取或写入数据。\n   - 例如，保存设备的历史位置数据、查询设备状态、更新设备配置等。\n\n4. **IOT设备**：\n   - IOT设备可以与WebSocket服务器建立连接，通过WebSocket协议发送和接收数据。\n   - WebSocket服务器可以控制IOT设备，发送指令或配置信息，并接收设备的状态、传感器数据等。\n\n这种架构允许实现高度实时、灵活和可扩展的应用，使得客户端、服务器、数据库和IOT设备之间能够实时、可靠地交换数据和指令。\n\n然而，需要注意的是，在设计和实现这样的系统时，需要考虑安全性、性能优化、错误处理、数据同步和一致性等关键问题，以确保系统的稳定性、可靠性和安全性。\n\n\n### *Websocket如何确定哪些更新的数据发送给客户端*\n\nWebSocket本身只负责数据的推送和通信，它并不关心数据的内容或数据是否是更新的。WebSocket仅提供了一个持久的双向通信通道，允许服务器实时地向客户端发送消息。\n\n要区分哪些数据是更新的，通常需要在应用的业务逻辑中进行处理。以下是一些常见的方法来识别和处理更新数据：\n\n1. **数据版本或时间戳**：\n   - 在发送数据时，可以包含一个版本号或时间戳，客户端可以使用这些信息来检查数据是否是最新的。\n   - 当客户端接收到新的数据时，比较版本号或时间戳，如果新数据的版本号或时间戳较新，则表示数据已更新。\n\n2. **状态或标志位**：\n   - 在数据中添加一个状态字段或标志位，表示数据的状态（如“更新”、“新增”、“删除”等）。\n   - 客户端在接收到数据时，根据状态字段或标志位来判断数据的变化类型。\n\n3. **数据差异比较**：\n   - 使用数据比较算法（如哈希比较、差异检测等）来比较新旧数据，识别数据的变化部分。\n   - 只发送数据的变化部分或差异，减少数据传输量和处理成本。\n\n4. **事件驱动更新**：\n   - 使用事件驱动机制，当数据发生变化时，触发事件并发送更新通知。\n   - 客户端订阅相应的事件，接收并处理更新通知。\n\n5. **轮询或查询更新**：\n   - 客户端定期查询或轮询服务器，检查是否有新的数据更新。\n   - 服务器在数据发生变化时，保存更新标志或版本信息，供客户端查询使用。\n\n在实际应用中，可以根据具体需求和场景选择合适的方法或组合使用多种方法来识别和处理数据更新。WebSocket提供了实时通信的能力，使得数据更新的通知和推送可以实时地传输给客户端，从而实现实时数据同步和通知。","tags":["Websocket"],"categories":["Websocket"]},{"title":"windows使用bat启动多个应用","slug":"windows使用bat启动多个应用","url":"/2024/04/21/windows-shi-yong-bat-qi-dong-duo-ge-ying-yong/","content":"\n每次开机都要开几个程序，于是将打开程序的这几个步骤写入到bat脚本中实现点击脚本自动打开的功能。\n\n<!--more-->\n\n首先进入到程序所在目录，这里以启动docsify为例，假如bat文件在桌面,docsify文档在D盘：\n\n```bash\n@echo off\nD:\ncd \"D:\\docs\"\n```\n\n启动docsify并打开chrome浏览器\n\n```bash\nstart docsify serve\nstart chrome http://localhost:3000/\n```\n\n可在启动chrome之前等待5s确保docsify已启动\n\n```bash\ntimeout /t 5\n```\n\n>  `docsify` 是一个基于 JavaScript 的轻量级文档站点生成器。它可以帮助你快速创建和发布文档网站，无需复杂的设置和构建步骤。你可以使用 `docsify` 来构建单页应用（SPA）式的文档网站，支持 Markdown 和 HTML，并提供了一些内置功能，如全文搜索、自动生成的侧边栏等。 \n\n完整示例如下：\n\n```bash\n@echo off\nD:\ncd \"D:\\docs\"\nstart docsify serve\ntimeout /t 5\nstart chrome http://localhost:3000/\n```\n\n可以将这段bat代码保存在bat文件中，之后直接点击bat文件就可以直接启动docsify，并启动chrome浏览器打开文档页面。\n\n以下是关于本文提到的批处理脚本中几个关键命令和语法的简要总结：\n\n### `cd` 命令\n\n- `cd` 是 \"change directory\" 的缩写，用于改变当前的工作目录。\n- 例如：`cd \"D:\\Code\"` 将当前目录更改为 `D:\\plus-doc`。\n\n> 注意: 如果需要切换磁盘，不能执行使用cd\n\n如果bat的目录在c盘，要进入的目录在d:\\plus-doc，则bat中应这么写：\n\n```bash\nD:\ncd D:\\plus-doc\n```\n\n\n### `start` 命令\n\n- `start` 用于启动一个新的命令提示符窗口以执行指定的命令或程序。\n- 例如：`start explorer \"D:\\plus-doc\"` 会在文件资源管理器中打开指定的目录。\n> 注意: 如果不使用start, 这样脚本会在同一个命令提示符窗口中运行命令，并等待其完成后再继续执行脚本的其他部分。\n\n### `timeout` 命令\n\n- `timeout` 用于在脚本中等待指定的时间（以秒为单位）。\n- 例如：`timeout /t 5` 会使脚本暂停 5 秒。\n\n### `pause` 命令\n\n- `pause` 用于暂停批处理脚本的执行并等待用户按下任意键继续。\n- 通常用于脚本的最后，以便用户查看输出或任何可能的错误信息。\n- 例如：`pause` 会在脚本执行到这里时暂停，并显示 \"按任意键继续. . .\"。\n\n这些是基本的批处理脚本命令和语法，你可以根据需要结合使用它们来编写复杂的脚本。\n\n","tags":["BAT"],"categories":["BAT"]},{"title":"利用Gradle优化Android构建流程：自动化处理JavaScript文件","slug":"利用Gradle优化Android构建流程：自动化处理JavaScript文件","url":"/2024/04/21/li-yong-gradle-you-hua-android-gou-jian-liu-cheng-zi-dong-hua-chu-li-javascript-wen-jian/","content":"\n在Android开发的世界中，`build.gradle`文件不仅仅是构建配置的核心——它也是提升构建效率和灵活性的关键工具。通过精心设计的自定义Task，开发者能够在APK的构建流程中插入定制化的操作，如文件的拷贝、删除等。这些操作能够在构建前预处理资源，或在构建后清理临时文件，从而确保最终的APK文件是按照精确的项目需求来打造的。 \n\n<!--more-->\n\n## 什么gradle\nGradle是一个强大的自动化构建工具，它结合了Apache Ant的灵活性和Apache Maven的依赖管理和约定优于配置的理念。Gradle使用Groovy或Kotlin DSL（领域特定语言）来编写构建脚本，而不是传统的XML。这使得Gradle的构建脚本更加简洁和易于理解。\n## gradle在Android APK打包中的作用\n **Gradle** —— 这个在Android开发领域中不可或缺的构建系统，以其强大的功能和灵活性，在Android Studio中占据了官方构建工具的宝座。它赋予开发者无与伦比的能力，让他们可以精确地定义构建配置，高效地管理项目依赖，以及自动化地执行测试和部署任务。这一切，不仅极大提升了开发的效率，更为项目的长期可维护性和稳定性奠定了坚实的基础。 \n## Task的定义\n在 Gradle 中，有多种类型的任务，用于执行不同的操作。以下是一些常见的任务类型：\n1. **Copy**：用于复制文件或目录。\n2. **Delete**：用于删除文件或目录。\n3. **Exec**：用于在操作系统上执行外部命令。\n4. **JavaExec**：用于在 JVM 上执行 Java 类。\n5. **Zip**：用于创建压缩文件。\n6. **Tar**：用于创建 Tar 文件。\n7. **Checkstyle**：用于执行代码风格检查。\n8. **Test**：用于执行测试。\n9. **Compile**：用于编译源代码。\n10. **Clean**：用于清理构建生成的文件。\n11. **Build**：用于构建项目。\n12. **GenerateBuildConfig**：用于生成构建配置文件。\n13. **GenerateResources**：用于生成资源文件。\n\n这里使用 `Exec` 类型的任务执行 Windows 上的 `.bat` 脚本，可以按照以下方式定义任务： \n\n```gradle\ntask runBatchScript(type: Exec) {\n    commandLine 'cmd', '/c', 'path/to/your/script.bat'\n}\n```\n这个task是放在模块(非项目)下的build.gradle文件中的，接着定义这个task的执行时机，可使用preBuild或asemble的相关方法。\n## Task的执行\n在Gradle中，preBuild.dependsOn和assemble.dependsOn都是用来指定任务依赖关系的，但它们在构建生命周期中的作用时机不同。\n**preBuild.dependsOn:** preBuild是一个在Android构建生命周期中非常早期的任务。当指定preBuild.dependsOn时，添加的任务会在编译代码之前执行。这通常用于执行一些准备工作，比如设置环境变量，检查必要的依赖等。\n**assemble.dependsOn:** 相比之下，assemble任务是在编译完成后执行的，它负责将所有的编译结果打包成APK文件。当使用assemble.dependsOn时，添加的任务会在APK打包之前执行。这可以用于最后的检查，比如验证编译结果，或者修改打包内容等。\n简而言之，preBuild.dependsOn用于在编译前执行任务，而assemble.dependsOn用于在打包前执行任务。选择哪一个取决于您想要在构建流程的哪个阶段执行特定的任务。\n除了表示依赖关系，preBuild和assemble还有更多的用法，可以直接在build.gradle文件中查看其属性。\n\n下面是在编译前执行名为runBatchScript的task:\n\n```gradle\npreBuild.dependsOn(runBatchScript)\n```\n如果是编译后执行,可使用\n```gradle\n\n// 在 assemble 任务之后执行拷贝回文件任务\n//assemble{\n//    dependsOn(copyBackFiles)\n//}\n// 在 assemble 任务之后执行删除临时目录任务\nassemble.finalizedBy(copyBackFiles)\n```\n> 说明：在gradle 5.6.4，Android Studio 3.6.3下没起作用。\n\n## 小结\n本文简单介绍了下android apk构建过程中，通过自定义task来干预apk的执行，可据此实现一些诸如js加密处理等的功能，当然Gradle 的任务类型非常灵活，你可以根据需要自定义任务类型来执行各种操作。\n\n在我们的对话中，我们实现了以下步骤：\n\n1. 创建了一个 Gradle 任务来将 `assets` 目录下的某个 JavaScript 文件夹拷贝到临时目录。\n2. 使用了一个批处理脚本（`.bat` 文件）来对临时目录中的 JavaScript 文件进行处理。\n3. 在 Gradle 任务中，将处理后的 JavaScript 文件夹从临时目录拷贝回原 JavaScript 目录。\n4. 执行了打包 APK 的 Gradle 命令。\n5. 创建了一个 Gradle 任务来将临时目录中的 JavaScript 文件拷贝回原 JavaScript 目录，并删除了临时目录。\n\n我们使用了以下技术和方法：\n\n- Gradle：使用 Gradle 构建工具来管理和执行任务。\n- Copy Task：使用 Gradle 的 Copy 任务来实现文件的复制。\n- Exec Task：使用 Gradle 的 Exec 任务来执行外部命令，比如运行批处理脚本。\n- 批处理脚本：编写了一个批处理脚本来处理 JavaScript 文件。\n- 文件操作：使用 Groovy 文件操作 API 来执行文件和文件夹的操作，比如复制、删除等。\n\n通过这些方法，我们成功地实现了对 JavaScript 文件的处理，并将其集成到 Gradle 构建流程中。\n\n\n\n```groovy\ntask createTempDirectory {\n    doLast {\n        // 创建临时目录\n        mkdir 'tempAssets'\n    }\n}\n\ntask copyToTemp(type: Copy, dependsOn: createTempDirectory) {\n    from 'src/main/assets/static/js/logic'\n    into 'tempAssets'\n}\n\ntask runBatScript(type: Exec, dependsOn: copyToTemp) {\n    // 执行批处理脚本\n    commandLine 'cmd', '/c', 'your_script.bat'\n}\n\ntask copyBackToOriginal(type: Copy) {\n    from 'tempAssets'\n    into 'src/main/assets/static/js/logic'\n}\n\ntask deleteTempDirectory(type: Delete) {\n    // 删除临时目录\n    delete 'tempAssets'\n}\n\n// 在 assemble 任务之前执行 copyBackToOriginal 任务\nassemble.dependsOn(copyBackToOriginal)\n// 在 assemble 任务之后执行 deleteTempDirectory 任务\nassemble.finalizedBy(deleteTempDirectory)\n\n```\n\n涉及到的bat\n\n## 文件拷贝\n\n```bash\n@echo off\nset source=xx\\tempAssets\nset destination=xx\\src\\main\\assets\\static\\js\\logic\nxcopy /i /Y \"%source%\" \"%destination%\"\n```\n\n## js加密处理\n\n```bash\n@echo off\nset JS_OBFUSCATOR_PATH=C:\\Users\\Administrator\\AppData\\Roaming\\npm\\javascript-obfuscator.cmd\nset INPUT_PATH=xx\\js\\logic\nset OUTPUT_PATH=xx\\js\\logic2\n%JS_OBFUSCATOR_PATH% %INPUT_PATH% --output %OUTPUT_PATH%\n```\n\n","tags":["Android"],"categories":["Android"]},{"title":"使用apksigner.bat对Android APK重签名","slug":"使用apksigner-bat对Android-APK重签名","url":"/2024/04/08/shi-yong-apksigner-bat-dui-android-apk-chong-qian-ming/","content":"\n本文主要记录使用Android SDK Tools中的apksigner.bat对已经打包的Android APK进行重签名。\n\n<!--more-->\n\n## 开发环境\nOS:windows\n\n## apksigner.bat的使用\n安装Android SDK Build Tools之后，会有apksigner.bat这个文件，可以直接使用这个文件进行重新名，在windows terminal中执行以下命令即可：\n\n```cmd\n./apksigner.bat sign --ks xx.jks --v1-signing-enabled xx.apk\n```\n\n## 验证是否签名\n\n```cmd\n\n./apksigner.bat verify -v xx.apk\n```\n\n## Referenced\n[1、Apk应用重签名—使用AndroidStudio自带工具apksigner](https://blog.csdn.net/java04/article/details/132337611)","tags":["Android"]},{"title":"AndServer：在 Android 应用中构建轻量级 HTTP 服务器","slug":"AndServer：在-Android-应用中构建轻量级-HTTP-服务器","url":"/2024/03/31/andserver-zai-android-ying-yong-zhong-gou-jian-qing-liang-ji-http-fu-wu-qi/","content":"\n本文介绍如何在Android app中搭建一个简单的http服务器。\n\n<!--more-->\n\n> 要实现此类功能，可以使用AndServer,NanoHttpd,本文使用AndServer.关于NanoHttpd的使用，可参考:https://blog.csdn.net/small_and_smallworld/article/details/103393070\n\n\n## 开发环境\nAndroid Studio:2023.1.1\nGradle: 8.2\nAndServer: 2.1.12\n\n## AndServer的配置\n\nAndServer支持部署静态网站、支持反向代理、支持restful和非restful服务，这里只介绍配置，具体的使用可参考其[官方文档](https://yanzhenjie.com/AndServer/qa/)。\n\n在项目下的build.gradle.kts中添加：\n\n```kotlin\nbuildscript{\n    dependencies{\n        classpath(\"com.yanzhenjie.andserver:plugin:2.1.12\")\n    }\n}\n```\n\n在模块下的build.gradle.kts中添加：\n\n```kotlin\nplugins {\n    id(\"com.android.application\")\n    id(\"com.yanzhenjie.andserver\")\n}\n...\ndependencies {\n    implementation(\"com.yanzhenjie.andserver:api:2.1.12\")\n    annotationProcessor(\"com.yanzhenjie.andserver:processor:2.1.12\")\n}\n```\n\n如果你使用的是groovy dsl，可参考如下写法：\n\n```groovy\nbuildscript {\n    repositories {\n        google()\n        mavenCentral()\n    }\n\n    dependencies {\n        classpath 'com.yanzhenjie.andserver:plugin:2.1.12'\n        ...\n    }\n}\n\n...\napply plugin: 'com.yanzhenjie.andserver'\ndependencies {\n    implementation 'com.yanzhenjie.andserver:api:2.1.12'\n    annotationProcessor 'com.yanzhenjie.andserver:processor:2.1.12'\n    ...\n}\n```\n\n## 关于kotlin dsl和groovy dsl\n\n> 赶紧来个人统一下\n\nKotlin DSL（Kotlin Domain-Specific Language）和 Groovy DSL（Groovy Domain-Specific Language）是 Gradle 构建脚本中使用的两种不同语法。它们之间的主要差异如下：\n\n1. **语言**：\n   - **Groovy DSL**：使用 Groovy 编程语言编写。\n   - **Kotlin DSL**：使用 Kotlin 编程语言编写。\n2. **类型检查**：\n   - **Groovy** 是一种动态语言，而 **Kotlin** 是一种静态类型语言。\n   - 在使用 Kotlin DSL 时，构建脚本的错误可能会在编译时而不是运行时被检测到。\n3. **IDE 支持**：\n   - **Kotlin DSL** 在 Android Studio 的代码编辑器中具有更好的集成，包括语法高亮、代码补全和导航到声明等。\n   - **Groovy DSL** 的 IDE 编辑支持相对较弱。\n4. **可读性**：\n   - **Kotlin** 通常被认为更易读，因为它具有清晰的语法和更严格的类型检查。\n5. **性能**：\n   - 使用 **Kotlin DSL** 构建的构建可能会比使用 **Groovy DSL** 构建的构建慢一些。因此，在迁移时需要考虑构建性能。\n\n总之，Kotlin DSL 提供了更好的 IDE 支持和更严格的类型检查，但在构建性能方面可能略逊于 Groovy DSL。可以根据自己的偏好和项目需求选择其中之一。\n\n## 另：关于Android项目的几个gradle文件\n\n在 Android 项目中，有三个关键的 Gradle 文件，它们分别是：\n\n### 模块下的build.gradle.kts 文件：\n模块级别的构建文件，位于每个模块（module）的目录下。\n主要用于配置模块的构建设置，例如编译选项、依赖库、插件等。\n包含了构建逻辑，定义了构建过程中的任务和规则。\n每个模块都有一个独立的 build.gradle.kts 文件。\n\n### settings.gradle.kts 文件：\n项目级别的设置文件，位于项目的根目录下。\n用于配置整个项目的全局设置，例如哪些子项目（subproject）应该包含在构建中。\n声明了项目的子模块，让 Gradle 知道哪些模块应该包括在构建中。\n\n### 项目下的 build.gradle.kts 文件：\n也称为 Project build script。\n用于配置整个项目的构建设置，例如 Gradle 版本、全局的依赖库、插件等。\n这个文件不是模块级别的，而是整个项目的全局设置。\n\n总结一下：\n\nbuild.gradle.kts 文件用于配置模块的构建逻辑和设置。\nsettings.gradle.kts 文件用于配置整个项目的全局设置，包括子模块的声明。\n项目下的 build.gradle.kts 文件用于配置整个项目的全局构建设置。\n\n\n","tags":["Android"],"categories":["Android"]},{"title":"Vue3构建Cesium应用:使用Pinia维护全局变量","slug":"Vue3构建Cesium应用-使用Pinia维护全局变量","url":"/2024/03/23/vue3-gou-jian-cesium-ying-yong-shi-yong-pinia-wei-hu-quan-ju-bian-liang/","content":"\n本文主要介绍如何使用Pinia集中管理全局变量，当然还是主要在Cesium中的应用。\n\n<!--more-->\n\n前面我们使用了依赖注入来向子组件传递viewer对象，本文我们则通过Pinia存储viewer对象，供所有组件使用。\n\n## 安装与注册Pinia\nPinia 是 Vue 的专属状态管理库，它允许你跨组件或页面共享状态。\n```javascript\npnpm install pinia\n```\n\n在`main.js`中创建Pinia实例并使用`app.use(pinia)`注册\n\n```javascript\nimport { createPinia } from 'pinia';\nconst pinia = createPinia();\napp.use(pinia)\n```\n\n## 定义Store\n\n创建stores/global.js文件，并使用`defineStore`定义store，包括`state`, `getters`, 和 `actions`。\n\n其中state中定义变量；actions中定义更新state中的变量；\n\n```javascript\n// store/global.js\nimport { defineStore } from 'pinia';\n\nexport const useGlobalStore = defineStore('global', {\n  state: () => ({\n    // 定义全局状态\n    viewer:null\n  }),\n  getters: {\n    // 定义getters\n    doubleCount: (state) => state.count * 2\n  },\n  actions: {\n    updateViewer(_viewer){\n      this.viewer=_viewer;\n    }\n  },\n});\n\n```\n\n>  注意：以下父组件和子组件的名字描述可能有点问题，只是为了容易理解\n\n## 在父组件中更新viewer的状态\n\n```javascript\nimport { useGlobalStore } from '@/stores/global';\nconst globalStore = useGlobalStore();\nlet viewer=ref(null)\nonMounted(()=>{\n    viewer.value = new Cesium.Viewer(\"map\", {});\n    globalStore.updateViewer(viewer);\n});\n```\n\n\n\n## 子组件中使用state中的viewer\n\n由于viewer只有在页面挂载后才初始化，因此子组件中需要监听viewer：\n\n```javascript\nimport { useGlobalStore } from '@/stores/global';\n\nconst myStore = useGlobalStore();\nlet viewer=null;\nwatch(() => myStore.viewer, (newValue, oldValue) => {\n  viewer=myStore.viewer;\n  showRtCoords(viewer)\n});\n```\n\n这里有2点需要注意：\n\n1. 组件中访问store中的变量时，无需state.someState.value。这是因为Pinia内部已经为状态做了响应式处理。当你在`state`中返回一个对象时，Pinia会自动将其内部的属性转换为响应式引用。这意味着你可以直接通过状态名称访问它们，而无需`.value`。\n2. watch监听state变量时，要使用getter。因为Pinia的`state`中的属性是响应式的，但它们是响应式对象的属性值，而非独立的响应式引用。这与Vue 3的Composition API中的`ref`和`reactive`不同，其中你需要使用`.value`来访问和更新`ref`的响应式值。Pinia抽象了这一层，使得状态访问更加直观和简洁。\n\n> **watch**:  它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组 ，但不能直接侦听响应式对象的属性值 。\n\n","tags":["Cesium","Vue3"],"categories":["Cesium","Vue3"]},{"title":"Vue3构建Cesium应用:Provide/Inject在Viewer对象传递中的应用","slug":"Vue3构建Cesium应用-Provide-Inject在Viewer对象传递中的应用","url":"/2024/03/23/vue3-gou-jian-cesium-ying-yong-provide-inject-zai-viewer-dui-xiang-chuan-di-zhong-de-ying-yong/","content":"\n本文主要介绍Vue3中使用Cesium时，如何通过依赖注入将viewer对象传递给子组件。\n\n<!--more-->\n\n> 背景：想要实现的效果，以组件的形式添加一个实时显示坐标的功能，其中涉及到了viewer向在子组件中传递数据\n\n![](2024-03-23_180750.jpg)\n\n## 使用provide和inject\n\n### 父组件\n\n```javascript\n<script setup>\nimport { provide } from 'vue'\n\nprovide(/* 注入名 */ 'message', /* 值 */ 'hello!')\n</script>\n```\n\n### 子组件\n\n 要注入上层组件提供的数据，需使用 [`inject()`](https://cn.vuejs.org/api/composition-api-dependency-injection.html#inject) 函数： \n\n```javascript\n<script setup>\nimport { inject } from 'vue'\n\nconst message = inject('message')\n</script>\n```\n\n## 如何向子组件传递viewer对象？\n\n有2种方法：\n\n1、在viewer初始化之后再加载子组件\n\n2、使用侦听器\n\n### 1、在viewer初始化之后再加载子组件\n\n父组件：\n\n```javascript\n<rt-loc v-if=\"init\"></rt-loc>\n\n<script setup>\n    import RtLoc from '../components/RtLoc/RtLoc.vue'\n\timport { ref,provide, onMounted } from 'vue'\n    let init=ref(false)\n    let viewer=ref(null)\n    provide('globalViewer',viewer);\n\n\tonMounted(()=>{\n        viewer.value = new Cesium.Viewer(\"map\", {});\n        init.value=true;\n    })\n</script>\n```\n\n子组件RtLoc.vue\n\n```javascript\n<script setup>\nimport { onMounted, ref,inject,watchEffect  } from 'vue'\nimport * as Cesium from 'cesium';\nlet globalVar=inject('globalViewer');\n\nonMounted(()=>{\n  if(globalVar.value){\n    console.log(\"初始化了\"+globalVar.value)\n    showRtCoords(globalVar.value);//注册地图事件\n  }\n  else{\n    console.log(\"为空\")\n  }\n})\n```\n\n### 2、子组件中使用watch或watchEffect\n\n在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。\n\n watch默认是 懒执行的，仅当数据源变化时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调。举例来说，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。 \n\n在组合式 API 中，我们可以使用 [`watch` 函数](https://cn.vuejs.org/api/reactivity-core.html#watch)在每次响应式状态发生变化时触发回调函数。\n\nwatch语法如下：\n\n```javascript\nwatch(\n  source,\n  (newValue, oldValue) => {\n    // 立即执行，且当 `source` 改变时再次执行\n  },\n  { immediate: true }//如果需要立即执行\n  { once: true }//如果需要侦听器是一次性的\n)\n```\n\n此时父组件中的init默认为true:\n\n```javascript\nlet init=ref(true)\n```\n\n子组件：\n\n```javascript\nwatch(globalVar,()=>{\n  if(globalVar.value){\n    console.log(\"初始化了\"+globalVar.value)\n    showRtCoords(globalVar.value);//注册地图事件\n  }\n  else{\n    console.log(\"为空\")\n  }\n});\n或使用watchEffect:\nwatchEffect(()=>{\n  if(globalVar.value){\n    console.log(\"初始化了\"+globalVar.value)\n    showRtCoords(globalVar.value);\n  }\n  else{\n    console.log(\"为空\")\n  }\n})\n```\n\n> `watch` 和 `watchEffect` 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：\n>\n> - `watch` 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。`watch` 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。\n> - `watchEffect`，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。","tags":["Cesium","Vue3"],"categories":["Cesium","Vue3"]},{"title":"一步步来：打造您自己的SFTP服务器","slug":"一步步来：打造您自己的SFTP服务器","url":"/2024/03/23/yi-bu-bu-lai-da-zao-nin-zi-ji-de-sftp-fu-wu-qi/","content":"\n使用sftpgo搭建sftp服务器，以实现文件共享及权限控制。\n\n<!--more-->\n\n> 之前有用过其它文件共享的软件，忘记了具体是哪个了，这次就记录下来。\n\n## 项目地址及简介\n[SFTPGo](https://github.com/drakkan/sftpgo)\n\nFully featured and highly configurable SFTP server with optional HTTP/S, FTP/S and WebDAV support. Several storage backends are supported: local filesystem, encrypted local filesystem, S3 (compatible) Object Storage, Google Cloud Storage, Azure Blob Storage, SFTP. \n\n## 安装及启动\n\n这里是windows下，默认安装到了windows服务，安装完成之后，修改默认配置：\n\n配置文件路径：C:\\ProgramData\\SFTPGo\\sftpgo.json，\n\n调整管理界面的端口号：\n\n```javascript\n  \"httpd\": {\n    \"bindings\": [\n      {\n        \"port\": 9999,\n```\nsftp默认端口号2022,可在配置文件中调整\n\n```javascript\n\"sftpd\": {\n    \"bindings\": [\n      {\n        \"port\": 2022,\n        \"address\": \"\",\n        \"apply_proxy_config\": true\n      }\n    ],\n```\n\n之后在windows服务中启动即可:\n\n管理地址：http://localhost:9999/web/admin 可用来配置用户及权限：\n\n![](2024-03-23_082750.jpg)\n\n最后使用SFTP客户端如winscp连接即可。\n","tags":["运维"]},{"title":"立即执行函数表达式：JavaScript作用域的守护者","slug":"立即执行函数表达式：JavaScript作用域的守护者","url":"/2024/03/23/li-ji-zhi-xing-han-shu-biao-da-shi-javascript-zuo-yong-yu-de-shou-hu-zhe/","content":"\n有的Javascript代码真的很难读啊，本文简单介绍立即执行函数表达式(Immediately Invoked Function Expression，IIFE)模式及其作用。\n\n<!--more-->\n## IIFE定义\nIIFE（立即执行函数表达式）是一种在定义后立即执行的JavaScript函数。并创建一个**封闭的作用域**。语法如下：\n\n```javascript\n(function(){ /* 代码 */ })()\n```\n示例：\n\n```javascript\nvar myModule = (function () {\n    var privateVar = '私有变量';\n    function privateFunction() {\n        console.log(privateVar);\n    }\n    \n    return {\n        publicMethod: function () {\n            privateFunction();\n        }\n    };\n})();\n\nmyModule.publicMethod(); // 输出: 私有变量\n\n```\n\n## 作用\n1. 创建私有作用域：在函数内部声明的变量不会污染全局作用域。\n2. 模块化代码：避免全局变量冲突，保护模块内的私有变量不被外部访问。\n\n## ES6及块级作用域\nES6引入了let和const关键字，提供了块级作用域，减少了IIFE的必要性。\n使用{}与let或const可以创建封闭的块级作用域，保护变量不被外部访问。\n\n如：\n\n```javascript\n// ES6中使用let创建块级作用域\n{\n    let privateVar = '私有变量';\n    // ...\n}\n\n```\n\n [因此，IIFE是一个在ES5及更早版本的JavaScript中常用的模式，而ES6提供了更多的作用域控制方式，减少了IIFE的必要性。但是，IIFE仍然是一个有效的模式，特别是在需要支持旧版JavaScript环境的情况下](https://zh.wikipedia.org/wiki/立即调用函数表达式)[1](https://zh.wikipedia.org/wiki/立即调用函数表达式)。 \n\n## 与其他JavaScript特性的关系\n\nIIFE语法如下：\n```javascript\n(function(){ /* 代码 */ })()\n```\n而JQuery长这样，似乎很相似：\n```javascript\n$(document).ready(function() {\n    // 当DOM加载完成后，这里的代码会执行\n    console.log('文档加载完成!');\n});\n\n// 或者使用简写形式\n$(function() {\n    // 当DOM加载完成后，这里的代码会执行\n    console.log('文档加载完成!');\n});\n```\n但jQuery的$(function(){})，后者是文档就绪事件的简写，不是IIFE。IIFE在某种程度上类似于匿名函数。在JavaScript和TypeScript中，匿名函数是没有具体名称的函数，它们可以被定义并立即执行，也都可以创建一个封闭的作用域来保护变量不被外部访问，这与IIFE的概念相符合。\n\n## IIFE的未来\n随着ES6新特性的普及，IIFE的使用场景减少。现在，开发者可以更方便地通过let和const来控制变量的作用域，而不必依赖IIFE来避免全局作用域的污染。当然，IIFE仍然在一些特定情况下有其用处，尤其是在需要兼容旧版JavaScript环境的项目中。但是，随着现代JavaScript开发的演进，新的语言特性如模块导入（import/export）也提供了更好的封装和作用域管理方式，进一步减少了IIFE的必要性。","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"独立而不孤立：前端样式隔离的策略","slug":"独立而不孤立：前端样式隔离的策略","url":"/2024/03/14/du-li-er-bu-gu-li-qian-duan-yang-shi-ge-chi-de-ce-lue/","content":"\n在使用js设置元素的html时，当里面引入了其他js文件时，可能会影响到外部的元素，此时需要做样式隔离，本文主要探讨前端样式隔离的几种策略。\n\n<!--more-->\n\n> **说明：**本文主要来源于在html中元素中嵌入流程图的流转记录，尝试的方法为Shadow DOM，但涉及到过多脚本和样式，最终还是采取在新页面中查看流程图。\n\n## 使用css命名空间\n\n 给div内部的样式添加特定的前缀或命名空间，以避免样式冲突。 **@namespace**规则通常在处理包含多个 namespaces 的文档时才有用，比如 HTML5 里内联的 SVG、MathML 或者混合多个词汇表的 XML 。如下面这个示例指挥选择svg命名空间种的circle元素：\n\n```javascript\n@namespace svg \"http://www.w3.org/2000/svg\";\n\nsvg|circle {\n  fill: green;\n}\n```\n\n参考： [@namespace - CSS：层叠样式表 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@namespace) \n\n## 使用iframe\n\n 如果将HTML内容放入`iframe`中，那么`iframe`内的样式默认不会影响到外部文档。 \n\n## 使用内联样式\n\n 直接在HTML元素上使用`style`属性定义样式，这样定义的样式只会影响到该元素。 如：\n\n```\n<div style=\"\"></div>\n```\n\n\n\n##  使用**CSS Modules** \n\n这是一种自动为类名生成唯一哈希值的技术，从而确保样式的局部作用域。在构建过程中，CSS Modules会自动转换类名，如：\n\n ```javascript\n<template>\n\n  <p :class=\"$style.red\">This should be red</p>\n\n  <p :class=\"$style.red\">This should be red</p>\n\n  <p :class=\"$style.bold\">This should be bold</p>\n\n</template>\n\n\n\n<style module>\n\n  .red {\n\n    color: red;\n\n  }\n\n  .bold {\n\n    font-weight: bold;\n\n  }\n\n</style>\n\n ```\n\n\n\n##  **使用Scoped CSS** \n\n 在Vue.js等现代前端框架中，您可以使用`scoped`属性在``标签中声明样式，这样样式只会应用于当前组件的元素 ，如：\n\n```javascript\n<style scoped>\n\n  .example {\n\n    color: red;\n\n  }\n\n</style>\n<template>\n\n  <div class=\"example\">hi</div>\n\n</template>\n\n```\n\n同**css modules**的区分：\n\n- **scoped css**: 这是Vue.js特有的一个功能，它允许您将CSS样式限制在单个组件的范围内。当您在一个Vue组件中使用style scoped时，Vue会通过PostCSS转换为每个CSS选择器添加一个独特的属性，如data-v-{hash}，以确保样式只应用于当前组件的元素。\n- **css modules**: 这是CSS Modules的一种实现，它不是Vue特有的，可以在任何支持CSS Modules的构建系统中使用。当您使用style type=\"module\"时，每个类名和动画名都会被编译成一个局部作用域的唯一名称，通常是通过Webpack等构建工具实现的。这意味着您可以在JavaScript中引用这些样式，因为它们被视为模块的一部分。\n\n总的来说，scoped属性更多地依赖于Vue的构建系统和PostCSS插件来实现样式的封装，而type=\"module\"则是利用CSS Modules的技术，它可以跨不同的框架和工具使用。\n\n##  使用**Shadow DOM** \n\n这是Web组件标准的一部分，它允许您将一段DOM与其余的页面隔离开来。在Shadow DOM中的样式不会泄漏到外部，外部样式也不会影响到Shadow DOM内部。 使用步骤如下：\n\n###  **创建宿主元素** \n\n```html\n<div id=\"shadow-host\"></div>\n```\n\n### 附加shadow root\n\n```javascript\nconst hostElement = document.getElementById('shadow-host');\nconst shadowRoot = hostElement.attachShadow({ mode: 'open' });\n```\n\n有2种模式：open和closed,区别在于对Shadow DOM的访问控制，具体如下：\n\n- **Open Mode (`mode: 'open'`)**: 在这种模式下，Shadow DOM是开放的，您可以通过宿主元素的`shadowRoot`属性来访问Shadow DOM。这意味着任何页面上的JavaScript代码都可以查询和操作Shadow DOM内部的节点\n- **Closed Mode (`mode: 'closed'`)**: 在这种模式下，Shadow DOM是封闭的，宿主元素的`shadowRoot`属性将返回`null`，这阻止了外部JavaScript代码访问Shadow DOM。即使您知道Shadow DOM存在，也无法直接与其内部的节点交互\n\n### 添加样式和内容\n\n```javascript\n// 添加内部样式\nconst style = document.createElement('style');\nstyle.textContent = `\n  /* 这里的样式只会影响Shadow DOM内部的元素 */\n  .example { color: red; }\n`;\nshadowRoot.appendChild(style);\n\n// 添加HTML内容\nshadowRoot.innerHTML = '<div class=\"example\">Shadow DOM 内容</div>';\n\n```\n\n 通过这种方式，您可以将样式和内容封装在Shadow DOM中，从而避免对全局样式造成影响。 \n\n另外需要注意的是当通过innerHTML的方式设置内容时，浏览器不会执行内联脚本，即script标签内的内容。\n\n### Shadown DOM中脚本的执行\n\n- 通过动态创建脚本元素\n\n  ```javascript\n  const script = document.createElement('script');\n  script.textContent = 'console.log(\"脚本执行了\");';\n  shadowRoot.appendChild(script);\n  ```\n\n  \n\n- 使用外部脚本\n\n  ```javascript\n  const script = document.createElement('script');\n  script.src = 'path/to/your/script.js';\n  shadowRoot.appendChild(script);\n  ```\n\n  \n\n- 模块化脚本\n\n  ```javascript\n  const script = document.createElement('script');\n  script.type = 'module';\n  script.src = 'path/to/your/module.js';\n  shadowRoot.appendChild(script);\n  ```\n\n> **注意：**这3种方法的前提时shadow dom的模式是open。\n\n## 参考文档\n\n [1、组件间样式隔离的几种方案 · CK's Blog (chenkai.life)](https://chenkai.life/css/css-web-compoent-isolation/#类名添加特定的前缀) \n\n [2、@namespace - CSS：层叠样式表 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@namespace) ","tags":["CSS、HTML"],"categories":["CSS、HTML"]},{"title":"使用vite在vue中快速搭建cesium 3D地图项目","slug":"使用vite在vue中快速搭建cesium-3D地图项目","url":"/2024/03/02/shi-yong-vite-zai-vue-zhong-kuai-su-da-jian-cesium-3d-di-tu-xiang-mu/","content":"\n<!--more-->\n\n## 创建vue应用\n```javascript\nnpm create vue@latest\nnpm install\nnpm run dev\n```\n\n## 安装及配置vite-plugin-cesium-build插件\n\n```\nnpm i vite-plugin-cesium-build\n```\n\n在`vite.config.js`中引入\n\n```javascript\nimport { defineConfig } from 'vite'\nimport cesium from 'vite-plugin-cesium-build'\n\nexport default defineConfig({\n  plugins: [\n    //...\n    cesium()\n  ]\n})\n```\n\n除此以外，插件提供了一些配置项：\n\n```javascript\nexport default defineConfig({\n  plugins: [\n    cesium({\n      /**\n       * 这指示了Cesium包文件夹的位置。\n       * 这意味着将会从这个文件夹中获取CesiumJS的相关资源。\n       */\n      from: 'node_modules/cesium/Build/Cesium',\n\n      /**\n       * 这指示了构建后资源位置。\n       * 这意味着构建后资源会被放在/dist/cesium-package/下\n       */\n      to: 'cesium-package',\n\n      /**\n       * 设置为true时，你需要自行设置CESIUM_BASE_URL\n       */\n      customCesiumBaseUrl: false\n    })\n  ]\n})\n```\ncesium就配置完成了，可以在vue页面中使用了。\n\n## 在vue页面中引入cesium\n\nvue提供2中API风格，选项式 API 和组合式 API,这里以选项式 API 为例：\n\n```javascript\n<template>\n  <div class=\"about\">\n    <div id=\"map\"></div>\n\n  </div>\n</template>\n\n<script>\nimport * as Cesium from 'cesium';\nimport \"cesium/Build/Cesium/Widgets/widgets.css\";\nimport { ref } from 'vue'\n\nexport default {\n  data() {\n    return {\n      viewer:null\n    }\n  },\n\n  methods:{\n    getCurrentLoc(){\n      let t=this.viewer;\n    }\n  },\n\n  mounted() {\n    Cesium.Ion.defaultAccessToken =\"your token\";\n    this.viewer = new Cesium.Viewer(\"map\", {\n      baseLayer: Cesium.ImageryLayer.fromWorldImagery({\n        style: Cesium.IonWorldImageryStyle.AERIAL_WITH_LABELS,\n      }),\n      baseLayerPicker: false,\n    });\n    this.getCurrentLoc();\n  }\n  \n}\n</script>\n\n```","tags":["GIS","Vue","Vite"],"categories":["GIS","Vue","Vite"]},{"title":"js中的import语句","slug":"js中的import语句","url":"/2024/03/02/js-zhong-de-import-yu-ju/","content":"import语句用于导入其他js文件中函数。\n<!--more-->\n\nimport有静态和动态两种形式,前者的需要在script标签中添加type=\"module\",后者import()则无需依赖type=\"module\"的script标签。\n\n> script 标签中使用 nomodule 属性，可以确保向后兼容，这是针对不支持es6语法的浏览器设计的。\n\n## 语法\n\n### 静态导入\n\n```javascript\nimport defaultExport from \"module-name\";\nimport * as name from \"module-name\";\nimport { export1 } from \"module-name\";\nimport { export1 as alias1 } from \"module-name\";\nimport { default as alias } from \"module-name\";\nimport { export1, export2 } from \"module-name\";\nimport { export1, export2 as alias2, /* … */ } from \"module-name\";\nimport { \"string name\" as alias } from \"module-name\";\nimport defaultExport, { export1, /* … */ } from \"module-name\";\nimport defaultExport, * as name from \"module-name\";\nimport \"module-name\";\n\n```\n\n### 动态导入\n\n标准用法的 import 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。\n\n\n```javascript\n\n(async () => {\n  if (somethingIsTrue) {\n    const {\n      default: myDefault,\n      foo,\n      bar,\n    } = await import(\"/modules/my-module.js\");\n  }\n})();\n\n\nimport(\"/modules/my-module.js\").then((module) => {\n  // Do something with the module.\n});\n\nlet module = await import(\"/modules/my-module.js\");\n\n```\n\n## 示例\n\n### file.js\n\n```javascript\nfunction getJSON(url, callback) {\n  let xhr = new XMLHttpRequest();\n  xhr.onload = function () {\n    callback(this.responseText);\n  };\n  xhr.open(\"GET\", url, true);\n  xhr.send();\n}\n\nexport function getUsefulContents(url, callback) {\n  getJSON(url, (data) => callback(JSON.parse(data)));\n}\n\n```\n### 静态导入\n\n```javascript\nimport { getUsefulContents } from \"/modules/file.js\";\n\ngetUsefulContents(\"http://www.example.com\", (data) => {\n  doSomethingUseful(data);\n});\n\n```\n\n### 动态导入\n\n```javascript\n\nconst main = document.querySelector(\"main\");\nfor (const link of document.querySelectorAll(\"nav > a\")) {\n  link.addEventListener(\"click\", (e) => {\n    e.preventDefault();\n\n    import(\"/modules/my-module.js\")\n      .then((module) => {\n        module.loadPageInto(main);\n      })\n      .catch((err) => {\n        main.textContent = err.message;\n      });\n  });\n}\n\n\n```\n\n> 文章来源:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import","tags":["Javascript","ES6"],"categories":["html"]},{"title":"html中实现手写签名","slug":"html中实现手写签名","url":"/2024/02/24/html-zhong-shi-xian-shou-xie-qian-ming/","content":"\nH5带笔锋手写签名，支持PC端和移动端，任何前端框架均可使用。\n\n<!--more-->\n\n[smooth-signature](https://github.com/linjc/smooth-signature)","tags":["手写签名"],"categories":["html"]},{"title":"如何在Windows下以后台方式运行Spring Boot打包的jar包","slug":"如何在Windows下以后台方式运行Spring-Boot打包的jar包","url":"/2023/11/24/ru-he-zai-windows-xia-yi-hou-tai-fang-shi-yun-xing-spring-boot-da-bao-de-jar-bao/","content":"\nSpring Boot是一种流行的Java Web开发框架，它可以快速地创建独立的、生产级的Spring应用程序。Spring Boot应用程序可以打包成jar文件，方便地进行部署和运行。但是，如果我们直接使用`java -jar your-app.jar`命令来运行jar文件，那么程序会在前台运行，占用控制台窗口，而且一旦关闭窗口，程序就会终止。那么，如何在Windows下以后台方式运行Spring Boot打包的jar包呢？本文将介绍两种方法，分别是使用nssm服务和使用powershell脚本。\n\n<!--more-->\n\n## 方法一：使用nssm服务\n\nnssm是一个开源的工具，您可以使用它来创建和管理Windows服务。Windows服务是一种在后台运行的程序，它可以在系统启动时自动运行，也可以手动启动或停止。使用nssm服务的优点是，您可以方便地管理多个jar文件，也可以设置服务的属性，如用户、日志、依赖等。使用nssm服务的步骤如下：\n\n1. 下载nssm工具，解压缩后得到nssm.exe文件。\n2. 在命令行中运行`nssm install your-app`，这会弹出一个窗口，让您填写服务的相关信息。\n3. 在Application标签页中，填写以下信息：\n    - Path: 您的Java运行时环境的路径，如`C:\\Program Files\\Java\\jdk1.8.0_181\\bin\\javaw.exe`。\n    - Startup directory: 您的jar文件所在的目录，如`C:\\path\\to\\your\\app`。\n    - Arguments: 您运行jar文件的参数，如`-jar your-app.jar`。\n    - Service name: 您的服务的名称，如`your-app`。\n4. 点击Install service按钮，这会创建一个名为your-app的服务，并在系统启动时自动运行。\n5. 您可以使用`nssm start your-app`命令启动服务，或者使用`nssm stop your-app`命令停止服务。\n6. 您可以使用`nssm status your-app`命令查看服务的状态，或者使用`nssm edit your-app`命令修改服务的信息。\n7. 您可以使用`nssm remove your-app`命令删除服务，或者使用`nssm gui`命令打开图形界面管理服务。\n\n## 方法二：使用powershell脚本\n\npowershell是一种强大的脚本语言，您可以使用它来运行或关闭多个jar文件，并且可以指定关闭哪个jar文件。使用powershell脚本的优点是，您不需要安装任何额外的工具，也可以灵活地控制程序的运行。使用powershell脚本的步骤如下：\n\n1. 创建一个名为start.ps1的文件，内容如下：\n\n```powershell\nWrite-Host \"Starting jar files...\"\nStart-Process -FilePath \"javaw\" -ArgumentList \"-jar your-app-1.jar\" -WindowStyle Hidden\nStart-Process -FilePath \"javaw\" -ArgumentList \"-jar your-app-2.jar\" -WindowStyle Hidden\nStart-Process -FilePath \"javaw\" -ArgumentList \"-jar your-app-3.jar\" -WindowStyle Hidden\nWrite-Host \"Done.\"\n```\n\n这个文件会在后台运行三个jar文件，您可以根据您的需要添加或删除jar文件。\n\n2. 创建一个名为stop.ps1的文件，内容如下：\n\n```powershell\nWrite-Host \"Stopping jar files...\"\n$processes = Get-Process -Name \"javaw\"\nforeach ($process in $processes) {\n    $commandLine = (Get-WmiObject Win32_Process -Filter \"ProcessId = $($process.Id)\").CommandLine\n    if ($commandLine -like \"*your-app-1.jar*\") {\n        Write-Host \"Stopping your-app-1.jar\"\n        Stop-Process -Id $process.Id -Force\n    }\n    if ($commandLine -like \"*your-app-2.jar*\") {\n        Write-Host \"Stopping your-app-2.jar\"\n        Stop-Process -Id $process.Id -Force\n    }\n    if ($commandLine -like \"*your-app-3.jar*\") {\n        Write-Host \"Stopping your-app-3.jar\"\n        Stop-Process -Id $process.Id -Force\n    }\n}\nWrite-Host \"Done.\"\n```\n\n这个文件会关闭所有包含jar文件名的javaw进程，您可以根据您的需要添加或删除jar文件。\n\n3. 双击start.ps1文件，或者在命令行中运行`powershell -ExecutionPolicy Bypass -File start.ps1`，这会在后台运行jar文件。\n4. 双击stop.ps1文件，或者在命令行中运行`powershell -ExecutionPolicy Bypass -File stop.ps1`，这会关闭jar文件。\n5. 您可以使用任务管理器查看程序的进程，或者使用`Get-Process -Name \"javaw\"`命令查看程序的信息。\n\n以下是一个示例的powershell脚本的运行结果：\n\n```powershell\nPS C:\\path\\to\\your\\app> powershell -ExecutionPolicy Bypass -File start.ps1\nStarting jar files...\nDone.\nPS C:\\path\\to\\your\\app> Get-Process -Name \"javaw\"\n\nHandles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName\n-------  ------    -----      -----     ------     --  -- -----------\n    328      23    50764      79876       0.28   4788   1 javaw\n    328      23    50764      79876       0.28   4788   1 javaw\n    328      23    50764      79876       0.28   4788   1 javaw\n\nPS C:\\path\\to\\your\\app> powershell -ExecutionPolicy Bypass -File stop.ps1\nStopping jar files...\nStopping your-app-1.jar\nStopping your-app-2.jar\nStopping your-app-3.jar\nDone.\nPS C:\\path\\to\\your\\app> Get-Process -Name \"javaw\"\nGet-Process : Cannot find a process with the name \"javaw\". Verify the process name and call the cmdlet again.\nAt line:1 char:1\n+ Get-Process -Name \"javaw\"\n+ ~~~~~~~~~~~~~~~~~~~~~~~~~\n    + CategoryInfo          : ObjectNotFound: (javaw:String) [Get-Process], ProcessCommandException\n    + FullyQualifiedErrorId : NoProcessFoundForGivenName,Microsoft.PowerShell.Commands.GetProcessCommand\n```\n\n## 总结\n\n本文介绍了如何在Windows下以后台方式运行Spring Boot打包的jar包的两种方法，分别是使用nssm服务和使用powershell脚本。这两种方法各有优缺点，您可以根据您的需求和喜好选择适合您的方法。如果您有任何疑问或建议，欢迎在评论区留言。谢谢您的阅读！","tags":["Java"],"categories":["Java"]},{"title":"一些对程序员有用的网站","slug":"一些对程序员有用的网站","url":"/2023/02/12/yi-xie-dui-cheng-xu-yuan-you-yong-de-wang-zhan/","content":"\n\n\n本文来自[程序员应该访问的最佳网站](https://github.com/tuteng/Best-websites-a-programmer-should-visit-zh)\n\n<!--more-->\n\n# 程序员应该访问的最佳网站中文版[原版](https://github.com/sdmg15/Best-websites-a-programmer-should-visit)\n\n一些对程序员有用的网站\n\n在学习CS的时候有一些你必须知道的有用的站点来获取通知为了你的技术储备和学习新知识。这里是一个你应该访问的不是非常全面的一些站点的列表，这个列表会不断更新，只要我能得到链接，你也可以通过添加你知道的来为此做出贡献\n\n\n<h3>Index</h3>   \n* [当你遇到问题时](#when-you-get-stuck)\n* [新闻篇](#news)\n* [杂志篇](#magazines)\n* [针对新手的代码训练](#coding-practice-for-beginners)\n* [加密货币](#cryptocurrency)\n* [针对那些想开始一个小的项目但是无从下手的人](#for-those-who-want-to-start-a-small-project-but-cant-find-the-ideas)\n* [通用编码建议](#general-coding-advice)\n* [编码风格](#coding-style)\n* [通用工具](#general-tools)\n* [面试准备](#interview-preparation)\n* [纪录片](#documentaries)\n* [学习新知识-mooc](#moocs-for-learning-something-new)\n* [与你首选的编程语言的站点(对我来说是java)](#sites-related-to-your-preferred-programming-language-for-me-java)\n* [AI学习](#learn-ai)\n* [研讨会、研究性写作、会谈等](#seminar--research-writing--talks-etc)\n* [Reddit知识汇总](#everything-in-one-place)\n* [Youtube频道](#youtube-channels)\n* [好文章](#good-articles)\n* [bash和shell脚本](bash-and-shell-scripting)\n* [播客](#podcasts)\n* [构建一个简单的编译器/解释器](#building-a-simple-compilerinterpreter)\n* [欣赏他人的代码](#watch-others-code)\n* [教程](#tutorials)\n* [一个程序员应该知道的东西](#what-should-a-programmer-know)\n* [编程比赛](#competitive-programming)\n* [计算机书籍](#computer-books)\n* [视频指南](#video-tutorials)\n* [在线编译和共享代码片段](#online-compiler-and-sharing-code-snippets)\n* [开发者博客](#blogs-of-developers)\n* [用来提高你的英语](#for-improving-your-english)\n* [当你厌倦了CS相关的东西](#when-you-get-bored-from-cs-related-stuff)\n* [开源网站](#open-source-websites)\n\n<h1 id='when-you-get-stuck'>当你遇到问题时</h1>\n[Codementor](https://www.codementor.io): 国际版在行，更侧重于开发者之间的帮助，可以从某些方面的专家那里获取帮助\n[devRant](https://www.devrant.io): 供你吐槽和释放压力的地方\n[Learn Anything](https://learn-anything.xyz/): 帮助你找到学习任何知识时的最佳路径\n[Quora](https://www.quora.com/): 一个共享知识和更好的理解世界的地方\n[Stack Overflow](http://stackoverflow.com/): 订阅他们的每周新闻和任何你感兴趣的主题\n\n<h1 id='news'>新闻篇</h1>\n[ACM TechNews](http://technews.acm.org) : 科技新闻\n[Stratechery](https://stratechery.com) : 类似于个人博客\n[AlternativeTo](https://alternativeto.net) : 众包软件推荐\n[Ars Technica](https://arstechnica.com) : 精品文章\n[Better Dev Links](https://betterdev.link) : 每周一次的链接推送帮助你成为更好的开发者\n[DevOpsLinks](http://devopslinks.com) : 一个对DevOps感兴趣的众多开发者和it专家的在线社区\n[GSMArena.com](http://www.gsmarena.com) : 与最新手机和android相关的新闻\n[Hacker News Digest](https://hndigest.com) : Hacker News文摘\n[Hacker News](https://news.ycombinator.com/): 针对程序员的新闻聚合，通过新闻稿获取头条新闻\n[Hacker Newsletter](http://www.hackernewsletter.com/) : 手工编辑，周周更新\n[Hacker Noon](https://hackernoon.com) : 一些技术科技类文章的网站\n[High Scalability](http://highscalability.com) : 不同公司在他们的apps上的成功的故事\n[Lobsters](https://lobste.rs/) : Lobsters是一个聚焦于技术的社区，主要是链接聚合和对话题进行讨论\n[product hunt ](https://www.producthunt.com/) : 寻找你最喜欢的东西\n[Recode](https://www.recode.net) : 聚焦硅谷商业的科技新闻\n[Reddit.com/r/programming](https://www.reddit.com/r/programming/) :科技新闻和文章的聚合\n[Slashdot](https://slashdot.org) : 新闻，社会新闻\n[Stack Share](https://stackshare.io) :各公司技术栈共享站点\n[TechCrunch](http://techcrunch.com/) : 一个科技新闻的站点\n[The DEV Community](https://dev.to) : 程序员分享想法和互相帮助的地方\n[Ars Technica](http://arstechnica.com/) : 发表的独特的精品文章\n[The Verge](https://www.theverge.com) : 更多面向产品的科技新闻\n[XDA](https://www.xda-developers.com) :Android开发者新闻\n\n<h1 id='magazines'>杂志篇</h1>\n[Mit技术评论](https://www.technologyreview.com/magazine/) :麻省理工学院技术评论杂志\n[Nautilus](http://nautil.us) : 纽约人看技术\n[LWN](https://lwn.net) :开源技术，编程等的新闻周刊等（原linux每周新闻）\n\n\n<h1 id='coding-practice-for-beginners'>针对初学者的代码练习</h1>\n[Cave of programming](https://caveofprogramming.com/) : 学习编程，提升技巧\n[Codeacademy](https://www.codecademy.com/) : 交互式编码学习，免费\n[CodeAbbey - 一个任何人都能精通编程的地方](http://codeabbey.com/) : 从菜鸟到专家进阶之地\n[Exercism.io](http://exercism.io/) : 用超过30种不同的语言解决实践问题，与其他人分享你的解决方案\n[freeCodeCamp](https://www.freecodecamp.com/) : 学习编码并且为非营利性组织构建项目。打造你的全栈开发技能\n[karan/Projects-Solutions](https://github.com/karan/Projects-Solutions) 用不同语言实现的项目\n[Lod - Cloud](http://lod-cloud.net/) : 开放数据云图\n[Programming by Doing](http://programmingbydoing.com/) : 编程进阶站点\n[Reddit.com/r/dailyprogrammer](http://www.reddit.com/r/dailyprogrammer) :  有趣的编程挑战，在这里你能学习其他人的编码，对于你解决不了的编码你能看看其他人是怎么解决的\n[People Can Program](https://www.peoplecanprogram.com) :互联网上最友好的编程学习应用\n[Programming Tasks](http://rosettacode.org/wiki/Category:Programming_Tasks) : 小程序汇总，不是微信的小程序\n[Vim adventures](https://vim-adventures.com) :边玩边学vim\n[Pramp](https://www.pramp.com) : 尝试面试官角色，结束后，可以点击左边的按钮交换角色\n[Paqmind](http://paqmind.com) :学习编程的指南和挑战\n[treehouse](https://teamtreehouse.com) :快速容易和经济实惠的方法来提升技巧\n\n<h1 id='cryptocurrency'>加密货币</h1>\n[加密货币爱好者必知内容](http://www.ofnumbers.com/2017/09/21/eight-things-cryptocurrency-enthusiasts-probably-wont-tell-you/) :加密货币爱好者必须要知道的8项内容\n[区块链基础](https://www.sitepen.com/blog/2017/09/21/blockchain-basics/) :区块链介绍\n\n<h1 id='for-those-who-want-to-start-a-small-project-but-cant-find-the-ideas'>针对那些想开始一个小的项目但是无从下手的人</h1>\n[freeCodeCamp | React project ideas](https://medium.freecodecamp.org/every-time-you-build-a-to-do-list-app-a-puppy-dies-505b54637a5d?gi=c786640fbd11) :学习react的27个有趣的想法\n[martyr2s-mega-project-ideas-list](http://www.dreamincode.net/forums/topic/78802-martyr2s-mega-project-ideas-list/) : 包含125个项目，从初级到中级\n[karan/Projects](https://github.com/karan/Projects) : 针对新手的小项目的汇总\n[Wrong \"big projects\" for beginners](http://rodiongork.tumblr.com/post/108155476418/wrong-big-projects-for-beginners) : 怎样选择，从哪里开始\n[vicky002/1000-Projects](https://github.com/vicky002/1000_Projects) : 一个能够用任何编程语言解决的巨型项目清单 \n\n<h1 id='general-coding-advice'>通用编码建议</h1>\n[成为一名优秀开发者的10种方法](https://stephenhaunts.files.wordpress.com/2014/04/10-ways-to-be-a-better-developer.png)\n[代码审查最佳实践](http://kevinlondon.com/2015/05/05/code-review-best-practices.html): Kevin London的博客\n[Dieter Rams : 好的产品设计的10个原则](https://stephenhaunts.com/2013/12/11/dieter-rams-10-principles-of-good-product-design/)\n[设计模式](https://sourcemaking.com/design_patterns) : 用例子详细说明设计模式\n[如何成为一个程序员或谷歌搜索的艺术](https://okepi.wordpress.com/2014/08/21/how-to-become-a-programmer-or-the-art-of-googling-well/)\n[js项目指南](https://github.com/wearehive/project-guidelines):javascript项目最佳实践集合\n[Learn to Code With Me](https://learntocodewith.me) : 一个资源非常全的网站，旨在为科技界的开发人员提供资源\n[一个程序员一生应遵循的原则](http://thecodist.com/article/lessons_from_a_lifetime_of_being_a_programmer)\n[编程规范](https://webpro.github.io/programming-principles/) :程序设计原理与模式分类综述\n[软件设计模式](https://en.wikipedia.org/wiki/Software_design_pattern) : 设计模式的汇总\n[良好的编程原则](http://www.artima.com/weblogs/viewpost.jsp?thread=331531)\n[我希望在我一开始学习编码的时候就能得到的一些建议 — Free Code Camp](https://medium.freecodecamp.com/things-i-wish-someone-had-told-me-when-i-was-learning-how-to-code-565fc9dcb329#.y5wbd3pj6) : 从教别人处学到的东西\n[在计算机科学专业应该知道什么](http://matt.might.net/articles/what-cs-majors-should-know/) :良好的编程规范\n[软件开发者的工作](https://henrikwarne.com/2012/12/12/working-as-a-software-developer/) : Henrik Warne的博客\n\n<h1 id='coding-style'>编码风格</h1>\n[Airbnb JS 风格指南](https://github.com/airbnb/javascript) : 写JavaScript最好的方式  \n[Airbnb Ruby 风格指南](https://github.com/airbnb/ruby) : Airbnb的ruby风格指南\n[Ruby 编码风格指南](https://github.com/bbatsov/ruby-style-guide) : 社区驱动的Ruby编码风格指南\n[Angular 1 风格指南](https://github.com/johnpapa/angular-styleguide/tree/master/a1) : 官方认可的风格指南，作者John Pappa\n[CS 106B 编码风格指南](http://stanford.edu/class/archive/cs/cs106b/cs106b.1158/styleguide.shtml) : 代码臃肿者必看  \n[调试问题](http://www.umich.edu/~eecs381/generalFAQ/Debugging.html) :检查如何调试程序\n[CS课程目录(许多在线讲座)](https://github.com/prakhar1989/awesome-courses) : 另一个在线CS课程\n[在线CS课程目录](https://github.com/open-source-society/computer-science) : 免费的在线CS课程\n[优秀的 C 编码习惯 • /r/C_Programming](https://www.reddit.com/r/C_Programming/comments/1vuubw/good_c_programming_habits/)  \n[google C++ 编码风格](https://google.github.io/styleguide/cppguide.html)  \n[怎样高效的报告Bug](http://www.chiark.greenend.org.uk/~sgtatham/bugs.html)  \n[建议初学者避免使用的坏的编码习惯?](https://www.reddit.com/r/learnprogramming/comments/1i4ds4/what_are_some_bad_coding_habits_you_would/)  \n[PEP8 - Python编码风格指南](https://www.python.org/dev/peps/pep-0008/)\n[标准 JS 风格指南](https://standardjs.com) : JavaScript风格指南\n[Google Python 风格指南](https://google.github.io/styleguide/pyguide.html)\n[Aurelia 风格指南](https://github.com/behzad888/Aurelia-styleguide)\n\n<h1 id='general-tools'>通用工具</h1>\n* [CodePad](https://codepad.remoteinterview.io/DDCUYLAEYS) : 远程面试工具\n* [CodePen](https://codepen.io) : 基于浏览器共享前端代码的地方\n* [Devicons](http://vorillaz.github.io/devicons/#/main) : 免费图标汇总\n* [regex101](https://regex101.com) : 在线正则表达式测试和调试，国内也有不少\n* [regexr](https://regexr.com) : 另一个在线学习、测试正则表达式的工具\n* [Wit AI](https://wit.ai) :帮助开发者灵活的控制应用，适合没有移动端开发经验的用户\n\n<h2 id='#'>bash和shell脚本</h2>\n* [Advanced Bash-Scripting Guide](http://tldp.org/LDP/abs/html/) :对shell脚本艺术的深入挖掘\n* [Bash Guide for Beginners](http://www.tldp.org/LDP/Bash-Beginners-Guide/html/) :对新手的bash使用指南\n* [Bash编程](http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html)\n* [Bash参考手册](https://www.gnu.org/software/bash/manual/bashref.html) \n* [Bash指南](http://mywiki.wooledge.org/BashGuide)\n* [Conquering the Command Line](http://conqueringthecommandline.com/book/frontmatter) : 针对开发者的Unix和Linux命令\n\n<h2 id='interview-preparation'>面试准备</h2>\n  * [/r/cscareerquestions](https://www.reddit.com/r/cscareerquestions/comments/20ahfq/heres_a_pretty_big_list_of_programming_interview/) : 这是一个非常大的面试问题列表是我在为4大面试时用到的，我认为对大家也是有用的\n  * [10个最频繁的SQL查询面试问题](http://java67.blogspot.in/2013/04/10-frequently-asked-sql-query-interview-questions-answers-database.html)\n  * [逻辑题答案汇总](http://puzzles.nigelcoldwell.co.uk/)\n  * [算法设计流程](http://www.hiredintech.com/algorithm-design/)\n  * [资质问题与答案](http://www.indiabix.com/) : Quant and aptitude preparation\n  * [一个技术面试题，逻辑题等的站点](http://www.techinterview.org/) : 各种让你思考的东西\n  * [BeehYve](https://www.beehyve.io) :各种学生需要的资源\n  * [面试准备时的链接的汇总 • /r/cscareerquestions ](https://www.reddit.com/r/cscareerquestions/comments/2lzc4h/big_collection_of_interview_preparation_links/)\n  * [算法复杂度笔记](http://bigocheatsheet.com/#)\n  * [大家的误解](http://ssp.impulsetrain.com/big-o.html)\n  * [位操作技巧](https://gist.github.com/dideler/2365607)\n  * [ChiperSoft/InterviewThis](https://github.com/ChiperSoft/InterviewThis) : 在面试期间问到对公司的了解的问题\n  * [Code Project](https://www.codeproject.com) : 面向开发人员\n  * [Java核心面试问题 - 每个主题的面试题 ](http://javahonk.com/core-java-interview-questions/)\n  * [一些有趣的C问题 ](http://www.gowrikumar.com/c/index.php)\n  * [CS9: CS技术面试中的问题解决](http://web.stanford.edu/class/cs9/)\n  * [优秀的逻辑题](http://gurmeet.net/puzzles/)\n  * [确定不同循环的时间复杂度?](http://stackoverflow.com/questions/11094330/determining-the-big-o-runtimes-of-these-different-loops) :在stackoverflow上的一些好问题包括计算时间复杂度.\n  * [5个基本的电话面试问题 - steveyegge2 ](https://sites.google.com/site/steveyegge2/five-essential-phone-screen-questions)\n  * [新人面试](http://placementsindia.blogspot.in/)\n  * [GeeksforGeeks | 针对geek的计算机科学入门](http://www.geeksforgeeks.org/) : 订阅他们获取新文章\n  * [准备学习SQL篇：用语言描述一下数据库规范化 - Essential SQL ](http://www.essentialsql.com/get-ready-to-learn-sql-database-normalization-explained-in-simple-english/)\n  * [https://github.com/odino/interviews](https://github.com/odino/interviews) : 面试重要问题列表\n  * [让你的简历改头换面](http://www.lifeclever.com/give-your-resume-a-face-lift/)\n  * [技术面试指南](http://www.kchodorow.com/blog/2013/02/28/guide-to-tech-interviews/)\n  * [如何为技术面试做准备• /r/cscareerquestions](https://www.reddit.com/r/cscareerquestions/comments/1jov24/heres_how_to_prepare_for_tech_interviews/)\n  * [怎样进行算法面试](http://www.palantir.com/2011/09/how-to-rock-an-algorithms-interview/)\n  * [怎样进行自我介绍 | The Art of Manliness ](http://www.artofmanliness.com/2016/01/05/tell-me-a-little-about-yourself/)\n  * [如何回答最棘手的40个面试问题| ICS Job Portal ](http://www.icsjobportal.com/blog/job-interview-questions/)\n  * [如何进入科技企业-求职和面试指南](http://haseebq.com/how-to-break-into-tech-job-hunting-and-interviews/)  \n  * [怎样面试](http://kelukelu.me/interview/index.html)\n  * [怎样准备一个面试 - 1](http://se7so.blogspot.in/2014/01/how-to-prepare-for-interview-1.html)\n  * [IIT Delhi 实习经验](http://placement-iit2013.blogspot.com) : \n  * [samwincott/Internship-Guide](https://github.com/samwincott/Internship-Guide) : 与实习相关的链接汇总\n  * [华尔街面试](https://blogs.janestreet.com/interviewing-at-jane-street/)\n  * [面试架构 - Java Honk](http://javahonk.com/category/interview/)\n  * [工作面试：如何做好求职面试|展示个人魅力 ](http://www.artofmanliness.com/2012/08/06/how-to-ace-a-job-interview/)\n  * [求职面试新闻、视频、评论和八卦 - Lifehacker ](http://lifehacker.com/tag/job-interviews)\n  * [求职面试问题和最佳答案](https://www.thebalance.com/job-interview-questions-and-answers-2061204)\n  * [kimberli/interviews](https://github.com/kimberli/interviews) : 面试学习表格\n  * [Mission-peace/interview problems ](https://github.com/mission-peace/interview/wiki) : 一个大的编码面试的问题的汇总\n  * [软件工程师面试实践平台](https://www.pramp.com/ref/gt1) :与真正的同行进行编程交流\n  * [Problems | LeetCode OJ ](https://leetcode.com/problemset/algorithms/) : 针对面试的编码训练\n  * [程序员和软件面试问答](http://www.programmerinterview.com/)\n  * [Reddit.com/user/ashish2199/m/puzzles](https://www.reddit.com/user/ashish2199/m/puzzles) : Reddit逻辑题\n  * [SQL面试问题](https://www.jitbit.com/news/181-jitbits-sql-interview-questions/) : 好的SQL测试\n  * [使用韦恩图进行SQL连接](http://stevestedman.com/wp-content/uploads/VennDiagram1.pdf)\n  * [svozniuk/java-interviews](https://github.com/svozniuk/java-interviews) : Java面试题\n  * [25个最难的HR问题 ](http://www.datsi.fi.upm.es/~frosal/docs/25mdq.html)\n  * [面试10大算法](http://www.programcreek.com/2012/11/top-10-algorithms-for-coding-interview/)\n  * [Unix／Linux笔记](http://cheatsheetworld.com/programming/unix-linux-cheat-sheet/)\n  * [为求职者和雇主提供的建议](https://www.reddit.com/r/india/comments/1clgdj/unsolicited_advice_for_job_seekers_and_employers/)\n  * [通过动画可视化数据结构和算法](http://visualgo.net/)\n  * [We Help Coders Get Hired](http://www.hiredintech.com/app) : 提供系统设计，面试策略，软件技能等的web站点\n  * [你的问题是什么?](https://www.reddit.com/r/cscareerquestions/comments/209rkq/what_are_your_goto_questions_for_the_do_you_have/)\n  * [为何你会赚钱少 • /r/cscareerquestions](https://www.reddit.com/r/cscareerquestions/comments/1b8wa3/why_you_make_less_money/)\n  * [ wu :: riddles(hard) ](https://www.ocf.berkeley.edu/~wwu/riddles/hard.shtml) : 逻辑题\n  * [夏季实习：最终篇](eulercoder.me/blog/career/Summer-Internship-the-ultimate-guide)\n  * [求职面试问题和最好的答案](http://jobsearch.about.com/od/interviewquestionsanswers/a/interviewquest.htm)\n  * [Java面试问题与答案](http://adnjavainterview.blogspot.in)\n  * [编程语言概念 课堂笔记 ](http://www.cmi.ac.in/~madhavan/courses/pl2006/lecturenotes/lecture-notes/lecture-notes.html) :  面向对象概念和编程语言概念\n  * [系统设计面试](https://github.com/checkcheckzz/system-design-interview)\n  * [一个站点提供技术面试题，逻辑题或者你想的其他内容 ](http://www.techinterview.org/)\n  * [前端常见面试题汇总](https://www.geekjc.com/ebook/detail/5ba5bcae7143880b09cb4d54/1537588096871)\n\n<h1 id='documentaries'>纪录片</h1>\n  * [什么都能问 Gayle Laakmann McDowell (程序员面试宝典的作者)](https://www.youtube.com/watch?v=1fqxMuPmGak)\n  * [Breaking the Code: Alan Turing传](https://www.youtube.com/watch?v=S23yie-779k)\n  * [攻破代码面试](https://www.youtube.com/watch?v=4NIb9l3imAo)\n  * [攻破代码面试-全栈开发演讲者系列](https://www.youtube.com/watch?v=Eg5-tdAwclo)\n  * [书呆子的胜利](https://www.youtube.com/playlist?list=PLn-Y3vvQbmHO5WUcBdIWqiUfNawhC1cn3) : Play-list\n  * [哈佛大学 CS50 - 渐进学习 (视频)](https://www.youtube.com/watch?v=iOq5kSKqeR4)\n  * [cpu如何执行程序(视频)](https://www.youtube.com/watch?v=42KTvGYQYnA)\n  * [机器代码指令(视频)](https://www.youtube.com/watch?v=Mv2XQgpbTNE)\n  * 机器改变世界 - 关于计算机历史的纪录片\n      [Part 1: 巨大的大脑 ](http://www.youtube.com/watch?v=rcR74y61xZk)\n      [Part 2: 发现未来](http://www.youtube.com/watch?v=1APZ5-cjWfw)\n      [Part 3: 台式计算机](http://www.youtube.com/watch?v=zwC3gOudlAc)\n      [Part 4: 机器的思考](http://www.youtube.com/watch?v=4gzpd0irP58)\n      [Part 5: 指尖上的世界](http://www.youtube.com/watch?v=J_3A2jSnvHE)\n  * [机械计算机(All Parts) ](https://www.youtube.com/watch?v=s1i-dnAH9Y4) : 20世纪50年代的一个视频，说明了在没有现代电子的情况下机械计算机是如何工作的\n  * [Project Code Rush - netscape/mozilla起源的纪录片](https://www.youtube.com/watch?v=a-49a_CjH0M)\n  * [自学计算机科学](https://teachyourselfcs.com/)\n  * [Linux的故事](https://www.youtube.com/watch?v=XMm0HsmOTFI)\n  * [Download: 互联网的真实故事](https://www.youtube.com/playlist?list=PL_IlIlrxhtPMqW4b0-v8OgLvFZQes6SoZ) : 发现频道关于浏览器战争和互联网泡沫的记录\n  * [Linux操作系统的故事 ](https://www.youtube.com/watch?v=fxjElWL8igo)\n\n<h1 id='moocs-for-learning-something-new'>学习新知识-mooc</h1>\n  * [课程中心](https://www.class-central.com) : 超过10万名学生评价的目录\n  * [计算机科学资源 ](https://docs.google.com/spreadsheets/d/1BD8BJJUNaX63m2QmySWMGDp71nx4W4MyyiIBlfMoN3Q/htmlview?sle=true#) : 针对自学者的mooc列表\n  * [Coursera.org](https://www.coursera.org) :在网上学习全世界最好的课程\n  * [CS50](https://www.youtube.com/user/cs50tv/videos)\n  * [edX](https://www.edx.org) : 免费在线课程，帮助你进步，改善你的生活\n  * [Kadenze | Creative Programming](https://www.kadenze.com/courses?subjects%5B%5D=7): 注重艺术和创造力的编程课\n  * [麻省理工学院电气工程和计算机科学](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/)  \n  * [MOOC.fi](http://mooc.fi/english.html) : 赫尔辛基大学在线课程\n  * [NPTEL Vidoes COMP_SCI_ENGG ](https://onlinecourses.nptel.ac.in/explorer/search?category=COMP_SCI_ENGG)  \n  * [prakhar1989/awesome-CS-courses](https://github.com/prakhar1989/awesome-courses/blob/master/README.md) : CS课程大汇总\n  * [Udacity](http://udacity.com/)\n  * [UCBerkeley](https://www.youtube.com/user/UCBerkeley/videos)\n  * [网上CS课程的收集](https://github.com/prakhar1989/awesome-courses/blob/master/README.md)\n  * [极客教程](https://www.geekjc.com)\n\n<h1 id='sites-related-to-your-preferred-programming-language-for-me-java'>与你偏爱的编程语言相关的网站(对我来说是Java)</h1>\n  * [学习java的最好的书](https://javahungry.blogspot.com/2014/02/best-books-for-learning-java-must-read.html) : Java基础\n  * [Bjarne Stroustrup's C++风格和技术问答](http://www.stroustrup.com/bs_faq2.html) : C++问答\n  * [Bjarne Stroustrup's FAQ](http://www.stroustrup.com/bs_faq.html) : The C++ FAQ\n  * [C++11 -新的ISO C++ 标准](http://www.stroustrup.com/C++11FAQ.html) : C++11问答\n  * [编译器(视频)](https://www.youtube.com/playlist?list=PLO9y7hOkmmSGTy5z6HZ-W4k2y8WXF7Bff)\n  * [深入Java：垃圾回收!](https://www.infoq.com/presentations/garbage-collection-benefits)\n  * [免费在线的章节用来学习java虚拟机](http://www.artima.com/insidejvm/ed2/index.html)\n  * [垃圾搜集如何工作](http://www.dynatrace.com/en/javabook/how-garbage-collection-works.html)  \n  * [算法、数据结构、面试问题和答案的实现 ](https://github.com/sherxon/AlgoDS)\n  * [IntelliJ键盘快捷键](https://www.jetbrains.com/help/idea/keyboard-shortcuts-you-cannot-miss.html) :使用IntelliJ的键盘快捷键用来提高生产力\n  * [Java Corner at Artima.com ](http://www.artima.com/java/index.html)\n  * [Java课程笔记 ](http://www.cafeaulait.org/course/)\n  * [Java堆](http://www.javaoffheap.com) \n  * [Java-source](http://www.java-source.net) : Java开源软件\n  * [Java Visualizer ](http://www.cs.princeton.edu/~cos126/java_visualize/) : 帮助将引用，值，变量可视化\n  * [JournalDev - Java, Java EE, Android, Web Development Tutorials](http://www.journaldev.com/)\n  * [Learning Java](http://chimera.labs.oreilly.com/books/1234000001805/index.html):一个免费的在线学习Java语言的教材\n  * [Netbeans的键盘快捷键](https://netbeans.org/project_downloads/usersguide/shortcuts-80.pdf) : 键盘快捷键能够使你在工作时提高生产力\n  * [搜索开源的Java API ](http://www.docjar.com/) : 浏览Java库的源代码，并且学习如何实现\n  * [C++编程语言](http://www.stroustrup.com/C++.html) : C++编程语言\n  * [Java内存模型](http://www.cs.umd.edu/~pugh/java/memoryModel/)\n  * [The Java™ Tutorials  ](https://docs.oracle.com/javase/tutorial/) : 最好的Java手册\n  * [理解JVM](http://www.cubrid.org/blog/dev-platform/understanding-jvm-internals/)\n  * [垃圾回收是什么](https://plumbr.eu/handbook/what-is-garbage-collection) : 动态垃圾搜集\n  * [Welcome to JavaWorld.com ](http://www.javaworld.com/)\n  * [XyzWs Java FAQs ](http://www.xyzws.com/javafaq/page/1) : Java面试题汇总\n\n\n<h1 id='learn-ai'>AI学习</h1>\n * [fast.ai](http://course.fast.ai) : 针对没有研究生水准的数学的开发者的免费实用的深度学习课程\n * [grakn.ai](https://grakn.ai) : 数据库AI\n * [Robots that learn](https://blog.openai.com/robots-that-learn/) : 机器人学习\n * [无监督神经元](https://blog.openai.com/unsupervised-sentiment-neuron/)\n * [AI、机器学习、深度学习的不同](https://blogs.nvidia.com/blog/2016/07/29/whats-difference-artificial-intelligence-machine-learning-deep-learning-ai/)\n * [TensorFlow](https://www.tensorflow.org) : 一个针对机器智能的软件开源库\n * [Scikit-learn](http://scikit-learn.org) : 一个针对机器学习的Python模块\n * [DeepLearning.ai](https://www.deeplearning.ai) : 深度学习课程，作者coursera的创建者，吴恩达\n * [深度学习的历史](http://blog.floydhub.com/coding-the-history-of-deep-learning/) \n * [Serpent AI](https://github.com/SerpentAI/SerpentAI) : 游戏代理框架\n\n<h1 id='seminar--research-writing--talks-etc'>研讨会、研究性写作、会谈等</h1>\n  * [关于研究和写作的建议](http://www.cs.cmu.edu/~mleone/how-to.html)\n  * [博士论文](http://www.cse.iitd.ac.in/~srsarangi/articles.html)\n  * [在会议上讨论的实用技巧](https://stephenhaunts.com/2015/10/02/practical-tips-for-talking-at-usergroups-and-conferences-part-1/)\n  * [研讨会和报告](https://www.cse.iitb.ac.in/~ranade/communicationskills.html)\n  * [Latex参考](http://latex.knobs-dials.com)\n  * [Begin Latex in minutes](https://github.com/LewisVo/Begin-Latex-in-minutes) : 针对初学者的Latex的简单介绍帮助你轻松掌握Latex\n  * [Lshort](https://tobi.oetiker.ch/lshort/lshort.pdf) : 对Latex2的详细介绍\n\n<h1 id='everything-in-one-place'>知识汇总</h1>\n  * [reddit.com/user/ashish2199/m/cs_student_subs](https://www.reddit.com/user/ashish2199/m/cs_student_subs) : 在reddits中计算机科学和编程相关的主题\n  * [一个程序员应该访问的web站点](https://www.quora.com/What-are-the-best-websites-a-programmer-should-visit/answer/Ashish-Padalkar?srid=OH96) :发表在Quora上，作者ashish2199\n  * [Moocha](https://www.moocha.io) : 从edx、coursera、udacity等搜索在线课程\n  * [Rico's cheatsheets](https://devhints.io) : 常用知识备忘集合\n  * [API Documentation](http://devdocs.io/) : 一个众所周知的带有搜索接口的API文档，类似于dash\n\n<h1 id='youtube-channels'>youtube频道</h1>\n  * [C++Now (BoostCon)](https://www.youtube.com/channel/UC5e__RG9K3cHrPotPABnrwg) :当前的C++会议\n  * [code::dive conference](https://www.youtube.com/channel/UCU0Rt8VHO5-YNQXwIjkf-1g) : 有诺基亚技术中心组织的会议\n  * [Coding Blocks](https://www.youtube.com/CodingBlocks) : 指南，技巧\n  * [Computerphile ](https://www.youtube.com/user/Computerphile/videos) : 每个CS学生都应该看\n  * [ComputerHistory ](https://www.youtube.com/user/ComputerHistory/videos) : 针对那些想知道如何达成目标的人\n  * [CppCon ](https://www.youtube.com/user/CppCon/videos?shelf_id=0&view=0&sort=dd) : C++会议\n  * [Facebook Developers ](https://www.youtube.com/user/FacebookDevelopers/videos)\n  * [Fun Fun Function](https://www.youtube.com/c/mpjmevideos) : 每周一次的对编程主题的分类，也包括一些与编码不直接相关的内容\n  * [Google Developers ](https://www.youtube.com/user/GoogleDevelopers/videos)\n  * [GoogleTechTalks ](https://www.youtube.com/user/GoogleTechTalks/videos) : 关于热门话题的视频和在技术界的一些趣事\n  * [Gynvael Coldwin](https://www.youtube.com/user/GynvaelEN) :逆向工程和黑客（CTF）博客，每周三都有新的直播\n  * [HowToBecomeTV ](https://www.youtube.com/user/HowToBecomeTV/videos) : 与技术界相关的开发人员的好的面试\n  * [Java ](https://www.youtube.com/user/java/videos) : 有关Java的会谈\n  * [JavaOne ](https://www.youtube.com/channel/UCdDhYMT2USoLdh4SZIsu_1g/videos) : Java会议\n  * [Meeting C++ YT Kanalseite ](https://www.youtube.com/user/MeetingCPP/videos) : C++会议\n  * [Netflix UI Engineering](https://www.youtube.com/channel/UCGGRRqAjPm6sL3-WGBDnKJA/videos) : web开发者，移动开发者和对Netflix技术栈感兴趣的视频\n  * [O'Reilly ](https://www.youtube.com/user/OreillyMedia/videos) : 世界最佳技术作家访谈录\n  * [Placement Grid ](https://www.youtube.com/user/PlacementGrid/videos) : 面试及校园实习经验\n  * [Scott Meyers: Past Talks ](http://www.aristeia.com/presentations.html)\n  * [Siraj Raval](https://www.youtube.com/channel/UCWN3xxRkmTPmbKwht9FuE5A) : AI和深度学习指南视频\n  * [ThinMatrix ](https://www.youtube.com/user/ThinMatrix/videos) : 开发者在java中使用OpenGL制作的一个3D游戏的博客和指南\n  * [thoughtbot  ](https://www.youtube.com/user/ThoughtbotVideo/videos) : 谈论各种话题\n  * [yegor256 ](https://www.youtube.com/user/technoparkcorp/videos)\n\n<h1 id='good-articles'>好文章</h1>\n  * [白话40个关键的计算机科学概念](http://carlcheo.com/compsci)  \n  * [关于图论的一个介绍](https://dev.to/vaidehijoshi/a-gentle-introduction-to-graph-theory)\n  * [一个对程序员友好的语言](http://moonscript.org/)\n  * [软件开发者的阅读列表](https://stevewedig.com/2014/02/03/software-developers-reading-list/) : 这是一些好书和链接 \n  * [关于TCP/IP协议栈的代码](http://www.saminiir.com/lets-code-tcp-ip-stack-5-tcp-retransmission/): 编写一个TCP/IP的协议栈，5:TCP重传\n  * [代码的转换](https://codewords.recurse.com/issues/four/the-language-of-choice):语言的选择\n  * [数据结构与算法](https://techiedelight.quora.com/500-Data-Structures-and-Algorithms-practice-problems-and-their-solutions):一些算法和数据结构的解决方案\n  * [深入字节码](https://www.wikiwand.com/en/Java_bytecode)\n  * [初级开发者的想法](http://blog.thefirehoseproject.com/posts/expectations-of-a-junior-developer/)\n  * [Linux内核](https://0xax.gitbooks.io/linux-insides/content/Booting/linux-bootstrap-1.html)\n  * [算法清单](https://www.wikiwand.com/en/List_of_algorithms)\n  * [提升编码技巧的关键](http://blog.thefirehoseproject.com/posts/learn-to-code-and-be-self-reliant/)\n  * [Unicode编码](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/)\n  * [我们正在通过创新重塑零售业](http://multithreaded.stitchfix.com/)\n  * [每个程序员都需要知道的关于在文本中设置编码和字符的内容](http://kunststube.net/encoding/)\n  * [每个程序员都应该了解的关于内存的内容-pdf](http://futuretech.blinkenlights.nl/misc/cpumemory.pdf)\n  * [为什么网页的快速加载是很重要的](https://fly.io/articles/why-fast-pages-are-important/):为什么一个APP的速度决定了其收入\n  * [qotoqot-提升技巧](https://qotoqot.com/blog/improving-focus/):我是如何一个月工作200个小时的\n  * [Pixel Beat - Unix](http://www.pixelbeat.org/docs/unix-parallel-tools.html):使用unix工具并行处理\n  * [学习Vim](https://hackernoon.com/learning-vim-what-i-wish-i-knew-b5dca186bef7):我希望我应该知道什么\n\n<h1 id='podcasts'>播客</h1>\n  * [Coding Blocks](http://www.codingblocks.net/):一个播客，涵盖最佳编程实践，设计模式，性能编码，面向对象编码，数据库设计和实现、提示、技巧和许多其他主题的内容\n  * [水深火热的开发者](http://developeronfire.com/episodes):一个播客，分享开发人员的人性，并讲述了由Dave Rael主持的一些令人惊叹的软件人物的故事\n  * [开发者茶话会](https://spec.fm/podcasts/developer-tea) : 开发者在喝茶小憩时浏览的播客\n  * [前端的欢乐时光](http://frontendhappyhour.com/):来自Netflix，Evernote，Atlassian＆LinkedIn的软件工程师小组，讨论关于前端开发的所有事情的一个博客。\n  * [无线电的所有流程](http://www.fullstackradio.com/):包括从产品设计和用户体验到单元测试和系统管理。\n  * [Groovy播客](http://groovypodcast.podbean.com/):专用于Groovy编程语言及其生态系统的播客。\n  * [IPhreaks](https://devchat.tv/iphreaks):每周讨论一次关于iOS开发和开发中的最新技术，具体讨论苹果，工具，做法  和代码\n  * [JavaScript 论坛](https://devchat.tv/js-jabber):每周一次关于JavaScript，前端开发，社区，职业和框架的讨论。\n  * [用我的播客学习代码](https://learntocodewith.me/podcast/):以一个季为一集的科技播客，是由劳伦斯·布拉德福德（Laurence Bradford）主持，从科技职业到科技业务的课程\n  * [MS示例展示](http://msdevshow.com/):Jason Young和Carl Schweitzer谈到有关Azure云，Windows，Windows Phone，Visual Studio以及使用Microsoft平台的跨平台开发等最新的开发者新闻\n  * [React Native Radio](https://devchat.tv/react-native-radio):每周讨论使用JavaScript和React构建移动应用程序的工具，技术和技术\n  * [软件工程日报](https://softwareengineeringdaily.com/):关于软件主题的日常技术面试\n  * [软件工程无线电](http://www.se-radio.net/):针对专业软件开发人员的播客，目标是成为一个持久的教育资源而不是新闻\n  * [语法](https://syntax.fm/) :对Wes Bos＆Scott Tolinski和Web开发人员来说是一个比较有趣的博客\n  * [The Bike Shed](http://bikeshed.fm/) :参与者讨论他们的开发经验和Ruby，Rails，JavaScript等的挑战\n  * [The Change log](https://changelog.com/podcast) : 每周一次的谈话，参与者都是开源技术的核心人员和创建者\n  * [愤世嫉俗的开发者](https://cynicaldeveloper.com/) :一个播客，旨在通过解释最新和最伟大的开发技术，为您提供开发知识和职业生涯，并提供您作为开发人员取得成功的需要。覆盖桌面，网络和移动开发，主要围绕.Net堆栈，也经常研究其他软件和框架\n\n<h1 id='building-a-simple-compilerinterpreter'>构建一个简单的编译器/解释器</h1>\n  * [snowman：可能是有史以来最小的编译器](https://github.com/thejameskyle/the-super-tiny-compiler) : 这是一个超简化的例子，它描述了一个使用JavaScript编写的易于阅读的 现代编译器的所有主要部分\n  * [精彩的编译器](http://aalhour.com/awesome-compilers/) : 编译器，翻译和运行的精彩资源列表\n  * [提升一个编译器](http://www.cs.dartmouth.edu/~mckeeman/cs48/mxcom/gem/html/GrowingCompiler.html) : 了解如何提升一个编译器  \n  * [一起开发一个简单的解释器-第一章](https://ruslanspivak.com/lsbasi-part1/) : 尝试通过构建一个编译器，揭开它的神秘面纱\n  * [业余编译器开发者的资源](http://c9x.me/compile/bib/) : 业余编译器开发者的资源\n  * [计算机程序的构造与解释](https://sarabander.github.io/sicp/html/index.xhtml) : 计算机程序的结构和解释\n  * [我开发的第一个编译器](https://dev.to/fcpauldiaz/writing-my-first-compiler) : 写出你的第一个编译器\n  * [编译器简介](https://nicoleorchard.com/blog/compilers) : 如何与计算机说话，例如Siri先生\n  * [编写自己的编译器](http://staff.polito.it/silvano.rivoira/HowToWriteYourOwnCompiler.htm) : 如何编写自己的编译器\n\n<h1 id='tutorials'>教程</h1>\n  * [A Hacker's Guide to Git](https://wildlyinaccurate.com/a-hackers-guide-to-git/) : 为那些想学习git的人打下坚实的基础\n  * [Best Of - Gustavo Duarte](http://duartes.org/gustavo/blog/best-of/) : 包含各种主题的文章\n  * [CMSI 281: Data Structures](http://cs.lmu.edu/~ray/classes/dsa/) : 针对数据结构的轻量级的说明\n  * [Collecting all the cheat sheets](http://overapi.com) : 大量编程语言的接口表\n  * [C Programming](http://users.cs.cf.ac.uk/Dave.Marshall/C/CE.html)\n  * [C编程语言常见问题](http://c-faq.com/index.html)\n  * [Data Structures and Algorithms by John Morris](http://oopweb.com/Algorithms/Documents/PLDS210/VolumeFrames.html) : 代码和其分析的另一个好的来源\n  * [深入学习C语言](https://www.slideshare.net/olvemaudal/deep-c) : 关于C语言的一个很好的演示\n  * [设计模式：可重用面向对象的软件的基础](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612) : aka the \"Gang Of Four\" book, or GOF\n  * [Dynamic programming - PrismoSkills](http://prismoskills.appspot.com/lessons/Dynamic_Programming/Chapter_01_-_Introduction.jsp) : 学习如何解决动态规划问题\n  * [Git从入门到精通](https://maryrosecook.com/blog/post/git-from-the-inside-out)\n  * [Head First Design Patterns](https://www.amazon.com/Head-First-Design-Patterns-Brain-Friendly/dp/0596007124)\n  * [How to Program in C++](http://cs.fit.edu/~mmahoney/cse2050/how2cpp.html) : 怎样学习C++编程，关于学习C++和STL的好资源\n  * [http://www.mysqltutorial.org/](http://www.mysqltutorial.org)\n  * [indradhanush tutotials](https://indradhanush.github.io/blog/writing-a-unix-shell-part-3/) : 写一个Unix核 \n  * [Introduction to C Programming](http://www.le.ac.uk/users/rjm1/cotter/index.htm)\n  * [10分钟搞定UNIX](http://freeengineer.org/learnUNIXin10minutes.html)\n  * [Learning the shell.](http://linuxcommand.org)\n  * [Linux Journey](https://linuxjourney.com) : 学习Linux的好站点\n  * [Linux Tutorial](https://ryanstutorials.net/linuxtutorial/) : 学习Linux的好资源\n  * [More about Github-flavored markdown](https://guides.github.com/features/mastering-markdown/)\n  * [MySQL Essentials](http://www.techotopia.com/index.php/MySQL_Essentials)\n  * [Open Data Structures](http://opendatastructures.org) : 用来学习数据结构和算法的优秀的资源提供了C++ , Java等各种语言的伪代码\n  * [OS Course Notes](https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/) : Galvin's书的章节笔记\n  * [从新手到专家-编程、web开发、DevOps新闻，教程和工具](https://dzone.com)\n  * [SQL (Structured Query Language) in one page : SQL.SU](http://www.cheat-sheets.org/sites/sql.su/) : 结构化查询语言，一个非常好的SQL记录表\n  * [Subtle | Poor Man's CI](https://www.subtle.press/course/poor-mans-ci) : 了解连续集成平台如何工作，通过使用Node.js构建您自己的git之一\n  * [TCP/IP图解](https://en.wikipedia.org/wiki/TCP/IP_Illustrated)\n  * [The Bash Guide](http://guide.bash.academy) : 学习Bash Shell的优秀教程\n  * [The Descent to C](https://www.chiark.greenend.org.uk/~sgtatham/cdescent/) : 针对那些从高级编程语言像java或者python迁移到C的人\n  * [The Linux 命令行: yige完整介绍](https://www.amazon.com/Linux-Command-Line-Complete-Introduction/dp/1593273894)\n  * [The Unix环境编程](http://product.half.ebay.com/The-UNIX-Programming-Environment-by-Brian-W-Kernighan-and-Rob-Pike-1983-Other/54385&tg=info)\n  * [TopCoder Tutorials](https://www.topcoder.com/community/data-science/data-science-tutorials/)\n  * [Tutorialspoint](https://www.tutorialspoint.com) : UPSC，IAS，PCS，公务员，银行，能力，问题，答案，解释，面试，入学考试，解决方案的文本和视频教程\n  * [UNIX和Linux系统管理员手册 第四版](https://www.amazon.com/UNIX-Linux-System-Administration-Handbook/dp/0131480057)\n  * [VimTutor+](https://vimtutorplus.herokuapp.com/exercise/1) : 从浏览器上学习VIM\n  * [W3Schools在线Web教程](https://www.w3schools.com) \n  * [Unix Shell](https://www.dartmouth.edu/~rc/classes/ksh/print_pages.shtml) : ksh / bash的Unix shell脚本\n  * [Snap SVG](http://snapsvg.io) : 现代Web的JavaScript SVG库\n  * [vim.rtorr](https://vim.rtorr.com) : Vim Cheat Sheet\n  * [Open Vim](http://www.openvim.com/tutorial.html) :  交互式Vim教程\n  * [Algorithm Using Dynamic Programming and A](http://thume.ca/2017/06/17/tree-diffing/) : 使用动态编程和A*设计树差分算法\n  * [Learn Python](https://www.learnpython.org) : 免费的交互式Python教程\n  * [C++17](https://www.viva64.com/en/b/0533/) : C ++指南17\n\n<h1 id='watch-others-code'>欣赏他人的代码</h1>\n  * [LiveEdu.tv](https://www.liveedu.tv) :  构建应用，网站游戏等人的视频\n  * [Twitch.tv](https://www.twitch.tv/communities/programming) : Twitch的编程社区\n\n<h1 id='what-should-a-programmer-know'>一个程序员应该知道的东西</h1>\n  * [GitHub.com Build software better, together](https://github.com) : 向其他人展示你的项目和与人协作的地方（为了更高效的使用它必须知道Git）\n  * [Gitlab提供无限制的私有库，和无限制的组织](https://about.gitlab.com)\n  * [程序员能力矩阵](http://sijinjoseph.com/programmer-competency-matrix/) :  一篇用来了解我们作为程序员的水平的文章\n\n<h1 id='competitive-programming'>编程比赛</h1>\n  * [Archived Problems - Project Euler](https://projecteuler.net/archives) : 问题归档\n  * [Art of Problem Solving](https://artofproblemsolving.com) : 数学课对你来说太容易了吗？你来到正确的地方！\n  * [CodeChef](https://www.codechef.com) : 唯一的编程比赛Web 2.0平台\n  * [Codefights](https://codefights.com) : 测试你的编码技巧\n  * [Codeforces](http://codeforces.com) : 编程竞赛，在线计算机编程\n  * [Codewars](https://www.codewars.com) : 根据完成代码排名\n  * [Codility](https://codility.com) : 验证和提高编码技能\n  * [Codingame](https://www.codingame.com/start) : 通过游戏和挑战学习编码！\n  * [Google Code Jam Practice and](https://code.google.com/codejam/past-contests) : 过去比赛的练习题\n  * [HackerEarth - Programming challenges and Developer jobs](https://www.hackerearth.com)\n  * [HackerRank](https://www.hackerrank.com) : 实践编码、竞争、找工作\n  * [PKU ACM ICPC Practice problems](http://poj.org/problemlist) : ACMACPC 在线审核\n  * [Sphere Online Judge (SPOJ)](http://www.spoj.com) : 成为一名真正的编程硕士学习如何编写和构建高效的算法\n  * [Topcoder](https://www.topcoder.com) : 通过更多的包为代码提供更快的速度\n  * [UVa Online Judge](https://uva.onlinejudge.org) : 支持多种语言的数百种问题\n  * [WakaTime](https://wakatime.com) : 通过编辑器插件收集编码度量的排行榜\n\n<h1 id='computer-books'>计算机书籍</h1>\n  * [Become a Programmer, Motherfucker (list of books)](http://programming-motherfucker.com/become.html) :来自Zed A. Shaw的书籍详尽清单\n  * [最佳图书奖](http://gatecse.in/best-books-for-gatecse/)\n  * [cses.fi/book.html](https://cses.fi/book.html)\n  * [github.com/vhf/free-programming-books](https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books.md) : 超过500本免费电子书几乎包括你能想到的所有语言\n  * [GitBook](https://www.gitbook.com) : GitBook 可以帮助您的团队在线编写，协作和发布内容\n  * [Data Science course](https://jakevdp.github.io/PythonDataScienceHandbook/) : Python数据科学手册\n\n<h1 id='video-tutorials'>视频指南</h1>\n  * [codedamn](https://www.youtube.com/channel/UCJUmE61LxhbhudzUugHL2wQ/videos) : 前端Web开发教程\n  * [代码学院](https://www.codeschool.com) : PluralSight公司和一个有抱负和有经验的开发人员的互动学习的地方\n  * [CodingMadeEasy](https://www.youtube.com/user/CodingMadeEasy/videos) : C ++教程\n  * [CS1: Higher Computing - Richard Buckland UNSW](https://www.youtube.com/playlist?list=PL6B940F08B9773B9F) : 一个很好的介绍性的CS课程\n  * [Derek Banas](https://www.youtube.com/user/derekbanas/videos) : 优质的教程\n  * [算法的设计与分析](http://openclassroom.stanford.edu/MainFolder/CoursePage.php?course=IntroToAlgorithms)\n  * [DevTips](https://www.youtube.com/user/DevTipsForDesigners/videos) : web开发教程\n  * [Kathryn Hodge](https://www.youtube.com/channel/UC4DwZ2VXM2KWtzHjVk9M_xg/videos) : 为初学者提供好视频\n  * [mycodeschool](https://www.youtube.com/user/mycodeschool/videos) : 数据结构和算法教程\n  * [Pluralsight](https://www.pluralsight.com) :通过多个短期课程学习软件开发，DevOps和数据科学\n  * [thenewboston](https://www.youtube.com/user/thenewboston/videos) : 课程很好但是与实际内容相比有点啰嗦\n  * [Tushar Roy](https://www.youtube.com/user/tusharroy2525/videos) : 印度Youtuber的算法和数据结构教程\n  * [Vim Tutorial Videos - Flarfnoogins](http://derekwyatt.org/vim/tutorials/index.html) : 用于学习Vim好的视频教程\n  * [XDA-University - Helping You Learn Android Development](https://forum.xda-developers.com/general/xda-university):帮助您学习Android开发\n  * [Khan Academy](https://www.khanacademy.org/computing/computer-science) : 免费学习计算机科学\n  * [Functional programming](https://www.youtube.com/watch?v=1PhArSujR_A) : John Carmack功能编程（2013）\n  * [Video about vims](https://vimeo.com/album/2838732) : 关于Vim的一系列教程\n\n<h1 id='online-compiler-and-sharing-code-snippets'>在线编译和共享代码片段</h1>\n  * [CodePad](https://codepad.remoteinterview.io) : 支持代码编写，测试和运行，支持超过25种语言\n  * [Codesandbox.io](https://codesandbox.io) : CodeSandbox可以更轻松地创建，与他人共享和重用React项目\n  * [Godbolt.org](https://godbolt.org) : 一款非常优秀的工具用来探索在不同编译器没有优化时的输出\n  * [Ideone.com](https://ideone.com) : 用于60多种编程语言的在线编译和调试工具\n  * [JSFiddle](https://jsfiddle.net) : 在线测试你的javascript，CSS，HTML或者CoffeeScript\n  * [Pastebin.com](https://pastebin.com)\n  * [C9.io](https://c9.io) : 在云端的开发环境\n  * [Github Gist](https://gist.github.com) : 即时分享代码，笔记和片段\n\n<h1 id='blogs-of-developers'>开发者博客</h1>\n  * [Algo-Geeks](http://algo-geeks.blogspot.com) : 编程拼图，数学技巧，算法等\n  * [Antirez - Redis Creator's blog](http://antirez.com/latest/0) : Antirez的博客\n  * [Antonio081014's Algorithms Codes](http://code.antonio081014.com) : RULE下的世界  \n  * [Archives — Ask a Manager](http://www.askamanager.org/archives) : 人力资源相关的东西\n  * [Armin Ronacher's Thoughts and Writings](http://lucumr.pocoo.org) : 关于Python和开源的博客\n  * [blog.might.net](http://matt.might.net/articles/) : might dot net的博客\n  * [Brendon Gregg - Linux Kernel Dev](http://www.brendangregg.com) : Brendon D. Gregg博客\n  * [Clean Coder Blog](http://blog.cleancoder.com) : 《代码整洁之道》一书作者的博客\n  * [CodeAhoy](https://codeahoy.com) : 软件和人为因素的博客，100％测试人类\n  * [CoderGears Blog Insights from](http://www.codergears.com/Blog/) : the CoderGears Team\n  * [Coding Geek - A blog about IT, programming and Java](http://coding-geek.com) : 关于IT，编程和Java的博客\n  * [Coding Horror](https://blog.codinghorror.com) : 一个最好的编码博客\n  * [CSE Blog](http://www.cseblog.com) : 量子，数学，计算机科学难题\n  * [Daedtech.com](https://www.daedtech.com) : 有关软件的故事\n  * [Dan Dreams of Coding](https://dandreamsofcoding.com)\n  * [Daniel Lemire's Blog](https://lemire.me/blog/) : Daniel Lemire的博客\n  * [Eli Bendersky](http://eli.thegreenplace.net) : 从Python到LLVM的一切\n  * [Geek Land](https://avidullu.wordpress.com) : 我珍贵的收藏品\n  * [HackerEarth Blog](http://blog.hackerearth.com) : 黑客博客\n  * [IT Enthusiast](http://rodiongork.tumblr.com) : IT热衷者\n  * [Joel on Software](https://www.joelonsoftware.com) : StackOverflow首席执行官的博客\n  * [Late Developer](https://latedev.wordpress.com) :  一个老C ++人的随机想法\n  * [1ucasvb's laboriginal math and physics visualization](http://1ucasvb.tumblr.com) : Lucas Vieira Barbosa的实验室原始数学和物理可视化\n  * [Math ∩ Programming](https://jeremykun.com) : Math ∩ Programming\n  * [My Tech Interviews](http://www.mytechinterviews.com) : 准备技术访谈\n  * [Paul Graham Essays](http://www.paulgraham.com/articles.html) : Paul Grahan Essays\n  * [Programming Blog](http://www.yegor256.com) : Yegor Bugayenko的编程博客   \n  * [Programming in the 21st Century](http://prog21.dadgum.com) : 二十一世纪的编程\n  * [rudhakar Rayavaram](http://sudhakar.online) : Sudhakar Rayavaram博客\n  * [Runhe Tian Coding Practice](https://tianrunhe.wordpress.com) : 苹果，谷歌，Facebook，亚马逊和微软的技术面试问题\n  * [Small Programming Challenges and Puzzles](https://www.nayuki.io/category/programming) : Nayuki项目\n  * [Stephen Haunts { Coding in the Trenches }](https://stephenhaunts.com) : 软件开发，架构和技术领导力\n  * [stevehanov.ca](http://stevehanov.ca/blog/) : 我知道如何在线制作和销售软件，我可以和你分享我的提示\n  * [Takipi Blog](http://blog.takipi.com) : 主要关注Java和JVM语言\n  * [WildMl](http://www.wildml.com) : 机器学习博客\n  * [XDA - Android Developer Forum](https://forum.xda-developers.com) : Android开源开发者论坛\n\n<h1 id='for-improving-your-english'>用来提高你的英语</h1>\n  * [Englishclub.com/learn-english](https://www.englishclub.com/learn-english.htm)\n  * [语法和写作指南](http://grammar.ccc.commnet.edu/grammar/) : 对于那些想提高英语语言能力的人\n  * [标点符号和字母大小写规则](http://www.grammarbook.com/english_rules.asp)\n  * [PPurdue大学在线写作实验室](https://owl.english.purdue.edu)\n  * [Quia - English](https://www.quia.com/shared/english/)\n\n<h1 id='when-you-get-bored-from-cs-related-stuff'>当你厌倦了CS相关的东西</h1>\n  * [Barcroft TV](https://www.youtube.com/user/barcroftmedia/featured) : 构成世界的各种各样的人的短小的纪录片\n  * [Big Think](https://www.youtube.com/user/bigthink/videos) : 专家驱动，可操作的教育内容，包括比尔·克林顿到比尔·奈\n  * [ColdFusion](https://www.youtube.com/user/coldfustion/videos) : 过去的当前的以及未来的技术\n  * [CrashCourse](https://www.youtube.com/user/crashcourse/videos) : 各种科目的小班课程\n  * [Every Frame a Painting](https://www.youtube.com/user/everyframeapainting/videos) : 高质量的电影分析\n  * [National Geographic](https://www.youtube.com/user/NationalGeographic/videos) 来自世界各地的高品质内容\n  * [r/ProgrammerHumor](https://www.reddit.com/r/ProgrammerHumor/) : Subreddit 用于听什么像什么\n  * [Reddit the front page of the internet](https://www.reddit.com) : 适合有大把空闲时间的人\n  * [Ridddle](https://www.youtube.com/user/VineMontanaTV/videos) : 关于科学的YouTube频道，主要是但不仅仅是宇宙和空间\n  * [SciShow](https://www.youtube.com/user/scishow/videos) : 有关您一直想知道的有趣问题的答案\n  * [SmarterEveryDay](https://www.youtube.com/user/destinws2/videos) : 关于我们周围世界的许多惊人的科学信息，通常用高速摄像机\n  * [TED](https://www.youtube.com/user/TEDtalksDirector/videos) : 谈论技术，娱乐和设计\n  * [TestTube News](https://www.youtube.com/user/TestTubeNetwork/videos) : 有关世界各地新闻的有趣信息\n  * [Reddit the front page of the internet](https://www.reddit.com) : 适合有大把空闲时间的人\n  * [How to live for long time ?](http://www.bbc.com/future/story/20170601-the-secret-to-a-long-and-healthy-life-eat-less) : 长寿的秘密\n  * [Vsauce](https://www.youtube.com/user/Vsauce/videos) : 最好的YouTube频道\n  * [Ox A cuk](http://www.ox.ac.uk/research/research-in-conversation/how-live-happy-life/dr-bronwyn-tarr#) : 如何过幸福的生活\n  * [lonelyspeck](https://www.lonelyspeck.com/the-milky-way-in-los-angeles-light-pollution/) : 关于轻污染天文摄影的权利的曝光 - Palos Verdes，洛杉矶，加利福尼亚州\n\n<h1 id='open-source-websites'>开源网站</h1>\n  * [Open Hatch](https://openhatch.org) : OpenHatch是一个非营利组织，致力于将潜在的免费软件贡献者与社区，工具和教育相匹配 \n  * [Source Forge](sourceforge.net) : SourceForge主持着近28万个项目（最后一次）。它每天提供超过200万次下载，并包含各种类别的应用程序和工具\n  * [Google Code](code.google.com/projecthosting) : Google使用Subversion或Mercurial版本控制系统为开源项目提供免费托管服务。它提供2GB的存储，集成的代码审查工具，维基和问题跟踪。 Google Code网站还提供了Google许多公开API和其他开发人员工具的链接。\n  * [Launch Pad](launchpad.net) :由Canonical、LaunchPad维护，特别针对在Ubuntu上运行的项目。它为超过21,000个使用Bazaar版本控制系统的项目提供托管\n  * [Google Open Source](opensource.google.com) : Google开源\n  * [Red Hat Developer](developer.redhat.com) : 全球领先的开源解决方案提供商\n  * [Open Source](opensource.com) : 开源\n  * [Google Summer of Code](https://summerofcode.withgoogle.com) : Google Summer of Code是一项全球性计划，致力于将更多的学生开发人员引入开源软件开发。学生在休学期间，用户3个月与一个开源组织合作完成的编程项目\n  * [Open Source Web Design](http://www.oswd.org) : 开源网页设计是一个共享符合标准的免费网页设计模板的平台。我们通过良好的设计给网络发布商一个通知\n  * [Mozilla Winter of Security](https://wiki.mozilla.org/Security/Automation/Winter_Of_Security_2016) : 安全冬季（MWOS）是由Mozilla安全小组组织的一个计划：让学生参与安全项目，学生必须执行一个学期项目作为大学课程的一部分，可以选择其中一个MWOS项目\n  * [Eclipse Lab](http://www.eclipse.org/org/foundation/eclipselabs/faq.php) : Eclipse Labs是一个基于Eclipse平台构建技术的开源项目社区。它提供开源项目通常需要的基础架构服务，如代码存储库，错误跟踪，项目网站/ wiki。 Eclipse Labs由Google Code Project Hosting托管，所以对于已经使用Google Code Project Hosting的开发人员来说，这将非常熟悉\n  * [Bit Bucket](https://bitbucket.org) : 像GitHub一样，BitBucket也承载了公共和私人项目。在这个网站上，少于五个用户的开源项目和私人项目是免费的。它拥有超过48,000个存储库，其中许多存储库可在现场进行搜索site.\n  * [Media Wiki](https://www.mediawiki.org/wiki/MediaWiki) : MediaWiki是一款用PHP编写的免费软件开源维基软件包，最初用于维基百科。现在也被非营利维基媒体基金会和许多其他维基的其他项目使用，包括这个网站，MediaWiki的主页\n  * [Code Curiosity](https://codecuriosity.org) : CodeCuriosity是一个鼓励开放源代码的平台，无论项目是大还是小，每个人都为自己的努力而获得回报\n  * [Code Triage](https://www.codetriage.com) : 帮助完成您最喜欢的开源项目，并在开发过程中成为更好的开发人员\n  * [Issue Hub](http://issuehub.io) : 贡献于开源。搜索问题标签为您找到正确的项目\n  * [Up for Grabs](http://up-for-grabs.net) : 这是一个专门为新贡献者策划的项目的列表。这些是开始使用项目的好方法，或是帮助分享开源项目的负担。\n  * [First Timers Only](http://www.firsttimersonly.com) : 首次对开放源码做出贡献可能是可怕的，有点压倒性。也许你是一个代码新手，或者你已经编码了一段时间，但还没有找到一个你觉得自己很有帮助的项目\n  * [Your First PR](http://yourfirstpr.github.io) : 您的第一个公关帮助在GitHub和其他地方展示最佳启动器问题为开源做贡献\n\n<h1 id='Special Thanks'>特别感谢</h1>\n  * 如果您发现这很有用或考虑也参与并作出贡献，请考虑一个github Star。\n  * 特别感谢Ashish Padalkar（@ ashish2199）为初始版本原始帖子贡献了大量的数据和结构。\n\n\n  ___Maintained with :heart: by sdmg15 & al___","tags":["阅读"]},{"title":"JavaScript对象深拷贝","slug":"JavaScript对象深拷贝","url":"/2023/02/04/javascript-dui-xiang-shen-kao-bei/","content":"\n为防止修改到JavaScript原始对象，会使用到深拷贝。\n\n<!--more-->\n\n\n\n[js对象深拷贝的方法](http://www.kaotop.com/it/14615.html)中介绍了深拷贝的3种方法：\n\n1、先将对象序列号为json字符串，再还原\n\n2、使用Object.assign():适用于要拷贝的对象中属性为基础数据类型的\n\n3、循环递归\n\n## Object.assign()\n\n```javascript\nObject.assign(target,source)\n```\n\n> 第一个参数为目标对象，第二个参数为原始对象。\n\n## Reference\n\n[1、js对象深拷贝的方法](http://www.kaotop.com/it/14615.html)","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"bat脚本打开某个网页","slug":"bat脚本打开某个网页","url":"/2023/02/04/bat-jiao-ben-da-kai-mou-ge-wang-ye/","content":"\n本文介绍如何使用bat打开某个网页。\n\n<!--more-->\n\n## 应用环境\n\nOS: Win10\n\n## 打开某个页面\n\n```bash\nexplorer.exe \"http://localhost/index.html\"\n```\n\n## Reference\n\n[1、bat命令：浏览器打开网站](https://www.jianshu.com/p/d48d6773681a)","tags":["脚本"],"categories":["脚本"]},{"title":"Python中的排序函数","slug":"Python中的排序函数","url":"/2023/02/04/python-zhong-de-pai-xu-han-shu/","content":"\nPython使用sort函数，配合lambda表达式，实现按照列表中某个字段的排序。\n\n<!--more-->\n\n## 应用环境\n\nPython: 3.9\n\n## python中的sort和sorted\n\n| sort                       | sorted                            |\n| -------------------------- | --------------------------------- |\n| 直接修改原始对象           | 不修改原始对象，会返回新的对象    |\n| 只能对list进行排序         | 所有**可迭代对象**都可以使用      |\n| lst. sort(key[, reverse]]) | sorted(iterable[,key[, reverse]]) |\n\n> 其中reverse为True时降序，False升序\n\n## 对列表中指定元素排序\n\n升序排列：\n\n```python\nstudents = [('john', 'A', 15), ('jane', 'B', 9), ('dave', 'B', 10)]\nstudents.sort(key = lambda student:student[2],reverse=False)\n```\n\n使用sorted:\n\n```python\nprint(sorted(students,key=lambda student:student[2],reverse=False))\n```\n\n## Python中标准数据类型\n\nNumber（数字）\n\nString（字符串）\n\nList（列表）\n\nTuple（元组）\n\nSet（集合）\n\nDictionary（字典）\n\n除数字外都可迭代(可使用for循环遍历)，可通过isinstance函数判断:\n\n```python\nfrom typing import Iterable\nprint(isinstance(('1','2'),Iterable))\nprint(isinstance('123',Iterable))\nprint(isinstance({'NAME':1},Iterable))\n```\n\n## Reference\n\n[1、python实现数组按列排序、字符串数组排序、按照关键字排序--sort和sorted的使用](https://www.cnblogs.com/liliwang/articles/12716899.html)\n\n[2、Python3基本数据类型](https://www.runoob.com/python3/python3-data-type.html)","tags":["Python"],"categories":["Python"]},{"title":"Cesium根据经纬度获取高程","slug":"Cesium根据经纬度获取高程","url":"/2023/02/04/cesium-gen-ju-jing-wei-du-huo-qu-gao-cheng/","content":"\n本文介绍使用Cesium获取指定地点的高程信息。\n\n<!--more-->\n\n## 应用环境\n\nCesium: 1.9\n\nOS：Win10\n\n## Cesium加载地形\n\n```javascript\nvar terrainProvider = new Cesium.CesiumTerrainProvider({\n    url: \"http://localhost/geodata/terrain\",\n});\nviewer.terrainProvider = terrainProvider;\n```\n\n## 获取高程信息\n\n```javascript\n// Query the terrain height of two Cartographic positions\nvar terrainProvider = Cesium.createWorldTerrain();\nvar positions = [\n    Cesium.Cartographic.fromDegrees(86.925145, 27.988257),\n    Cesium.Cartographic.fromDegrees(87.0, 28.0)\n];\nvar promise = Cesium.sampleTerrain(terrainProvider, 11, positions);\nCesium.when(promise, function(updatedPositions) {\n    // positions[0].height and positions[1].height have been updated.\n    // updatedPositions is just a reference to positions.\n});\n```\n\n> **sampleTerrain(terrainProvider, level, positions)**\n>\n> 其中level为The terrain level-of-detail from which to query terrain heights. \n\n## Cesium注册点击事件\n\nCesium中Scene对象的pickPosition函数需要开启深度检测，即需要设置depthTestAgainstTerrain为true,否则无法正确获取到点击位置的地理坐标：\n\n```javascript\nviewer.scene.globe.depthTestAgainstTerrain=true;\n```\n\n完整的点击事件中获取坐标的代码如下：\n\n```javascript\n this.clickHandler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);\n this.clickHandler.setInputAction(function (movement) {\n     var position = viewer.scene.pickPosition(movement.position);\n     var cartographic = Cesium.Cartographic.fromCartesian(position);\n     var longitude = Cesium.Math.toDegrees(cartographic.longitude);\n     var latitude = Cesium.Math.toDegrees(cartographic.latitude);\n }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n```\n\n移除点击事件：\n\n```\nthis.clickHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);\n```\n\n","tags":["Cesium"],"categories":["Cesium"]},{"title":"配置web服务器中SSL使用的TLS版本","slug":"配置web服务器中SSL使用的TLS版本","url":"/2023/02/04/pei-zhi-web-fu-wu-qi-zhong-ssl-shi-yong-de-tls-ban-ben/","content":"\n本文介绍配置Nginx和Tomcat中TLS的版本为1.2，其中1.0和1.1已于2020年被弃用。\n\n<!--more-->\n\n## 应用环境\n\nOS: Win10\n\nOpenssl: 3.0.3\n\nTomcat: 9.0\n\n## 安全信息提示\n\nSSL/TLS:已弃用的TLSv1.0和TLSv1.1协议检测。\n\n## 检测SSL支持的TLS的版本\n\n```bash\nopenssl s_client -connect localhost:8443 -tls1_2\n```\n\n> tls版本：-tls1、-tls1_1、-tls1_2、-tls1_3\n\n## Tomcat配置ssl\n\n在server.xml中:\n\n```xml\n<Connector\n           port=\"8443\" maxThreads=\"200\"\n           scheme=\"https\" secure=\"true\" SSLEnabled=\"true\"\n     keystoreFile=\"xx.p12\" \n     keystorePass=\"xx\"\n     keystoreType=\"PKCS12\"\n           clientAuth=\"false\" sslEnabledProtocols=\"TLSv1.2,TLSv1.1\" sslProtocol=\"TLS\"\n     />\n```\n\n配置参数: sslEnabledProtocols\n\n此时如果执行以下命令：\n\n```bash\nopenssl s_client -connect localhost:8443 -tls1_2\n```\n\n会得到含有session-id的信息，表示成功建立的会话：\n\n```\nSSL-Session:\n    Protocol  : TLSv1.1\n    Cipher    : 0000\n    Session-ID: 63DC6861ED2A37C74AB5921C634687939C09DE0198959EE9369292681D3DA9EA\n```\n\n如果执行以下命令:\n\n```bash\nopenssl s_client -connect localhost:8443 -tls1\n```\n\n则此处的session-id为空，表示会话建立失败，未启用tls1.0版本\n\n## Nginx的SSL配置中设置支持的tls版本\n\n```nginx\nserver {\n\t\tlisten 8443 ssl;\n\t\tssl_certificate   ../cert/localhost.pem;\n\t\tssl_certificate_key  ../cert/localhost-key.pem;\n\t\tssl_session_timeout 5m;\n\t\tssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n\t\tssl_protocols TLSv1.2;\n\t\tssl_prefer_server_ciphers on;\n```\n\n> 参数为ssl_protocals\n\n## Reference\n[1、Tomcat 启用TLS1.2 1.3 禁用TLS1.0 1.1](https://www.cnblogs.com/harbin1900/p/16805959.html)\n\n[2、SpringBoot配置SSL](https://www.cnblogs.com/zklymm/p/16356119.html)\n\n","tags":["应用安全"],"categories":["应用安全"]},{"title":"Python3获取键盘输入及print函数的使用","slug":"Python3获取键盘输入及print函数的使用","url":"/2022/12/21/python3-huo-qu-jian-pan-shu-ru-ji-print-han-shu-de-shi-yong/","content":"\n本文介绍python脚本打包的全过程。\n\n<!--more-->\n\n## 环境\n\nPython: 3.9\n\nOS: Win10\n\n## 应用简介\n\n用Python写了一个脚本处理图片数据，其中输入和输出目录需要手动设置，最终达到的效果如下所示：\n\n![最终效果](2022-12-21_165353.jpg)\n\n## 获取键盘输入\n\n使用input()可以获取键盘输入数据，其中\\n为换行符：\n\n```python\ninput_dir=input(\"请输入tif文件所在目录:\\n\")\n```\n\n## PIL提示图片大小超出显示\n\nDecompressionBombWarning: Image size (92680344 pixels) exceeds limit of  89478485 pixels, could be decompression bomb DOS  attack.DecompressionBombWarning...\n\n[可调整上限](https://www.cnblogs.com/PiaoLingJiLu/p/14335184.html)：\n\n```python\nfrom PIL import Image\nImage.MAX_IMAGE_PIXELS = 2300000000 # 更改阈值像素上限\n```\n\n> 不调整也没关系，只是会出现提示\n\n## Python3 print函数格式化\n\n输出多个int类型的变量：\n\n```python\nprint('处理完成:%d个成功,%d个失败 ' %(counts,errors))\n```\n\n同时输出int和str类型的变量:\n\n```python\nprint(\"the length of (%s) is %d\" %('runoob',len('runoob')))\n```\n\npython字符串格式化符号(更多的可[参考](https://www.runoob.com/w3cnote/python3-print-func-b.html)):\n\n| 符号 | 描述           |\n| :--: | -------------- |\n|  s%  | 格式化字符串   |\n|  d%  | 格式化整数     |\n|  f%  | 格式化浮点数字 |\n\n## Pyinstaller打包时设置图标\n\n添加--icon参数：\n\n```python\npyinstaller -F xx.py --icon=\"xx.ico\"\n```\n\n> 可将ico文件放在py文件同级目录\n\n## 小结\n\n本文记录了一个简单的含用户交互的python脚本的从0到打包的全过程，希望对你有所帮助。\n\n","tags":["Python"],"categories":["Python"]},{"title":"Python tornado获取请求头和reuqests添加请求头","slug":"Python-tornado获取请求头和reuqests添加请求头","url":"/2022/12/08/python-tornado-huo-qu-qing-qiu-tou-he-reuqests-tian-jia-qing-qiu-tou/","content":"本文介绍Python中使用tornado做接口时，获取客户端请求头中的数据，然后将请求头中的数据使用requests发送到另外一个接口。\n\n<!--more-->\n\n## 应用环境\n\nPython: 3.9\n\nOS: Win10\n\nIDE: VS Code\n\n## 客户端发送请求\n\n```javascript\n$.ajax({\n    type: \"POST\",\n    url: '/imgproc/rest/test',\n    headers: {\n        'token': 'zjk'\n    },\n    dataType: \"json\",\n    data: {\n        pId:23\n    },\n    timeout: 5000,\n    cache: false,\n    success: function (data) {\n    }\n});\n```\n\n## Tornado获取请求头中的数据\n这里的headers是字典类型的数据，因此可以直接读取：\n```python\ntoken= self.request.headers['token']\n```\n\n## requests发送请求时携带token\nrequests这里的headers也是字典类型的数据，如下：\n\n```python\nimport requests\nrequests.post(headers={'token':token})\n```\n","tags":["Tornado","Python"],"categories":["Python","Tornado"]},{"title":"JQuery删除和添加元素","slug":"JQuery删除和添加元素","url":"/2022/12/04/jquery-shan-chu-he-tian-jia-yuan-su/","content":"\n本文归纳下jQuery中添加和删除元素。\n\n<!--more-->\n\n> 本文内容参考：[jQuery - 添加元素](https://www.runoob.com/jquery/jquery-dom-add.html)\n\n## 添加元素\n\n### append() \n\n在被选元素的内部结尾插入内容\n\n```javascript\n$(\"#bbox\").append('<div id=\"bbox2\"></div>')\n```\n元素执行此方法之后，如下：\n```javascript\n<div id=\"bbox\">\n    <div id=\"bbox2\">\n    </div>\n</div>\n```\n\n### prepend() \n\n在被选元素的内部的开头插入内容，效果可参考append\n\n### after() \n\n在被选元素之后插入内容\n\n### before() \n\n在被选元素之前插入内容\n\n> 即：append/prepend 是在选择元素内部嵌入。\n>\n> after/before 是在元素外面追加。\n\n## 删除元素\n\nremove() - 删除被选元素（及其子元素）\n\nempty() - 从被选元素中删除子元素","tags":["JQuery","前端"],"categories":["前端"]},{"title":"JQuery中的效果方法","slug":"JQuery中的效果方法","url":"/2022/12/04/jquery-zhong-de-xiao-guo-fang-fa/","content":"\n本文介绍几个jQuery的效果函数，如显示隐藏,淡入淡出,逐渐变化等。\n\n<!--more-->\n\n## animate()\n\n对选中元素自定义动画。\n\n在改变元素的位置或大小时,如果使用此方法，可以使得变化不那么生硬，有一个类似过度的效果\n\n### 语法\n\n```javascript\n(selector).animate({styles},speed,easing,callback)\n```\n\n其中:\n\n**styles**主要支持以下样式：\n\nleft、right、width、height、top、bottom、margin、padding等，需要注意的是该属性名称必须是驼峰写法： 您必须使用 paddingLeft 代替 padding-left，marginRight 代替 margin-right。\n\n**speed** 可设置：slow、fast 或毫秒\n\n**easing** 可取值：swing或linear,前者表示开头和结尾慢，中间快，后者表示匀速移动\n\n**callback** 动画完成后要执行的函数\n\n### 示例\n\n```javascript\n$(\"#bbox\").stop().animate({height:\"300px\"});\n```\n\n更多内容参考：[jQuery animate() 方法](https://www.runoob.com/jquery/eff-animate.html)\n\n## fadeIn or fadeOut\n\nfadeIn：元素从不可见到可见\n\nfadeOut: 元素从可见到不可见\n\n### 语法\n\n```javascript\n$(selector).fadeOut(speed,easing,callback)\n```\n\n> 其中speed的取值同animate函数的一样，都是:毫秒/slow/fast\n>\n> easing: swing/linear\n\n### 示例\n\n完整的演示一个元素从消失到再次出现的过程：\n\n```javascript\n$(\"#bbox\").fadeOut('slow','linear',function(){\n    $(\"#bbox\").fadeIn('slow','swing');\n});\n```\n\n### fadeTo\n\n将元素的透明到改到指定的数值。\n\n语法如下：\n\n```javascript\n$(selector).fadeTo(speed,opacity,easing,callback)\n```\n\n示例：\n\n将元素的透明度改为0.4\n\n```javascript\n$(\"#bbox\").fadeTo('slow',0.4);\n```\n\n### fadeToggle\n\n调整元素的显示或隐藏的状态：即如果元素是隐藏的，那么会将其调整为显示；如果是显示的，调整为隐藏。\n\n语法：\n\n```javascript\n$(selector).fadeToggle(speed,easing,callback)\n```\n\n示例：\n\n```javascript\n$(\"#bbox\").fadeToggle('slow');\n```\n\n## hide or show\n\n显示或隐藏元素。\n\n### 语法\n\n```javascript\n$(selector).hide(speed,easing,callback)\n$(selector).show(speed,easing,callback)\n```\n\n### toggle\n\n在显示和隐藏中切换，类似fade家族中的fadeToggle\n\n语法如下：\n\n```javascript\n$(selector).toggle(speed,easing,callback)\n```\n\n## slideUp or slideDown\n\n**slideUp**:以向上滑动的方式隐藏元素\n\n**slideDown**:以向下滑动的方式显示元素\n\n### 语法\n\n```javascript\n$(selector).slideUp(speed,easing,callback)\n```\n\n> **slideDown** 适用于通过 jQuery 方法隐藏的元素，或在 CSS 中声明 display:none 隐藏的元素（不适用于通过 visibility:hidden 隐藏的元素）。 \n\n### slideToggle\n\n在显示或隐藏中切换，使用限制同slideDown,即：\n\n> 适用于通过 jQuery 方法隐藏的元素，或在 CSS 中声明 display:none 隐藏的元素（不适用于通过 visibility:hidden 隐藏的元素）。\n\n## jQuery链\n\n通过 jQuery，可以把动作/方法链接在一起,Chaining 允许我们在一条语句中运行多个 jQuery 方法（在相同的元素上）, 这样的话，浏览器就不必多次查找相同的元素。\n\n使用如下：\n\n```javascript\n$(\"#p1\").css(\"color\",\"red\").slideUp(2000).slideDown(2000);\n```\n\n","tags":["JQuery","前端"],"categories":["前端"]},{"title":"JS遍历对象的key","slug":"JS遍历对象的key","url":"/2022/11/28/js-bian-li-dui-xiang-de-key/","content":"\n在JavaScript中遍历对象的key时，看到有使用到for-in循环的，了解了下for-in的使用限制。\n\n<!--more-->\n\n## JavaScript遍历对象的key\n\n> 说明:本节参考了[js 获取对象的所有key值，用来遍历](https://blog.csdn.net/qq_34790644/article/details/114672553)\n\n```javascript\nvar gArr={\n    \"一年级\":30,\n    \"二年级\":20,\n};\nfor(key in gArr){\n    console.log(key+\":\"+gArr[key])\n}\n```\n\n输出如下：\n\n```javascript\n一年级:30\n二年级:20\n```\n\n换种写法，先获取keys,再用for-in循环，如下：\n\n```javascript\nvar keys=Object.keys(gArr);\nconsole.log(keys.join(','));\n\nfor(key in keys){\n    console.log(key)\n    console.log(gArr[key])\n}\n```\n\n输出如下：\n\n```javascript\n0\nundefined\n1\nundefined\n```\n\n为甚么会出现这种情况?\n\n## JavaScript中的for-in循环\n\nfor/in 语句用于循环对象属性。\n\n循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作。\n\nJavaScript 支持不同类型的循环：\n\n-  **for** - 循环代码块一定的次数\n-  ***for/in*** - 循环遍历对象的属性\n-  **while** - 当指定的条件为 true 时循环指定的代码块\n-  **do/while** - 同样当指定的条件为 true 时循环指定的代码块\n\n> **注意：** 不要使用 for/in 语句来循环数组的索引，你可以使用 for语句替代。\n\n本节内容摘自:[JavaScript for/in 语句](https://www.runoob.com/jsref/jsref-forin.html)","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"取消Chrome和Firefox的更新提示","slug":"取消Chrome和Firefox的更新提示","url":"/2022/11/27/qu-xiao-chrome-he-firefox-de-geng-xin-ti-shi/","content":"\n最新的浏览器都在设置里面取消了自动更新的设置，本文介绍如何取消Chrome和Firefox这两款浏览器的更新提示。\n\n<!--more-->\n\n## 应用环境\n\nOS: Windows\n\nFirefox: 102\n\nChrome: 96\n\n## Firefox\n\n修改注册表，在CMD中执行以下命令即可：\n\n```bash\nreg add \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Mozilla\\Firefox\" /v DisableAppUpdate /t REG_DWORD /d 1 /f\n```\n\n更多方法可参考[如何禁用 Firefox 自动更新 (macOS, Linux, Windows)](https://sysin.org/blog/disable-firefox-auto-update/#Firefox-for-Windows)\n\n## Chrome\n\n直接修改Chrome浏览器的快捷方式，修改target参数：\n\n```bash\n\"C:\\Program Files\\Chrome\\Chrome.exe\" --disable-background-networking\n```\n\n\n\n","tags":["系统安装配置"],"categories":["系统安装配置"]},{"title":"Python中的文件和文件夹操作","slug":"Python中的文件和文件夹操作","url":"/2022/11/26/python-zhong-de-wen-jian-he-wen-jian-jia-cao-zuo/","content":"\n本文记录用python处理文件的一些操作，含文件的遍历、拷贝、重命名等操作。\n\n<!--more-->\n\n## 应用环境\n\nPython: 3.9\n\nOS: Windows\n\nIDE: VS Code\n\n## 文件遍历\n\n参考：[python遍历某个文件夹下的所有子文件夹及文件](https://www.cnblogs.com/yibeimingyue/p/14678667.html)\n\n```python\nfor root,dirs,files in os.walk(file_dir):      \n    for dir in dirs:\n        print(os.path.join(root,dir))\n    for file in files:\n        print(os.path.join(root,file))\n```\n\n## 判断文件是否存在\n\n```python\nos.path.exists(awz3_path)\n```\n\n## 文件拷贝\n\n```\nimport shutil\nshutil.copy(source,dest)\n```\n\nshutil的更多用法：\n\n![](Python的shutil.jpg)\n\n更多用法，参考：[Python模块-shutil模块详解](https://www.cnblogs.com/ltkekeli1229/p/15709414.html)\n\n## 文本文件的读取\n\n Python open() 方法用于打开一个文件，并返回文件对象。 \n\n### 全部读取文件内容\n\n```python\ntxt_file=\"xx.txt\"\nwith open(txt_file,mode='r') as fs:\n    print(fs.read())\n```\n\n> with关键字的使用：读完文件后，要对文件关闭，调用文件的close,dispose的方法，否则文件会被占用，此时使用with就可以自动关闭，和c#中的using关键字非常相似。\n\n### 逐行读取文本文件\n\n```python\nwith open(txt_file,mode='r') as fs:\n    line=fs.readline()\n    while line:\n        print(line)\n        line=fs.readline()\n```\n\n### 读取JSON文件\n\n```python\nimport json\nwith open(\"xx.json\",mode='r',encoding='utf8') as fs:\n    htss=json.load(fs)\n    print(len(htss))\n```\n\n## 文本文件的写入\n\nopen函数的[mode参数](https://www.runoob.com/python3/python3-file-methods.html)\n\n| 模式 | 描述                                                         |\n| ---- | ------------------------------------------------------------ |\n| x    | 写模式，新建一个文件，如果该文件已存在则会报错。             |\n| b    | 二进制模式。                                                 |\n| +    | 打开一个文件进行更新(可读可写)。                             |\n| U    | 通用换行模式（**Python 3 不支持**）。                        |\n| r    | 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 |\n| rb   | 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 |\n| r+   | 打开一个文件用于读写。文件指针将会放在文件的开头。           |\n| rb+  | 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 |\n| w    | 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 |\n| wb   | 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 |\n| w+   | 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 |\n| wb+  | 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 |\n| a    | 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |\n| ab   | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |\n| a+   | 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 |\n| ab+  | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 |\n\n### 文件的写入\n\n```python\nwith open(\"test.txt\",mode=\"w\",encoding='utf8') as file:\n    file.write(\"做自己的保护神\")\n```\n\n### 文件的追加\n\n```python\nwith open(\"test.txt\",mode=\"a\",encoding='utf8') as file:\n    file.write(\"落子无悔\")\n```\n\n此时文件内容：\n\n> ***做自己的保护神落子无悔***\n\n如果需要换行，添加换行符**\\n**\n\n```python\nwith open(\"test.txt\",mode=\"a\",encoding='utf8') as file:\n    file.writelines([\"好好生活好好爱\\n\"])\n```\n\n","tags":["Python"],"categories":["Python"]},{"title":"Python中的list和tuple","slug":"Python中的list和tuple","url":"/2022/11/26/python-zhong-de-list-he-tuple/","content":"\nPython中列表list和元组tuple是非常常见的两种数据类型，其中list是可变序列，tuple是不可变序列，本文对这两种数据类型进行简单的介绍\n\n<!--more-->\n\n## 应用环境\n\nPython:3.9\n\nOS:Windows\n\nIDE:VS Code\n\n## 列表：list\n\n内容来源：[Python3 列表](https://www.runoob.com/python3/python3-list.html)\n\n### 创建列表\n\n```python\nlist = ['red', 'green', 'blue', 'yellow', 'white', 'black']\n```\n\n### 元素的访问\n\n```python\n# 访问第一个元素\nprint(list[0])\n\n# 倒数第二个元素\n\nprint(list[-2])\n\n# 索引[1,3)\n\nprint(list[1:3])\n\n# ['green', 'blue']\n```\n\n### 数组的更新\n\n```python\nlist[0]=0\n\nprint(list)\n\n# [0, 'green', 'blue', 'yellow', 'white', 'black']\n\n# 列表添加元素\n\nlist.append('pink')\n\nprint(list)\n\n# 列表插入元素\n\nlist.insert(3,'black')\n\nprint(list)\n\n# 删除元素\n\ndel list[-1]\n\nprint(list)\n\n# [0, 'green', 'blue', 'yellow', 'white', 'black']\n\n# 元素个数计算\nprint(len(list))\n\n# 6\n```\n\n### 内置方法\n\n| 方法              | 作用                       |\n| ----------------- | -------------------------- |\n| append(obj)       | 添加元素                   |\n| insert(index,obj) | 插入                       |\n| remove(obj)       | 删除元素                   |\n| reverse()         | 列表反转                   |\n| index(obj)        | 返回第一个匹配项的索引位置 |\n| list(seq)         | 将元组转为列表             |\n\n## 元组：tuple\n\n内容来源：[Python3 元组](https://www.runoob.com/python3/python3-tuple.html)\n\n Python 的元组与列表类似，不同之处在于元组的元素不能修改。\n\n元组使用小括号 ( )，列表使用方括号 [ ]。\n\n元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。\n\n### 创建元组\n\n```python\ntup1 = ('Google', 'Runoob', 1997, 2000)\n```\n\n### 访问元组的元素\n\n```python\nprint(tup1[1])\n\nprint(tup1[1:3])\n```\n\n### 修改和删除？\n\n元组中的元素不允许修改，但可以连接元组\n\n```python\ntup2 = ('abc', 'xyz')\n\ntup3=tup1+tup2\n\nprint(tup3)\n```\n\n元组中的元素不可删除，但可以删除元组\n\n```python\ndel tup2\n\nprint(tup2)\n\n# name 'tup2' is not defined\n```\n\n### 元组的运算\n\n```python\ntup4=(3,4,5)\n\n# 元组元素个数\n\nprint(len(tup4))\n\n# 元素复制\n\nprint(tup4*4) \n\n# 判断元素是否在元组内\n\nprint(3 in tup4)\n# (3, 4, 5, 3, 4, 5, 3, 4, 5, 3, 4, 5)\n\n# isinstance 判断某个数据的数据类型\n\nprint(isinstance(tup4,tuple))\n\n# 将元组转为列表\n\nlist_tup4=list(tup4)\n\nprint(list_tup4)\n```\n\n### 元组的内置函数\n\n| 方法            | 描述                   |\n| --------------- | ---------------------- |\n| len(tuple)      | 计算元素个数           |\n| max(tuple)      | 元素最大值             |\n| min(tuple)      | 最小值                 |\n| tuple(iterabke) | 将可迭代序列转换为元组 |\n\n\n\n\n\n","tags":["Python"],"categories":["Python"]},{"title":"Python中的datetime和time","slug":"Python中的datetime和time","url":"/2022/11/26/python-zhong-de-datetime-he-time/","content":"\n本文记录Python中的日期和时间的用法。\n\n<!--more-->\n\n## 应用环境\n\nPython:3.9\n\nOS:Windows\n\nIDE:VS Code\n\n## 时间：time\n\n本节内容来源：[Python3  日期和时间](https://www.runoob.com/python3/python3-date-time.html)\n\n### 获取当前时间\n\n```python\nimport time\nprint (time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()))\n```\n\n输出：\n\n2022-11-26 15:43:44\n\n### 将时间字符串转为时间\n\n这里有个struct_time的东西，为tuple格式：\n\n```python\ntime_struct=time.strptime(\"2022-11-26 15:43:44\",\"%Y-%m-%d %H:%M:%S\")\nprint(time_struct)\n```\n\n输出结果如下:\n\ntime.struct_time(tm_year=2022, tm_mon=11, tm_mday=26, tm_hour=15, tm_min=43, tm_sec=44, tm_wday=5, tm_yday=330, \ntm_isdst=-1)\n\n> 注：这个是可以直接使用>,<等运算符直接比较大小的\n\n如判断当前时间是否在某个时间段：\n\n```python\ndef checkTimePassed(startTime,endTime):\n    start=time.strptime(startTime,\"%Y-%m-%d %H:%M:%S\")\n    end=time.strptime(endTime,\"%Y-%m-%d %H:%M:%S\")\n    nowstr=datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    now=time.strptime(nowstr,\"%Y-%m-%d %H:%M:%S\")\n    if now>start and now<end:\n        return True\n    else:\n        return False\n```\n\n\n\n将time_struct转为时间戳：\n\n```python\nprint (time.mktime(time.strptime(\"2022-11-26 15:43:44\",\"%Y-%m-%d %H:%M:%S\")))\n```\n\n输出\n\n1669448624.0\n\n### 时间格式化字符串\n\n- %y 两位数的年份表示（00-99）\n- %Y 四位数的年份表示（000-9999）\n- %m 月份（01-12）\n- %d 月内中的一天（0-31）\n- %H 24小时制小时数（0-23）\n- %I 12小时制小时数（01-12）\n- %M 分钟数（00=59）\n- %S 秒（00-59）\n\n## datetime\n\n### 获取当前时间\n\n```python\nimport datetime\ndt=datetime.datetime.now()\nprint(dt.strftime('%Y-%m-%d %H:%M:%S'))\n```\n\n输出\n\n2022-11-26 15:50:27\n\n### 获取前10分钟的时间\n\n使用datetime的**timedelta**方法：\n\n```python\nimport datetime\ndt=datetime.datetime.now()\nprint(dt.strftime('%Y-%m-%d %H:%M:%S'))\nyes_time = dt + datetime.timedelta(minutes=-10)\nnewTime=yes_time.strftime('%Y-%m-%d %H:%M:%S')\nprint(newTime)\n```\n\n输出：\n\n2022-11-26 15:51:15\n2022-11-26 15:41:15\n\n## strftime vs. strptime\n\nstrftime:将时间类型转为指定格式的字符串\n\nstrptime:将时间字符串转为时间\n\n","tags":["Python"],"categories":["Python"]},{"title":"Javascript中的let和const","slug":"Javascript中的let和const","url":"/2022/11/05/javascript-zhong-de-let-he-const/","content":"\n本文主要介绍在Javascript中出现的let和const关键字,它们是ES6中新增的。\n\n<!--more-->\n\n## 几个概念\n\n### ECMAScript和Javascript\n\nECMAScript6它是 ECMA-262 标准的第六个版本，其特点是对 ECMAScript 规范有着显著的变化和改进。\n\nES6=ECMAScript6=ES2015，描述的是同一个东西，名字不同。\n\nECMAScript是标准规范，Javascript是其实现(大概是这个意思)。\n\n### Babel\n\n一款可以将 ES6 代码转换为 ES5 代码的转译器。\n\n## let vs. var\n\n作用：声明一个在代码块中有效的变量。\n\n在ES6之前， JavaScript 只有两种作用域： **全局变量** 与 **函数内的局部变量**。  \n\nES6则引入了块级作用域，即用let声明的变量只能在代码块{}内有效，{}外不能访问，如：\n\n```javascript\n{\n    var x=2;\n    let y=3;\n}\nconsole.log(x);//2\nconsole.log(\"y:\"+y);//y is not defined\n```\n\n在循环体中，let关键字也是仅在循环体内部有效，如:\n\n```javascript\nlet i = 5;\nfor (let i = 0; i < 10; i++) {\n    // 一些代码...\n}\n// 这里输出 i 为 5\n```\n\n> let声明的全局变量不属于window对象，因此不能用window.访问；\n>\n> let关键字在相同的作用域中，是不可以重新声明赋值的；\n\n\n\n## const关键字\n\n作用：声明一个只读的常量，声明的同时必须进行初始化。\n\nconst 定义的对象或者数组，其实是可变的，可修改其属性值。\n\n## let和const\n\n**相同点:**\n\n都是块级作用域；\n\n都不能和它所在的作用域内的其它变量或函数拥有相同名称；\n\n**不同点：**\n\nconst声明时要同时初始化\n\nconst不能修改，但可重新为对象的属性赋值。\n\n## Referenced\n\n[1、JavaScript let 和 const ](https://www.runoob.com/js/js-let-const.html)\n\n[2、一文读懂 JavaScript 和 ECMAScript 的区别](https://blog.51cto.com/u_15127629/2871340)","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"Javascript中数组的使用","slug":"Javascript中数组的使用","url":"/2022/11/05/javascript-zhong-shu-zu-de-shi-yong/","content":"本文主要记录Javascript中数组的一些方法，包括map、reduce、filter等。\n<!--more-->\n\n## map()\n作用：通过指定函数处理数组的每个元素，并返回处理后的数组。\n\n实例：\n\n```javascript\n var nums=[1,2,3,4,5]\n var newArr=nums.map(num=>{\n     return num+1;\n });\n console.log(JSON.stringify(newArr));\n```\n\n输出结果:\n\n```javascript\n[2,3,4,5,6]\n```\n\n\n\n## filter()\n\n作用: 检测数值元素，并返回符合条件所有元素的数组。 \n\n## find()\n\n作用:返回通过测试（函数内判断）的数组的第一个元素的值。 \n\n## reduce()\n\n作用:接收一个函数作为**累加器**，数组中的每个值（从左到右）开始缩减，最终计算为一个值。 \n\n用法:array.reduce(function(total, currentValue, currentIndex, arr), initialValue)\n\n实例：\n\n```javascript\nvar nums=[1,2,3,4,5]\nvar sum=nums.reduce((total,num)=>{\n    return total+num;\n});\nconsole.log(sum);\n```\n\n输出结果:\n\n```javascript\n15\n```\n\n## splice()\n\n作用： 添加或删除数组中的元素。 \n\n用法： *array*.splice(*index*,*howmany*,*item1*,.....,*itemX*) \n\n| 参数            | 描述                                                         |\n| --------------- | ------------------------------------------------------------ |\n| index           | 添加或删除的位置                                             |\n| howmany         | 应该删除多少元素。必须是数字，但可以是 \"0\"。如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。 |\n| item1,....itemX | 要添加的元素                                                 |\n\n示例：\n\n```javascript\nvar nums=[1,2,3,4,5]\nvar deletedArr=nums.splice(1,1,10,11,13)\nconsole.log(JSON.stringify(nums));\n```\n\n输出结果:\n\n```javascript\n[1,10,11,13,3,4,5]\n```\n\n## indexOf()\n\n作用：返回数组中某个指定的元素位置 \n\n\n\n## concat()\n\n作用：连接两个或多个数组\n\n语法： *array1*.concat(*array2*,*array3*,...,*arrayX*) \n\n\n\n## join()\n\n作用：将数组中的元素转为为一个字符串\n\n语法： *array*.join(*separator*) \n\n\n\n## shift()\n\n作用：删除并返回数组的第一个元素\n\n\n\n## unshift()\n\n作用：向数组的开头添加一个或更多元素，并返回新的长度\n\n\n\n## sort()\n\n作用：对数组进行排序，会改变原始数组。 默认排序顺序为按字母升序。 \n\n语法： *array*.sort(*sortfunction*)\n\n示例：\n\n```javascript\nvar fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];\nfruits.sort();\nconsole.log(JSON.stringify(fruits));\n//[\"Apple\",\"Banana\",\"Mango\",\"Orange\"]\n\nfruits=[1,2,20,3,4,5];\nfruits.sort();\nconsole.log(JSON.stringify(fruits));\n//[1,2,20,3,4,5]\n\nfruits=[1,2,20,3,4,5];\nfruits.sort((a,b)=>{\n    return a-b;//升序\n});\nconsole.log(JSON.stringify(fruits));\n//[1,2,3,4,5,20]\n\nfruits=[\"杨蓉\",\"朱一龙\",\"彭冠英\"];\nfruits.sort((a,b)=>{\n    return a.localeCompare(b,'zh');\n});\nconsole.log(JSON.stringify(fruits));\n//[\"彭冠英\",\"杨蓉\",\"朱一龙\"]\n```\n\n\n\n## reverse()\n\n作用：反转数组元素，直接改变原始数组\n\n\n\n## slice()\n\n作用：返回指定位置的数据并组成新的数组\n\n语法： *array*.slice(*start*, *end*) \n\n示例：\n\n```javascript\nfruits = [\"Banana\", \"Orange\", \"Lemon\", \"Apple\", \"Mango\"];\nvar citrus = fruits.slice(1,3);\nconsole.log(JSON.stringify(citrus));\n// [\"Orange\",\"Lemon\"]\n```\n\n更多用法，可参考[文章](https://www.runoob.com/jsref/jsref-obj-array.html)","tags":["JavaScript"],"categories":["JavaScript"]},{"title":"Cesium编辑并保存Entity","slug":"Cesium编辑并保存Entity","url":"/2022/11/03/cesium-bian-ji-bing-bao-cun-entity/","content":"这里借助Cesium的exportKml方法，先将Entity转为xml字符串，然后借助mapbox的togeojson将kml转为geojson,从而实现Entity数据的保存。\n<!--more-->\n\n\n\n## Cesium编辑Entity\n可参考[绘制编辑线面](http://support.supermap.com.cn:8090/webgl/examples/webgl/editor.html#DrawAndEdit)\n\n## Cesium将Entity转为kml\n参考[exportKml](http://cesium.xin/cesium/cn/Documentation1.62/exportKml.html):\n```javascript\nlet entities = new Cesium.EntityCollection();\nentities.add(x);//其中x为Entity\nCesium.exportKml({\n     entities: entityCollection\n })\n  .then(function(result) {\n    var xmlStr=result.kml;\n  });\n```\n\n## kml转geojson\n使用[togeojson](https://github.com/mapbox/togeojson)可将kml转为geojson,如下:\n```javascript\n<script src='togeojson.js'></script>\n<script>\n$.ajax('test/data/linestring.kml').done(function(xml) {\n    console.log(toGeoJSON.kml(xml));\n});\n</script>\n```\n如果拿到的是xml的字符串形式，即：\n```xml\n\"<xml></xml>\"\n```\n需要先将xml字符串格式化，再调用toGeoJSON.kml函数:\n```javascript\nvar dom = (new DOMParser()).parseFromString(xmlStr, 'text/xml');\n```","tags":["Cesium","KML","Geojson"],"categories":["Cesium"]},{"title":"Windows Server 2019禁止自动更新","slug":"Windows-Server-2019禁止自动更新","url":"/2022/10/20/windows-server-2019-jin-zhi-zi-dong-geng-xin/","content":"windows server 2019 调整为手动更新\n<!--more-->\n在cmd中输入sconfig,然后选择\"5)Windows更新设置\"，之后选择手动更新即可，如图:![2022-10-20_201808](2022-10-20_201808.jpg)\n\n参考文章[Windows Server2019/2022中禁用自动更新(更改为手动更新)系统](https://www.cnblogs.com/yuwentao/p/15708595.html)","tags":["运维","Windows"],"categories":["运维"]},{"title":"Python的whl包的版本选择和依赖查询","slug":"python的whl包的版本选择和依赖查询","url":"/2022/10/16/python-de-whl-bao-de-ban-ben-xuan-ze-he-yi-lai-cha-xun/","content":"\n本文主要介绍如何选择合适的whl包，以及如何查询whl包的依赖。\n\n<!--more-->\n\n## pip离线安装时如果选择whl包\n这里以pycryptodomex为例\n先在可以访问互联网的机器上通过pip install pycryptodomex\n然后查询pycryptodomex,可以找到pycryptodomex-3.15.0.dist-info目录\n里面找到一个WHEEL文件，记录了版本信息:\n```\nWheel-Version: 1.0\nGenerator: bdist_wheel (0.36.2)\nRoot-Is-Purelib: false\nTag: cp35-abi3-win_amd64\n```\n这样就能确定应该要下载的whl包了\n\n## whl包的依赖查询\n\n在离线安装whl包，可能会出现有若干依赖没有安装的问题，这时如果能知道这个包的所有依赖，就能下载全部依赖后，再进行安装，这里以requests为例：\n\n先在一台可以访问互联网的机器上安装requests，然后执行以下命令:\n\n```\npip show requests\n```\n\n会出现如下信息：\n\n![](2022-10-16_194301.jpg)\n\n这样将这些依赖一起下载后，再去安装requests就可以了。","tags":["Python"],"categories":["Python"]},{"title":"Postgresql配置远程连接","slug":"Postgresql配置远程连接","url":"/2022/10/16/postgresql-pei-zhi-yuan-cheng-lian-jie/","content":"\n安装Postgresql后，如果需要通过Navicat等第三方客户端连接时，需要调整在配置文件。\n<!--more-->\n\n## 应用环境\nOS:windows\nPostgresql:v14\n\n## postgresql配置远程连接\n\n默认情况下，使用Navicat连接Postgresql,遇到了localhost无法连接的问题: [链接PostgreSQL报错authentication method 10 not supported解决](https://www.cnblogs.com/q149072205/p/15697287.html) 的问题，可通过修改pg_hba.conf文件来解决,具体如下:\n```\n# \"local\" is for Unix domain socket connections only\nlocal   all             all                           trust\n# IPv4 local connections:\nhost    all             all             127.0.0.1/32            trust\n# IPv6 local connections:\nhost    all             all             ::1/128                 trust\n```\n另如果需要其它ip来访问,如果192.168.10网段的Ip来访问postgresql，可通过增加以下内容来解决：\n```\nhost    all             all             192.168.10.0/24         trust\n```","tags":["数据库","PostgreSQL"],"categories":["数据库","PostgreSQL"]},{"title":"typecho博客迁移至hexo","slug":"typecho博客迁移至hexo","url":"/2022/10/16/typecho-bo-ke-qian-yi-zhi-hexo/","content":"\n本文记录typecho博客迁移到Hexo时使用的软件的注意事项。\n\n<!--more-->\n\n使用了[dealtypecho](https://github.com/g-mero/dealtypecho/releases/tag/1.0.0)\n\n软件界面如下图所示：\n\n![typecho文章导入](2022-10-16_142938.jpg)\n\n> 其中用户名和数据库名反了，使用的时候注意一下。","tags":["博客","Typecho"],"categories":["Hexo"]},{"title":"Hello World","slug":"hello-world","url":"/2022/10/16/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"github token 的生成","slug":"github-token-的生成","url":"/2022/10/16/github-token-de-sheng-cheng/","content":"参考 [github的token使用方法](https://blog.csdn.net/chengwenyang/article/details/120060010)","tags":["Hexo"],"categories":["Hexo"]},{"title":"Hexo的基本使用","slug":"Hexo的基本使用-md","url":"/2022/10/16/hexo-de-ji-ben-shi-yong-md/","content":"本文记录Hexo安装的基本步骤及遇到的各种问题。\n<!--more-->\n\n## Hexo安装\n\n```\nnpm install -g hexo-cli\n```\n初始化\n\n```\nhexo init\n```\n> 此时会选择hexo-generator-category的版本，但可能会不起作用，可直接修改package.json中hexo-generator-category 和hexo-generator-index 为0.1.3，然后执行npm install 命令，否则很多插件无法使用。\n\n配置主题\n\n进入themes目录，然后下载主题：\n\n```\ngit clone https://github.com/blinkfox/hexo-theme-matery\n```\n\n修改hexo根目录中的_config文件,将其theme设为主题的文件名:\n\n```\ntheme: hexo-theme-matery\n```\n\n## 创建新页面\n\n参考 [Hexo新建标签、分类、归档页面](https://yansheng836.github.io/article/7e72998a.html)\n\n```\nhexo new page \"tags\"\n```\n\n然后找到/source/tags/index.md，设置type为“tags\"\n\n```\ntitle: tags\ndate: 2022-10-16 09:09:13\ntype: \"tags\"\n```\n\n其它归档、分类页面同上即可\n\n## 创建新博客\n\n```\nhexo new \"新博客\"\n```\n\n标签和分类的语法:\n\n```markdown\ntags: [Typecho,博客]\ncategories: [Typecho,博客]\n```\n\n或\n\n```markdown\ntags:\n\t- 博客\n\t- Typecho\ncategories:\n\t- [123]\n\t- [456]\n\t- [123, 789]\n```\n\n\n\n## 生成部署文件及预览\n\n### 部署文件的生成\n\n```\nhexo g\n```\n\n生成部署文件，在public目录，可直接通过nginx或iis部署，\n\n### 本地预览\n\n```\nhexo s\n```\n\n如果没有错误，在浏览器中直接输入http://localhost:4000 即可访问到。\n\n## 将博客部署到github中\n\n> 提示:可以使用hexo-deployer-git部署，但Hexo1.0在本文写作时不支持此插件，故没有选择，如果hexo-deployer-git插件可以正常安装，可参考[技术小白搭建个人博客 ------ hexo+github](https://zhuanlan.zhihu.com/p/56101093)\n\n直接将public目录上传到github，然后直接访问https://shenmamuniu.github.io/ 即可：\n\n```\ngit init\ngit add .\ngit commit -m \"first commit\"\ngit config user.name \"\"\ngit config user.email \"\"\ngit remote add origin xx\ngit branch -M main\ngit push -u origin main\n```\n\n这里会涉及到登录，可生成一个[github token](https://blog.csdn.net/chengwenyang/article/details/120060010)\n\n## 图片问题\n\n修改配置文件_config.yml:\n\n```\npost_asset_folder: true\n```\n\n这样在执行hexo new 创建文章时，会创建一个同名的目录，把文章中的图片放到此目录中\n\n安装插件:\n\n```\n npm install hexo-asset-image -- save\n```\n\n如果最终找不到图片，图片路径多出io等信息，修改hexo_assets-image中的index.js文件，在第24行：\n\n```\nelse {\n    // var endPos = link.lastIndexOf('.');\n    var endPos=link.length-1;\n}\n```\n\nmarkdown语法书写`(test)[xxx.jpg]`，**不需要写相对路径，只需写图片名字.jpg即可** \n\n参考[文档](https://blog.csdn.net/Qyy2079628327/article/details/114859707)\n\n## 独立域名配置\n\n参考[文档](https://blog.csdn.net/v1coder/article/details/125109745)\n\n","tags":["Hexo"],"categories":["Hexo"]},{"title":"WebGL系列之三：ThreeJS webgl or CesiumJS Webgl","slug":"139","url":"/2022/08/28/139/","content":"本文主要是来自cesium论坛的一个回答，问题是CesiumJS的shader是否和ThreejS中的兼容。\n<!--more-->\n##  Q\nIs shader of CesiumJS compatible with threeJs’s GLSL?\n\n##  A:\n@Marco13\nThe shader code itself is written in GLSL. So you can use all the built-in functionality of GLSL in your vertex- or fragment shader.\n\nUsing “pure” GLSL in WebGL can be a bit cumbersome. Even simple things require a lot of effort and care. That’s why libraries usually introduce structures for simplifying the use of custom shaders.\n\nYou mentioned three.js. You can have a look at an example of how they set up the shader for a ShaderMaterial in one of the examples: You have to say, for example, that the object has vertex colors 1 so that you can use the color in the shader 1. Similarly, values like the modelViewMatrix will automatically be filled with sensible values. If you wanted to do that with plain WebGL, you’d have to use low-level functions like gl.getUniformLocation and gl.uniformMatrix4fv just to set this single matrix! Or for short: three.js is doing a lot of work for you behind the scenes!\n\nSimilarly, the CustomShader of CesiumJS is simplifying the setup for you, so that you can focus on the “core” part that should be customized. And this part is exactly the implementation of the vertexMain or fragmentMain function: CesiumJS is setting up all the attributes and uniforms that are required, and collects them in the VertexInput and FragmentInput structures. These structures are passed to the vertexMain/fragmentMain functions, where you can use them to implement custom behavior.\n\nThe following is overly simplified, but it can roughly be imagined like that:\n\n```\n// Many attributes that are part of the model:\nattribute float position;\nattribute float color;\nattribute float texCoord;\n...\n\n// Many uniforms that are part of the rendering setup\n...\n\n\nvoid main() {\n\n    // Collect all attributes in the VertexInput\n    VertexInput vertexInput;\n    vertexInput.attributes.positionMC = position;\n    vertexInput.attributes.color = color;\n    vertexInput.attributes.texCoord = texCoord;\n    \n    // Pass the attributes to your main function:\n    vertexMain(vertexInput, ...)\n}\n\n//============================================================================\n// You only have to write this part:\n\nvoid vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput)\n{\n    float customFactor = 12.34;\n    vsOutput.positionMC = vsInput.attributes.positionMC * customFactor;\n}\n```\nAll the work that is required for setting up the attributes and uniforms with low-level WebGL calls is done by CesiumJS. You can focus on the part below the ==== line in the example.\n\nFurther documentation, for example, for the VertexInput structure, can be found in the [CustomShaderGuide](https://github.com/CesiumGS/cesium/tree/main/Documentation/CustomShaderGuide) 6\n##  Summary\nThreeJS webgl和CesiumJS中的webgl都是更高层级的实现，封装了WebGL API中写法，简化了写法。因此在某些情况下，可能会显得不够用。\n\n##  Referenced\n[Is shader of CesiumJS compatible with threeJs’s GLSL](https://community.cesium.com/t/is-shader-of-cesiumjs-compatible-with-threejss-glsl/17458)\n[封面图](https://huadou145.lofter.com/post/205d4db3_1c7247e32)","tags":["WebGL"],"categories":["图形图像"]},{"title":"WebGL系列之二：基础概念","slug":"WebGL系列之二：基础概念","url":"/2022/08/28/webgl-xi-lie-zhi-er-ji-chu-gai-nian/","content":"本文来自网站[webglfundamentals](https://webglfundamentals.org/)的前三节内容。\n<!--more-->\n本文三个部分：基础概念、工作原理、Shaders和GLSL\n##  WebGL基础概念\n\nWebGL通常被认为是3D API，可以用来做一些很酷炫的3D的东西，实际上，它只是一个光栅化引擎，根据提供的点、线、三角形进行图形的绘制。它是在GPU中运行，因此相对来说运行速度会比较快(只要GPU性能够)。\n\nWebGL的代码有2个部分组成：顶点着色器(vertex shader)和片元着色器(fragment shader)，shader使用一种强类型语言——GLSL语言来完成,一组vertex shader和fragment shader组成Program,一个Web应用中可能会有多个Program.关系大致如图所示：\n![](2828327738.png)\n\n###  两个着色器\n\n####  顶点着色器\n\n顶点着色器(Vertex shader)负责进行坐标转换，输出顶点的坐标，坐标范围[-1,1]。\n一个顶点着色器的工作是生成裁剪空间坐标值，通常是以下的形式\n```\n    void main() {\n       gl_Position = doMathToMakeClipspaceCoordinates\n    }\n```\n每个顶点调用一次（顶点）着色器，每次调用都需要设置一个特殊的全局变量`gl_Position`，该变量的值就是裁减空间坐标值(Clip Space Coordinates)。\n> 注:这里的Clip Space Coordinates的翻译感觉不是很好。\n\n顶点着色器需要的数据，可以通过以下三种方式获得。\n\n1.  [Attributes 属性](# attributes-) (从缓冲中获取的数据)\n2.  [Uniforms 全局变量](# uniforms-) (在一次绘制中对所有顶点保持一致值)\n3.  [Textures 纹理](# textures-) (从像素或纹理元素中获取的数据)\n\n####  片元着色器\n\n片元着色器(Fragment shader)负责计算颜色，输出像素的颜色。\n一个片元着色器的工作是为当前光栅化的像素提供颜色值，通常是以下的形式\n```\n    precision mediump float;\n    \n    void main() {\n       gl_FragColor = doMathToMakeAColor;\n    }\n```\n每个像素都将调用一次片断着色器，每次调用需要从你设置的特殊全局变量`gl_FragColor`中获取颜色信息。\n\n片断着色器所需的数据，可以通过以下三种方式获取：\n\n1.  [Uniforms 全局变量](# uniforms-) (values that stay the same for every pixel of a single draw call)\n2.  [Textures 纹理](# textures-) (data from pixels/texels)\n3.  [Varyings 可变量](# varyings-) (data passed from the vertex shader and interpolated)\n\n###  两类着色器中的参数(变量)的关键词\n\n####  Attributes and Buffers \n\nBuffer是发送到GPU的一些二进制数据序列，通常情况下缓冲数据包括位置，法向量，纹理坐标，顶点颜色值等。\n你可以存储任何数据。\n\nArribute用来指明怎么从缓冲中获取所需数据并将它提供给顶点着色器。\n\n最常用的方法是缓冲和**属性**，在[工作原理](webgl-how-it-works.html)\n中讲到了缓冲和属性，你可以创建缓冲，\n```\n    var buf = gl.createBuffer();\n```\n将数据存入缓冲\n```\n    gl.bindBuffer(gl.ARRAY_BUFFER, buf);\n    gl.bufferData(gl.ARRAY_BUFFER, someData, gl.STATIC_DRAW);\n```\n然后初始化的时候，在你制作的（着色）程序中找到属性所在地址\n```\n    var positionLoc = gl.getAttribLocation(someShaderProgram, \"a_position\");\n```\n在渲染的时候告诉WebGL怎么从缓冲中获取数据传递给属性\n```\n    // 开启从缓冲中获取数据\n    gl.enableVertexAttribArray(positionLoc);\n    \n    var numComponents = 3;  // (x, y, z)\n    var type = gl.FLOAT;    // 32位浮点数据\n    var normalize = false;  // 不标准化\n    var offset = 0;         // 从缓冲起始位置开始获取\n    var stride = 0;         // 到下一个数据跳多少位内存\n                            // 0 = 使用当前的单位个数和单位长度 （ 3 * Float32Array.BYTES_PER_ELEMENT ）\n    \n    gl.vertexAttribPointer(positionLoc, numComponents, type, false, stride, offset);\n```\n在[WebGL 基础概念](webgl-fundamentals.html)中示范了不做任何运算直接将数据传递给`gl_Position`。\n```\n    attribute vec4 a_position;\n    \n    void main() {\n       gl_Position = a_position;\n    }\n```\n如果缓冲中存的是裁剪空间坐标就没什么问题。\n\n属性可以用 `float`, `vec2`, `vec3`, `vec4`, `mat2`, `mat3` 和 `mat4` 数据类型。\n\nvec4:向量：vec4 a = vec4(1, 2, 3, 4);\nmat2:2x2矩阵\n\n####  Uniforms\n\n全局变量，在着色程序运行前设置\n\n####  Textures\n\n着色程序运行时可随意读取其中的数据，为数组类型，通常里面存放的是图片，当然也可以只放颜色。\n\n####  Varyings\n\n顶点着色器如果需要给片元着色器传递数据，那么可以使用它。\n为了使用可变量，要在两个着色器中定义同名的可变量。\n给顶点着色器中可变量设置的值，会作为参考值进行内插，在绘制像素时传给片断着色器的可变量。\n\n##  WebGL工作原理\n\nWebGL在GPU上的工作基本上分为2个部分， 第一部分将顶点坐标转到到Clip space vertices,第二部分就是基于坐标绘制像素。\n这里有一个简单的例子：\n假设你正在画三角形，顶点着色器每完成三次顶点处理，WebGL就会用这三个顶点画一个三角形。它计算出这三个顶点对应的像素后，就会光栅化这个三角形，“光栅化”其实就是“用像素画出来”的花哨叫法。对于每一个像素，它会调用你的片断着色器询问你使用什么颜色。你通过给片断着色器的一个特殊变量`gl_FragColor`设置一个颜色值，实现自定义像素颜色。\n\nWebGL先获得顶点着色器中计算的三个颜色值，在光栅化三角形时将会根据这三个值进行插值。每一个像素在调用片断着色器时，可变量的值是与之对应的插值。想要给片断着色器传值，我们可以先把值传递给顶点着色器(varyings)然后再传给片断着色器。\n这里有一张来自OpenGL的图形管线的图，大致的描述了如何从顶点坐标到渲染到屏幕的过程：\n\n![](416715407.png)\n\n可阅读文章:[现代OpenGL简介](https://duriansoftware.com/joe/an-intro-to-modern-opengl.-chapter-1:-the-graphics-pipeline)\n\n##  GLSL\n###  GLSL简介\nGLSL全称是 Graphics Library Shader Language （图形库着色器语言），是着色器使用的语言。它有一些不同于JavaScript的特性，主要目的是为栅格化图形提供常用的计算功能。所以它内建的数据类型例如`vec2`, `vec3`和 `vec4`分别代表两个值，三个值和四个值，\n类似的还有`mat2`, `mat3` 和 `mat4` 分别代表 2x2, 3x3 和 4x4 矩阵。\n你可以做一些运算例如常量和矢量的乘法。\n```\nvec4 a = vec4(1, 2, 3, 4);\n```\n关于矩阵的计算和变换，有专门的库实现，如[glmatrix](https://glmatrix.net/),在此之前，可把线性代数部分熟悉一下。\n###  如何在js中使用glsl\n大致有两种方法：\n1、js的script标签改为nojs或顶点片元着色器标记，如：\n```\n<script id=\"vertexShader\" type=\"x-shader/x-vertex\">\n</script>\n<script id=\"fragmentShader\" type=\"x-shader/x-fragment\">\n</script>\n```\n2.直接使用字符串拼接的形式加载\n\n##  小结\nWebGL的全部内容就是创建不同的着色器，向着色器提供数据然后调用`gl.drawArrays`或 `gl.drawElements`让WebGL调用当前顶点着色器处理每个顶点，调用当前片断着色器渲染每个像素。\n实际上创建着色器需要为数不多的几行代码，并且在大多数WebGL应用程序中都相似，因此一旦写完几乎可以不再关心它们了。[在这里介绍如何编译GLSL并链接到着色程序](webgl-boilerplate.html)。\n至此，WebGL的基础概念部分就到此结束了，后面的内容大部分都是介绍API相关的，如有兴趣，可继续在[webglfundamentals](https://webglfundamentals.org/)学习。\n\n##  Referenced\n[封面图](https://alisonmarket.lofter.com/post/2b1789_1c808c676)","tags":["WebGL"],"categories":["图形图像"]},{"title":"WebGL系列之一：OpenGL vs. WebGL","slug":"WebGL系列之一：OpenGL vs. WebGL","url":"/2022/08/28/webgl-xi-lie-zhi-yi-opengl-vs.webgl/","content":"本文主要介绍WebGL的起源，同OpenGL、OpenGL ES之间的关系。\n<!--more-->\n##  OpenGL And OpenGL ES\nOpenGL 就是 GPU 驱动 的一套标准接口;\nOpenGL ES 为嵌入式设备 GPU 驱动（如手机）的标准接口， 全称：OpenGL for Embedded Systems,它是OpenGL的子集。\n\nOpenGL 是可跨平台使用的 API，移动端使用 OpenGL ES 作为图形 API，苹果在 2014 年推出了 Metal 作为图形 API，但它们的一些专业名词、渲染过程等都是一样的。\n\n无论是OpenGL、OpenGL ES、Metal的本质都是利用GPU芯片来实现高效的渲染图像，我们可以利用这些API操控GPU去完成我们想做的事,如：\n1、游戏开发：游戏的场景、人物的渲染，这些都是由引擎去做的。\n2、音视频开发：视频解码后变成了二进制数据，利用OpenGL将这些数据渲染到屏幕。\n3、地图开发：地图引擎对地图数据的渲染\n4、动画开发：实现动画的绘制\n5、视频处理：视频滤镜开发\n\n这两者之间最大差别就是**两者应用场景不一样**，一个是计算机，一个是移动或嵌入式设备。\n这种差别体现在两个方面：\n1、 **窗口系统不一样。\n**OpenGL ES 是一个平台中立的图形库，在它能够工作之前，需要于一个实际的窗口系统关联起来，这一点 OpenGL 也是一样的。\n但是 **OpenGL 时代在不同平台上有不同的机制一关联窗口系统，**在 Windows上是wgl，在X-Window上市 xgl ,在 Apple OS 上是 agl 等。\n而嵌入式市场的平台种类不计其数，单是学习各家手机操作系统的接口就是很大负担了，更不用说致力于支持各种尺寸平台的软件开发者，**所以OpenGL ES 提供了Window Surface的抽象，使得移植工作基本可以局限在重新实现一下建立窗口的过程**。\n这个窗口工具是 EGL, 全称: **embedded Graphic Interface**,是 **OpenGL ES 和底层 Native 平台 视窗系统之间的接口**。\n2、功能规模不一样。\n嵌入式设备和移动设备追求的是高性能，**因此 OpenGL ES 相对OpenGL 删减了一切低效能的操作方式**，有高性能的决不留低效能的，即只求效能不求兼容性(和苹果的作风类似)。\n\n##  WebGL\nWebGL，是一项用来**在网页上绘制和渲染复杂三维图形（3D图形），并允许用户与之交互的技术。**随着个人计算机和浏览器的性能越来越强，我们能够在Web上创建越来越精美、越来越复杂的3D图形。从传统意义上来说，为了显示三维图形，开发者需要使用 C 或 C++ 语言，辅以专门的计算机图形库，如OpenGL或Direct3D，来开发一个独立的应用程序。现在**有了 WebGL，我们只需要向已经熟悉的 HTML 和 JS 中添加一些额外的三维图形学的代码**，就可以在网页上显示三维图形了。**WebGL 是内嵌在浏览器中的，不必安装插件和库就可以直接使用它**。\n\n##  三者之间的关系\nOpenGL ES 可以说是 OpenGL 为了满足嵌入式设备需求而开发一个特殊版本，是其一个子集；而 **WebGL，是为了网页渲染效果，将 JavaScript 和 OpenGL ES 2.0 结合在一起，通过增加 OpenGL ES 2.0 的一个JavaScript绑定得到**。\n基本关系如下:\n![](2967495361.png)\n\n在实际应用过程中，前端的 **WebGL 是通过 JS 语句，操作本地的OpenGL的部分接口，**对于移动设备这是操作OpenGL ES的接口，来实现页面的图形的渲染，WebGL只是绑定外面接口的一层，内部的一些核心内容，如着色器，材质，灯光等都是需要借助 GLSL 语法来操作的。\n\n三者之间的版本关系:\n\n\n![](2524471132.png)\n\n##  三者之间的区别\n**WebGL 与其他 OpenGL 最大差别就是其可以通过 HTML 脚本本身实现 Web 交互式三维动画的制作，无需任何浏览器插件支持。**至于OpenGL ES和OpenGL之间的区别见本文第一节OpenGL And OpenGL ES。\n\n##  Referenced\n[OpenGL/OpenGL ES（一）基础知识](https://www.jianshu.com/p/8a246e01a534)\n[An intro to modern OpenGL. Chapter 1: The Graphics Pipeline](https://duriansoftware.com/joe/an-intro-to-modern-opengl.-chapter-1:-the-graphics-pipeline)\n[封面](https://melare.lofter.com/post/1f010e23_1c71032c6)","tags":["WebGL"],"categories":["图形图像"]},{"title":"使用POSTGIS的ST_Value函数查询栅格值","slug":"132","url":"/2022/08/22/132/","content":"之前查询dem值时，一直是在ArcServer发布DEM数据，然后通过调用服务的Identify方法来查询的,但由于ArcServer过于庞大,因此考虑用其它方法来替代，这里使用PostGIS的ST_Value函数来进行栅格的查询。\n<!--more-->\n\n##  dem数据导入到postgis\n```\nraster2pgsql.exe -s 4326 -C E:/Data/dem/江津区_DEM.tif public.zjk | psql.exe -h localhost -p 5432 -U postgres -d dem_test -W\n```\n##  ST_Value的使用\n```\nSELECT ST_Value(cqdem.rast,1, ST_SetSRID(ST_MakePoint(107.7,30.09),4326),false, 'bilinear')\nFROM public.cqdem\n```\n\n> The allowed values of the resample parameter are \"nearest\" which performs the default nearest-neighbor resampling, and \"bilinear\" which performs a bilinear interpolation to estimate the value between pixel centers.\n\n如果需要坐标转换,geomeotry参数改为以下:\nST_Transform(ST_SetSRID(ST_MakePoint(lon,lat),4326),3035)\n\n##  遗留的问题\n1、当DEM数据计比较大时，可能会无法导入;\n2、有的DEM数据即便使用了blinear插值，还是只能查询到整数的结果；\n\n##  Referenced\n[1、纬度/经度点的PostGIS栅格值](https://qastack.cn/gis/14960/postgis-raster-value-of-a-lat-lon-point)\n[2、ST_Value](http://postgis.net/docs/RT_ST_Value.html)\n[3、封面图源](https://lyla7784.lofter.com/post/30a15a3d_1c8923399)","tags":["空间数据库","PostGIS"],"categories":["Python"]},{"title":"Python实现将Markdown转PDF","slug":"131","url":"/2022/08/22/131/","content":"由于Markdown在移动端读取稍微困难，因此存在将markdown文件转为PDF文档的需要。首先将markdown文件转为html,然后再用工具将html转为pdf文件。\n<!--more-->\n\n##  应用环境\nOS:windows\nPython:3.9\n\n##  文件遍历\n\n```\n# md文件路径\noriginal_path = u'xxx/xxx' \n# 输出路径\nsaved_path = u'xxx/xxx'\n\nfor root,dirs,files in os.walk(original_path):\n    # for dir in dirs:\n    #     print(os.path.join(root,dir))        \n    for file in files:\n        if file.endswith('md'):\n            input=os.path.join(root,file)\n            file = file[:-2] + 'pdf'\n            dirName=''\n            # 处理多级目录的情况\n            if root==original_path:\n                dirName=root.replace(original_path,'')\n            else:\n                dirName=root.replace(original_path+'\\\\','')\n            # print(dirName)\n            dirOpt = os.path.join(saved_path, dirName)\n            if not os.path.exists(dirOpt):\n                # 相比mkdir,此方法可创建多级目录\n                os.makedirs(dirOpt)\n            output=os.path.join(dirOpt,file)\n\n            if not os.path.exists(output):\n                cvtMd2Pdf(input=input,output=output)\n\n```\n\n##  markdown转pdf\n\n```\nimport pdfkit\nfrom markdown import markdown\nimport os\n\ndef cvtMd2Pdf(input,output):\n    with open(input, encoding='utf-8') as f:\n        text = f.read()\n\n    html = markdown(text, output_format='html',extensions=['tables'])  # MarkDown转HTML\n    htmltopdf = r'C:\\\\Program Files\\\\wkhtmltopdf\\\\bin\\\\wkhtmltopdf.exe'\n    configuration = pdfkit.configuration(wkhtmltopdf=htmltopdf)\n    pdfkit.from_string(html, output_path=output, configuration=configuration, options={'encoding': 'utf-8'})  \n```\n\n##  缺点和不足\n1、存在某些文件转换失败的问题\n2、转换效率不高\n\n##  参考文档\n[1、python遍历某个文件夹下的所有子文件夹及文件](https://www.cnblogs.com/yibeimingyue/p/14678667.html?ivk_sa=1024320u)\n[2、Python实战之markdown转pdf(包含公式转换)](https://www.jb51.net/article/231989.htm)\n[3、封面图源](https://tiezhuzhuzhu923.lofter.com/post/310ff6d7_1c804cbfb)\n\n","tags":["Python"],"categories":["Python"]},{"title":"局域网生成https证书","slug":"130","url":"/2022/07/10/130/","content":"通过mkcert生成证书,为局域网网站添加https支持。\n<!--more-->\n##  应用环境\nOS:windows\nmkcert:[1.4.1](https://github.com/FiloSottile/mkcert)\nNginx:1.20.2\n\n##  安装根证书到服务器\n\n将下载的mkcert-v1.4.1-windows-amd64.exe重命名为mkcert,执行以下命令：\n```\nmkcert -install\n```\n\n> 卸载\nmkcert -uninstall\n\n##  为应用服务器生成ssl证书\n```\nmkcert -pkcs12 192.168.10.106 //生成p12格式的正式iis可以用，默认密码为：“changeit”\n```\n如果需要为Nginx生成证书，可通过以下命令：\n```\nmkcert 127.0.0.1 localhost //后面还可以继续空格添加其他域名或IP地址，默认是pem格式\n```\n\n此时会生成x.pme和x-key.pem两个文件，然后再Nginx配置：\n\nNginx ssl配置:\n```\nlisten 443 ssl;\n\nssl_certificate   ../cert/192.168.10.106.pem;\nssl_certificate_key  ../cert/192.168.10.106-key.pem;\nssl_session_timeout 5m;\nssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\nssl_protocols TLSv1 TLSv1.1 TLSv1.2;\nssl_prefer_server_ciphers on;\n```\n\n##  生成客户端证书\n```\nmkcert -pkcs12 -client 192.168.10.123\n//生成p12格式客户端证书，win用户可以直接导入，默认密码为：“changeit”\n```\n直接安装即可。\n\n> pem格式\nmkcert -client 192.168.10.123 //客户端证书，默认是pem格式\n\n##  Nginx端口占用问题\n如遇到以下问题:\nnginx: [emerg] bind() to 0.0.0.0:443 failed (10013: An attempt was made to access a socket in a way\n按以下命令找到对应的进程,直接杀死即可：\n```\nnetstat -aon|findstr \"443\"\n```\n##  Referenced\n[1、封面图源](https://huadou145.lofter.com/post/205d4db3_1c81c6e8f)","tags":["Nginx","应用安全","运维"],"categories":["应用安全"]},{"title":"C# 使用Topshelf安装windows服务","slug":"129","url":"/2022/06/22/129/","content":"最近在使用c# 控制台程序接收tcp数据时，经常运行一段时间后服务中断,需要和之前运行jar包一样，按下ctrl+c程序才会恢复,因此想到.net中将控制台程序转到后台运行,将其安装为windows服务。\n<!--more-->\n\n##  应用环境\nOS:win10\nIDE:vs2019\n.NET版本:4.5.2\nTopshelf:4.0.3\n\n##  Topshelf的安装\n通过visual studio的nuget包管理器安装topshelf包,支持的最低版本为.net framework4.5.2。\n\n##  Topshelf的使用\n创建一个控制台程序,添加如下内容:\n```\nHostFactory.Run(x => {\n    x.Service<TaskService>();\n    x.RunAsLocalSystem();\n    x.SetDescription(description);\n    x.SetDisplayName(displayName);\n    x.SetServiceName(serviceName);\n});            \nConsole.ReadKey();\n```\n添加TaskService类:\n```\npublic class AISService : ServiceControl\n{\n    public bool Start(HostControl hostControl)\n    {\n        \n    }\n\n    public bool Stop(HostControl hostControl)\n    {\n    \n    }\n}\n```\n添加完之后，生成项目。\n##  服务安装和卸载\n在cmd窗口中，输入以下命令安装:\n```\n./xxx.exe install\n```\n卸载：\n```\n./xxx.exe uninstall\n```\n\n##  c# 程序以管理员身份运行程序\n\n添加应用程序清单文件，即app.manifest,将requestedExecutionLevel部分改为以下内容:\n```\n<requestedExecutionLevel  level=\"requireAdministrator\" uiAccess=\"false\" />\n```\n\n##  Referenced\n[1、封面图](https://alisonmarket.lofter.com/post/2b1789_1c7361bf1# )","tags":["C"],"categories":["语言"]},{"title":"c# networkStream运行一段时候后连接丢失","slug":"128","url":"/2022/06/21/128/","content":"c# 在使用接收tcpserver中的数据时,经常运行一段时间后出现假死的状态，无法再接收数据，也没有报错信息，通过设置readTimeout来重新连接tcpserver实现数据的继续接收。\n<!--more-->\n##  环境\n应用环境：.net framework4.0\nos:win10\n\n##  设置ReadTimeout参数\n\n在读取网络流中的数据时，总是运行10分钟后连接就丢失，无法读取到数据了，可通过设置ReadTimeout参数，在指定的时间内如果读取不到网络流时,会报如下错误：\n```\n无法从传输连接中读取数据: 由于连接方在一段时间后没有正确答复或连接的主机没有反应，连接尝试失败。。\n```\n此时进入异常处理函数中，重新连接即可。\n```\ntry{\n    tcpClient = new TcpClient();\n    tcpClient.Connect(System.Net.IPAddress.Parse(this.ip), this.port);\n    networkStream = tcpClient.GetStream();\n    networkStream.ReadTimeout = 10000;\n}\ncatch(Exception ex){\n    //重新连接逻辑代码\n}\n\n```\n##  Referenced\n[1、C# 中NetworkStream类Read函数导致程序死机的问题](https://blog.csdn.net/v6543210/article/details/85016784)\n[2、封面图源](https://huadou145.lofter.com/post/205d4db3_1c8a36320)","tags":["C"],"categories":["语言"]},{"title":"C# Thread启动多线程","slug":"127","url":"/2022/06/21/127/","content":"仅对c# 中Thread类的使用做简单记录，至于使用多线程对应用程序性能带来的影响不在本文研究范围内，但在某些情况下多线程确实对程序的性能有很大的影响，还需结合具体的情况使用。\n\n<!--more-->\n\n##  应用环境\n开发环境:vs2010+.net framework4.0\nOS:win10\n\n##  ThreadStart不带参数\n\n```\nThread t = new Thread(ConnectToServer,0);\nt.Start();\n```\n> 其中ConnectToServer为函数名称\n\n##  ThreadStart带一个参数\n\n```\nThread t2 = new Thread(new ParameterizedThreadStart(InsertDb));\nt2.Start(reJson);\n```\n> 这里函数的参数为object类型\n\n##  Referenced\n[1、C# Thread启动线程时传递参数](https://blog.csdn.net/gubaofu/article/details/104648916)\n[2.封面图源](https://huadou145.lofter.com/post/205d4db3_1c84a2eba)","tags":["C"],"categories":["语言"]},{"title":"windows下jar包部署的web应用经常卡死无响应","slug":"126","url":"/2022/06/21/126/","content":"在windwos下运行java web应用时，总是出现程序中断的情况，控制台也没有错误输出,通过按ctrl+c就恢复正常,linux下却没有遇到到这种问题,通过使用javaw启动java应用程序来解决此问题。\n<!--more-->\n##  应用环境\nOS：windows\n\n##  Abstract\n当在windows系统运行jar包服务时，使用doc窗口直接通过java -jar xxx.jar带来的两个弊端：\n\n1、一个doc窗口只能运行一个服务，如果需要另外部署其他服务，需要再开一个doc窗口\n2、服务会出现假死状态，网络、端口是通的，就是访问一直出现超时的问题\n\n##  jar包是不是卡死,接口无响应\n可将Jar包的执行命令调整为:\n```\njavaw -jar xx.jar\n```\n    \n##  windows tomcat配置后台启动\n[Tomcat后台启动](win10下tomcat后台启动方式)：\n进入bin目录,打开setclasspath.bat文件,找到如下内容\n```\nset_RUNJAVA=\"%JRE_HOME%\\bin\\java\"\n```\n将其修改为:\n```\nset_RUNJAVA=\"%JRE_HOME%\\bin\\javaw\"\n```\n然后启动tomcat即可,此时cmd窗口不会再有输出，关闭即可。\n\n##  java、javaw、javaws的区别\n一句话总结:\njava.exe用于启动window console控制台程序;\njavaw.exe用于启动 GUI程序,而不会出现黑窗;\njavaws.exe用于web程序。\n具体可参考文末的链接2。\n\n##  Referenced\n[1、windows环境下使用java -jar命令运行jar包出现假死问题](https://blog.csdn.net/millery22/article/details/123611593)\n[2、java和 javaw 及 javaws的区别解析](https://www.jb51.net/article/189754.htm)\n[3、java vs javaw vs javaws](https://javapapers.com/core-java/java-vs-javaw-vs-javaws/)\n[4. 封面图源](https://huadou145.lofter.com/post/205d4db3_1c71e6ba8)\n","tags":["Java"],"categories":["语言"]},{"title":"使用javascript-obfuscator混淆js代码","slug":"125","url":"/2022/06/16/125/","content":"本文介绍代码js代码混淆工具javascript-obfuscator的基本使用。\n<!--more-->\n\n##  应用环境\nOS:win7\nNodeJS:12.22\n\n##  安装javascript-obfuscator\n全局安装:\n```\nnpm install -g javascript-obfuscator\n```\n>注:javascript-obfuscator对nodejs版本有要求,大版本支持12、14及以上;\n> win7需要安装nodejs 12.22\n\n##  javascript-obfuscator的使用\n\n###  对单个文件进行混淆\n\n```\njavascript-obfuscator xx.js --output xx.min.js\n```\n\n###  对整个文件加进行混淆\n\n```\njavascript-obfuscator ./xxx --output ./xxxx\n```\n\n具体可参考[javascript-obfuscator](https://github.com/javascript-obfuscator/javascript-obfuscator)\n\n##  Referenced\n[1、Cover](https://huadou145.lofter.com/post/205d4db3_1c7474e60)\n","tags":["代码混淆","应用安全"],"categories":["应用安全"]},{"title":"Python中获取前一天的时间","slug":"124","url":"/2022/06/13/124/","content":"本文主要介绍python中的时间差函数\n<!--more-->\n##  应用环境\nOS:win10\nPython:3.9\n\n##  datetime获取当前时间\n\n```\nimport datetime\n\ndt=datetime.datetime.now()\nuptime=dt.strftime('%Y-%m-%d %H:%M:%S')\nprint(uptime)\n```\n\n##  timedelta\ntimedelta有以下几个参数:\ndays=0,seconds=0,microseconds=0,milliseconds=0,minutes=0,hours=0,weeks=0\n可根据需要获取到前1天,前1分钟的的时间，如下获取到前10分钟的时间：\n```\ndt=datetime.datetime.now()\nyes_time = dt + datetime.timedelta(minutes=-10)\nuptime=yes_time.strftime('%Y-%m-%d %H:%M:%S')\nprint(uptime)\n```\n##  Referenced\n[1、封面图](https://huadou145.lofter.com/post/205d4db3_1c7247e32)","tags":["Python"],"categories":["Python"]},{"title":"Python查询mariadb数据库总是查到缓存的问题","slug":"123","url":"/2022/06/13/123/","content":"Python中操作Mariadb有多个包，这里用了mariadb和pymysql两种包，大体一致，可能mariadb这个包的部分类的函数没有pymysql那么丰富。\n<!--more-->\n##  应用环境\nOS:win10\nMariadb(数据库软件):10.6\nPython:3.9\nPyMySQL:1.0.2\nmariadb:1.0.11\n\n##  背景\n\n这里使用了tornado发布了一个服务，用来查询数据库中某个表的记录数，因为是实时数据展示，所以我这里查询还是比较快，但当我数据有更新时，这里返回的还是同一个值:\n```\nimport mariadb\nconn= mariadb.connect(user=\"xx\", host=\"localhost\", database=\"xxx\", password=\"xxx\")\nclass AisCountHandler(tornado.web.RequestHandler):\n    def post(self):\n        querySql=\"select count(*) from jtb\"\n        cursor= conn.cursor(buffered=False)\n        cursor.execute(querySql)\n        result=cursor.fetchone()[0]\n        self.write(str(result))\n    def options(self):\n        self.set_status(204)\n        self.finish()\n```\n\n##  使用reset函数重置连接\n\n由于mariadb中的cursor这里没有close函数,因此猜测是连接的问题，因此在self.write前面调用重置连接函数即可：\n```\nconn.reset()\n```\n\n> 关于[Connection.reset()](https://mariadb-corporation.github.io/mariadb-connector-python/connection.html?highlight=connection# mariadb.connections.Connection)\n>    Resets the current connection and clears session state and pending results. Open cursors will become invalid and cannot be used anymore.\n\n##  Referenced\n[1、封面来源](https://huadou145.lofter.com/post/205d4db3_1c7247e32)","tags":["Python","数据库"],"categories":["Python"]},{"title":"Python使用pika操作RabbitMQ","slug":"122","url":"/2022/06/13/122/","content":"本文对pika的使用中遇到的几个问题做了简单的介绍：具体包括长连接、消息确认、连接断开的处理等。\n<!--more-->\n\n##  应用版本\nOS:win10\nPython:3.9\nPika:1.2.1\nRabbitMQ:3.10.5\n\n##  为什么要用消息队列\n\n直接写入数据库效率比较低，时间稍微长一点，就会导致接收到的数据无法被及时处理。\n\n##  为什么要使用RabbitMQ\n\n相比ActiveMQ、RocketMQ、Kafka,更喜欢RabbitMQ的文档,且有可视化界面，学习成本低。\n\n##  pika操作RabbitMQ\n\n[RabbitMQ Tutorials](https://www.rabbitmq.com/getstarted.html)对RabbitMQ有非常详细的讲解，如果有比较深入的应用，可以具体了解，本文仅介绍基本使用以及几个比较重要的参数。\n\n###  生产者\n\n这里以简单的代码为例，仅对其中几个重要的参数进行说明\n```\nimport pika\n\ntry:\n    connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost',heartbeat=0))\n    channel = connection.channel()\n    channel.queue_declare(queue='hello',durable=True)\n    channel.basic_publish(exchange='',\n                        routing_key='hello',\n                        body=self.request.body,\n                        properties=pika.BasicProperties(\n                            delivery_mode = 2, # make message persistent\n                        ))\n    channel.close()\n    connection.close()\nexcept:\n    print(\"连接异常\")\n```\n\n> 几个参数:\n> connection:heartbeat：心跳监测,0时为一直保持连接\n> channel:durable:是否持久化,即使Rabbitmq意外关闭时依旧可以恢复，同时还需要设置delivery_mode=2\n\n###  消费者\n这里主要设置auto_ack为false,表示消息只有得到了确认之后才算消费完成，如果没有得到确认，还会收到此消息\n```\nconnection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))\nchannel = connection.channel()\nchannel.queue_declare(queue='hello')\n\ndef callback(ch, method, properties, body):\n    print(\" [x] Received %r\" % body)\n    ch.basic_ack(delivery_tag = method.delivery_tag)\n\nchannel.basic_consume(queue='hello', on_message_callback=callback, auto_ack=False)\nchannel.start_consuming()\n```\n\n###  关于连接断开的问题\n\n在遇到网络中断的情况下，需要能够重新连接，[pika的介绍页面](https://pypi.org/project/pika/)提供了2中方法：1种使用while循环，第二种是使用retry组件，具体如下:\n\n###  使用While循环\n```\nimport pika\nwhile True:\n    try:\n        connection = pika.BlockingConnection()\n        channel = connection.channel()\n        channel.basic_consume('test', on_message_callback)\n        channel.start_consuming()\n    # Don't recover if connection was closed by broker\n    except pika.exceptions.ConnectionClosedByBroker:\n        break\n    # Don't recover on channel errors\n    except pika.exceptions.AMQPChannelError:\n        break\n    # Recover on all other connection errors\n    except pika.exceptions.AMQPConnectionError:\n        continue\n\n```\n\n###  使用retry\n```\nfrom retry import retry\n\n@retry(pika.exceptions.AMQPConnectionError, delay=5, jitter=(1, 3))\ndef consume():\n    connection = pika.BlockingConnection()\n    channel = connection.channel()\n    channel.basic_consume('test', on_message_callback)\n\n    try:\n        channel.start_consuming()\n    # Don't recover connections closed by server\n    except pika.exceptions.ConnectionClosedByBroker:\n        pass\n        \nconsume()\n```\n\n##  Referenced\n[1、封面图](https://melare.lofter.com/post/1f010e23_1c71032c6)","tags":["Python","消息队列"],"categories":["Python"]},{"title":"基于PostGIS的等值线分析服务发布","slug":"121","url":"/2022/05/30/121/","content":"在用Cesium原生的等高线工具时，由于地形存在分级，不同级别下的地形的精度不同，因此生成的等高线也在时刻发生变化，且无法知道高程，给用户造成了一定的困惑。正好PostGIS3.2中提供了ST_Contour函数可生成等高线，本文即利用ST_Contour函数来生成等值线。\n\n<!--more-->\n\n##  应用环境\n\nPostGIS:3.2.1\n\nPostgresql:14.3\n\nOS:win10\n\npython:3.9\n\n##  地形导入PostGIS数据库\n\nQGIS只提供矢量数据的导入，并未提供栅格数据的导入功能，这里可使用PostGIS安装目录下的raster2pgsql程序进行导入，命令如下：\n```\n./raster2pgsql.exe -s 4326 -C E:/Data/dem/江津区_DEM.tif public.dem | ./psql.exe -h localhost -p 5432 -U postgres -d chongqing -W\n```\n\n关于参数说明，可通过以下命令查看\n\n```\n./raster2pgsql.exe\n```\n> 提示:不能使用SuperMap IDesktop导入栅格数据，导入后的格式不太一样，会导致后面的ST_Contour函数无法使用。\n\n\n##  使用ST_Contour函数\n\n使用如下sql语句进行查询:\n\n```\nWITH c AS (\nSELECT (ST_Contour(rast, 1, fixed_levels => ARRAY[1000.0, 1200.0, 1300.0])).*\nFROM public.\"dem\" WHERE rid = 1\n)\nSELECT id, value,st_astext(geom)\nFROM c order by value asc;\n```\n\nST_Contour函数的[参数说明](http://www.postgis.net/docs/manual-3.2/RT_ST_Contour.html):\n\n| 参数名         | 说明           |\n| -------------- | -------------- |\n| level_interval | 等值线间隔     |\n| fixed_levels   | 取固定的高程值 |\n\n##  Python连接PostGIS提供REST服务\n\n这里使用[psycopg2](https://pypi.org/project/psycopg2/)连接postgis数据库,使用tornado提供REST服务。\n\n安装psycopg2及tornado:\n\n```\npip install psycopg2 -i https://mirrors.aliyun.com/pypi/simple/\npip install tornado -i https://mirrors.aliyun.com/pypi/simple/\n```\n\n也可以下载whl文件离线安装:\n\n```\npip install xx.whl\n```\npsycopg2的使用可[参考](https://www.cnpython.com/qa/83354),代码如下：\n```\nimport psycopg2\nconn = psycopg2.connect(database='postgis', user='postgres')\ncurs = conn.cursor()\n\n# Find the distance within 1 km of point-of-interest\npoi = (-124.3, 53.2)  # longitude, latitude\n\n# Table 'my_points' has a geography column 'geog'\ncurs.execute(\"\"\"\\\nSELECT gid, ST_AsGeoJSON(geog), ST_Distance(geog, poi)\nFROM my_points, (SELECT ST_MakePoint(%s, %s)::geography AS poi) AS f\nWHERE ST_DWithin(geog, poi, 1000);\"\"\", poi)\n\nfor row in curs.fetchall():\n    print(row)\n```\n\ntornado的使用：\n\n```\nimport tornado.ioloop\nimport tornado.web\nfrom tornado import ioloop, web, websocket, httpclient\nimport tornado.gen\nfrom tornado.concurrent import run_on_executor\nfrom concurrent.futures import ThreadPoolExecutor\nimport tornado.httpserver\n\nclass IndexHandler(tornado.web.RequestHandler):\n    def get(self):\n    \tself.write({\n            \"data\":result\n        })\n    def post(self):\n        lngMax= float(self.get_argument('lngMax'))\n        self.write({\n            \"data\":result\n        })\n        \n    def options(self):\n        self.set_status(204)\n        self.finish()\n\n\nclass Application(tornado.web.Application):\n    def __init__(self):\n        handlers = [\n            (r'/gisfunc/rest/contour', IndexHandler)\n        ]\n        tornado.web.Application.__init__(self, handlers,autoreload=False, debug=False)\nif __name__ == \"__main__\":\n    app = Application()\n    app.listen(8866)  \n    tornado.ioloop.IOLoop.current().start()\n```\n\n这样前端就可以通过调用发布的REST服务进行等高线的绘制。\n\n##  小结\n\n这种方法在查询速度和准确性上相比其它方法都有明显的提升，但线段之间的平滑度不够，后续还需要在这方面进行优化。\n\n##  Referenced\n[1、封面图源](https://lyla7784.lofter.com/post/30a15a3d_1c8923399)","tags":["Python","PostGIS"],"categories":["Python"]},{"title":"Geoserver+Postgis发布服务","slug":"Geoserver+Postgis发布服务","url":"/2021/10/08/geoserver-postgis-fa-bu-fu-wu/","content":"本文通过qgis+postgis+geoserver实现矢量数据的存储与数据共享。\n<!--more-->\n##  应用环境\nOS:win8 x64\nPostGIS:3.1.4\nPostgresql:10.18.2\nGeoserver:2.19.2\nTomcat:8.5.71\nJDK:1.8.131\nQGIS:3.16.11\n\n##  Postgresql和Postgis\nPostgresql为开源的关系型数据库，Postgis为在此基础上开发的支持空间数据存储与计算的扩展工具，为Postgresql提供了空间数据存储与计算的能力。\n\npostgis对postgresql的版本支持可以参考此处[链接](https://trac.osgeo.org/postgis/wiki/UsersWikiPostgreSQLPostGIS),具体如下：\n![postgis支持版本说明](1968459782.png)\n\n本文使用的是PostGIS版本为3.1.4,Postgresql版本为10.18.2.\n\n###  Postgresql数据库安装及初始化\n安装过程根据提示进行即可，安装完成之后，数据库初始化：\n```\nC:\\Program Files\\PostgreSQL\\10\\bin\\initdb.exe -D C:\\pgdata -E UTF8 --locale=Chinese\n```\n\n数据库启动：\n```\nC:\\Program Files\\PostgreSQL\\10\\bin\\pg_ctl.exe start -w -D C:\\pgdata\n```\n\n###  Postgis安装\n这里最好下载二进制安装包:postgis-bundle-pg10x64-setup-3.1.4-1.exe,根据提示进行安装就就好了，安装过程中会提示创建一个空间数据库postgis_31_sample。\n\n###  pgAdmin创建空间数据库\n创建完数据库添加一个叫postgis的扩展就可以了支持存储空间数据了，如下图:\n![](1165327728.png)\n\n##  QGIS向postgis中导入矢量数据\n首先在右侧的Browser创建Postgis的连接：\n![](586084083.png)\n假定你已经在QGIS中加载了一个shapefile文件。\n点击QGIS工具条的Database->Database Manager,打开下图所示界面：\n![](4294453525.png)\n找到刚刚创建的postgis数据库连接，并选中数据库，然后点击Import Layer即可，根据提示进行操作。\n\n##  geoserver连接postgis并发布图层服务\n1、 添加新的数据源，选择PostGIS,输入数据库连接信息；\n2、 添加图层，设置图层信息发布即可\n\n> 注:geoserver默认用户名和密码:admin/geoserver\n\n##  tomcat控制台中文乱码\nwindows默认编码集GBK,使用startup.bat启动tomcat时，从logging.properties读取到的编码为UTF-8,导致了乱码,将logging.properties中的以下属性调整为GBK即可:\n```\njava.util.logging.ConsoleHandler.encoding = GBK\n```\n\n##  References\n[1、windows下tomcat8控制台出现中文乱码问题](https://blog.csdn.net/super712/article/details/89639583)\n[2、PostGIS安装](https://www.cnblogs.com/gispathfinder/p/9286642.html)\n[3、GeoServer+PostGIS发布图层](https://blog.csdn.net/ljg124034929/article/details/70142420)\n[4、封面图源](https://huadou145.lofter.com/post/205d4db3_1c8bfba2e)","tags":["geoserver","PostgreSQL","PostGIS"],"categories":["GIS"]},{"title":"Skyline BS加载本地影像数据","slug":"Skyline BS加载本地影像数据","url":"/2021/09/30/skyline-bs-jia-zai-ben-di-ying-xiang-shu-ju/","content":"一般情况下，我们会把数据做成Fly文件的形式在skyline平台加载，但有时也会有直接加载影像数据和文本数据的需求，本文主要为影像数据的加载说明。\n<!--more-->\n\n##  应用环境\nQGIS:3.16.6\nSkyline:6.6.1\nOS:windows server 2008 r2\n\n##  加载影像数据\n\n###  CreateImageryLayer方法说明\nskyline bs中有一个CreateImageryLayer方法，支持加载本地的影像数据，参数如下：\n![](2e6f4a34b3edb207e1c4752f6f825e4b.png)\n这里的影像数据只能使用用户本地的，不支持服务器的。\n\n另外对于数据格式也有一定的要求,需要将tif格式的数据转为img格式的。\n\n###  QGIS将tif转为img格式\n输出模式这里选择：Rendered image,否则会是灰度图,配置如下：\n![](1088210689.png)\n然后就可以使用CreateImageryLayer方法在bs中加载了。\n\n##  References\n[1、封面图源](https://huadou145.lofter.com/post/205d4db3_1c81c6e8f)","tags":["GIS","Skyline","三维"],"categories":["GIS"]},{"title":"Echarts折线图之平滑设置及MarkPoint配置","slug":"Echarts折线图之平滑设置及MarkPoint配置","url":"/2021/09/30/echarts-zhe-xian-tu-zhi-ping-hua-she-zhi-ji-markpoint-pei-zhi/","content":"本文主要通过对echarts的几个属性设置，使echarts的折线图展示效果更好。\n<!--more-->\n\n##  环境\nOS: windows server 2008\nEcharts:5.2\n\n##  折线平滑设置\n设置smooth属性为true，如下:\n```\nseries: [\n    {\n      name: 'Lowest',\n      type: 'line',\n      data: [1, -2, 2, 5, 3, 2, 0],\n      smooth:true\n    }\n]\n```\n##  空数据连接\n当数据中有空数据时，折线图可能会断掉，如下:\n![](220754231.png)\n将connectNulls设置为true即可：\n![](418628742.png)\n```\nseries: [\n    {\n      name: 'Lowest',\n      type: 'line',\n      data: [1, -2, 2, 5, 3, 2, 0],\n      smooth:true,\n      connectNulls:true\n    }\n]\n```\n##  添加最大、最小值、平均线\n```\nseries: [\n    {\n      name: 'Highest',\n      type: 'line',\n      data: [10, 11, null, 11, 12, 12, 9],\n      connectNulls:true,\n      markPoint: {\n        data: [\n          { type: 'max', name: 'Max' },\n          { type: 'min', name: 'Min' }\n        ]\n      },\n      markLine: {\n        data: [{ type: 'average', name: 'Avg' }]\n      }\n    },\n```\n\n##  References\n[1、Echarts折线图示例](https://echarts.apache.org/examples/zh/editor.html?c=line-marker)\n[2、封面图源](https://tiezhuzhuzhu923.lofter.com/post/310ff6d7_1c804cbfb)","tags":["Echarts"],"categories":["前端"]},{"title":"解决优麒麟20.04应用更新后移动应用环境无法打开的问题","slug":"110","url":"/2021/09/22/110/","content":"优麒麟每次更新之后移动应用环境都无法打开，可以重新安装头文件包来解决。\n<!--more-->\n\n##  应用环境\nOS:优麒麟20.04\n##  头文件的安装\n\n系统更新时，大概对内核进行了修改，因此需要重新安装头文件包来进行修复，如下：\n```\nsudo apt install linux-headers-`uname -r`\n```\n\n##  Referenced\n[1、优麒麟 20.04 LTS Pro（0620更新版本），麒麟移动应用环境上线](https://www.ubuntukylin.com/ukylin/forum.php?mod=viewthread&tid=194309&highlight=%D2%C6%B6%AF%D3%A6%D3%C3)\n[2、封面图](https://alisonmarket.lofter.com/post/2b1789_1c808c676)","tags":["Linux"],"categories":["Linux"]},{"title":"ArcServer发布数据量很大的服务卡死的解决方案","slug":"109","url":"/2021/08/30/109/","content":"在发布服务到ArcServer中时，由于数据量太大，有10+g，再加上服务器性能不是很好，很容易造成假死的状态。\n<!--more-->\n\n##  应用环境\nOS: win server 2016\nArcGIS:10.2\n\n##  背景\n在发布服务时，发现c盘的空间在不断的变小，这是因为没有将数据源注册到ArcServer服务器，导致每次发布都会把数据拷贝到c盘的一个staging目录，如果数据量比较大，再加上服务器性能不够时，就会出现ArcMap假死的情况。这里通过将数据源注册到ArcServer，避免了数量的拷贝过程，因此发布过程就变得很快了。\n\n##  操作\n在发布时，有Analyse操作，如果提示了Data source is not registerd with the server...,可以双击此项警告以将数据源注册到ArcServer中去，再重新分析、发布就可以了。\n\n##  数据源注册vs不注册\n以下是数据源注册和不注册到ArcServer的区别:\n\n| 项目     | 注册  | 不注册 |\n| :------- | :---|:---|\n| 发布速度 |非常快 | 数据量大时很慢 |\n| 数据同步更新 |是 |否 |\n| 数据浏览速度 |不切图时相对较慢 |相对较快 |\n\n##  Referenced\n[1、ArcGIS Server缓存清理](https://www.cnblogs.com/DayDreamEveryWhere/p/6830545.html)\n[2、ArcGIS10.1如何将数据库注册到ARCSERVER服务器](https://www.cnblogs.com/zmbhfly/p/9548175.html)\n[3、封面图源](https://huadou145.lofter.com/post/205d4db3_1c84a2eba)","tags":["ArcServer","ArcGIS"],"categories":["GIS"]},{"title":"How to Install python or pip offline.","slug":"108","url":"/2021/08/24/108/","content":"This article is about how to install python on linux system and how to install pip package offline.Hope it will help you.\n<!--more-->\n##  Applicaton Enviroment\nOS:centos7.8\npython:3.9\n\n##  Install python\n\n###  Basic Enviorment\nWhen python goes to 3.7 or later,it needs libffi-devel installed in advanced.You can excute command like this:\n```\nyum install libffi-devel\n```\nYou can also install it offline if you couldn't access the internet.Find the rpm package and excute like this:\n```\nrpm -ivh libffi-3.0.5-3.2.AXS4.x86_64.rpm\n```\nMaybe you will meet an error about dependency,then you can add this the end of last command like this:\n```\nrpm -ivh libffi-3.0.5-3.2.AXS4.x86_64.rpm --nodeps --force \n```\n\n> If you don't have gcc installed,you should install it too.You can reference the passage[1]or[6].\n\n###  Start install\n**Unzip your python install package,then excute commands like this:**\n```\n./configure --prefix=/usr/local/python3  \nmake\nmake install\n```\n**Create soft link for python3 and pip3**\n```\nln -s /usr/local/python3/bin/python3 /usr/bin/python3\nln -s /usr/local/python3/bin/pip3 /usr/bin/pip3\n```\n**Add python path to system environment variables.**\nOpen /etc/profile the add the following code to its end line:\n```\nexport PATH=$PATH:/usr/local/python3/bin\n```\n\n##  Install pip package offline\nYou can download pip package on this website:https://pypi.org/.Find the package you want then unzip it.Use the following command to install:\n```\npip3 install tornado-6.1/\n```\n##  Summary\nMaybe you would meet some new problem when you install python or pip offline.Hope you can get new idea from the next charpter's links. Good luck!\n\n\n##  Referenced\n[1、升级Nginx的Openssl版本](https://blog.lightmao.cn/2021/05/07/98/)\n[2、安装rpm包时提示错误：依赖检测失败的解决方法 ](https://www.cnblogs.com/ming-4/p/11700663.html)\n[3、Python安装报错：”ModuleNotFoundError:No module named _ctypes“ 的解决方案 ](https://blog.csdn.net/qq_42353939/article/details/94609591)\n[4、linux下安装python ](https://www.cnblogs.com/guo2733/p/11459144.html)\n[5、linux安装tornado ](https://www.cnblogs.com/zhaoxd07/p/5190560.html)\n[6、No module named 'ctypes'](https://blog.csdn.net/qq_36416904/article/details/79316972)\n[7、Cover](https://huadou145.lofter.com/post/205d4db3_1c7474e60)","tags":["Python"],"categories":["Python"]},{"title":"ArcGIS DEM高程放大","slug":"106","url":"/2021/08/12/106/","content":"在对DEM数据进行可视化的时候，如果我们的地形起伏较小，那为了有更好的显示效果，我们通过会对地形起伏放大处理。\n\n<!--more-->\n\n##  基本环境\n软件：win10+ArcMap10.6\n数据：某区域DEM数据\n\n##  操作步骤\n\n把DEM中的像素点的值进行放大处理处理，这里统一乘以x倍：\n\n在ArcMap中，找到SpatialAnalystTools->Math->Times,然后输入栅格及放大的倍数即可。\n\n##  Referenced\n[1、封面图](https://melare.lofter.com/post/1f010e23_1c71032c6)","tags":["ArcGIS","DEM"],"categories":["GIS"]},{"title":"html+vue+elmentui实现组件动态切换","slug":"105","url":"/2021/06/25/105/","content":"最近要为运行在ie8上的老系统整理一个配置管理的界面，主要是对系统配置进行修改，前端使用的是html+vue，服务端采用的是asp.net。\n<!--more-->\n##  应用环境\nOS:win10\n开发环境：.net framework 4.0\n##  技术选型\n不能打包，需要选择能够直接修改更新的方案，因此前端只能使用html,后端考虑到现有的环境就是windows，因此直接使用asp.net website开发，实现快速更新。\n\n##  创建vue组件\n这里创建一个组件，config.vue\n```\n<template>\n...\n</template>\n<script>\nmodule.exports= {\n  name: \"ConfigPanel\",\n  data: function () {\n  }\n  ...\n}\n```\n##  引入组件\n这里使用httpVueLoader在html中加载组件，先导入httpVueLoader:\n```\n<script type=\"text/javaScript\" src=\"./http-vue-loader.js\"></script>\n```\n引入组件：\n```\ncomponents: {\n            'config':httpVueLoader('./components/config.vue')\n}\n```\n使用组件\n```\n<config></config>\n```\n##  动态切换组件\n使用component，动态修改comName的值即可，如下：\n```\n<componet :is=\"comName\"></componet>\n```\n在结合element-ui中的导航菜单，就可以实现一个简单的配置管理界面啦。\n##  Referenced\n[1、http-vue-loader](https://www.npmjs.com/package/http-vue-loader)\n[2、Vue--动态组件实现组件切换](https://www.cnblogs.com/kinoko-1009/p/10589371.html)\n[3、封面图源](https://huadou145.lofter.com/post/205d4db3_1c8a36320)","tags":["ASP.NET","VUE"],"categories":["前端"]},{"title":"使用webpack对代码压缩混淆","slug":"103","url":"/2021/06/02/103/","content":"本文对webpack的基本使用作简单的介绍，从js、css的打包，到代码的混淆，希望对初步学习webpack的你有帮助。\n<!--more-->\n##  软件版本\nwebpack 5.38.1\nwebpack-cli 4.7.0\nnode:v14.17.0\n\n##  webpack的安装\n```\nnpm install webpack webpack-cli -g\n```\n\n##  对单个js文件进行压缩\n创建一个test.js文件，添加如下内容:\n```\ndocument.write('It works from runoob2.js');\n```\n创建一个index.html,内容如下:\n```\n\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title>Hello world</title>\n        <script src=\"./dist/main.js\"></script>\n    </head>\n    <body>\n    </body>\n</html>\n```\n使用webpack对test.js进行压缩: \n```\nwebpack ./test.js --mode producation\n```\n打开index.html文件，查看test.js文件压缩后，里面的内容是否被成功调用。\n\n##  对多个js文件进行压缩\n同样的，我们创建test2.js,内容如下:\n```\nmodule.exports = \"It works from runoob2.js.\";\n```\n并将test.js中的内容修改为如下：\n```\ndocument.write(require(\"./test2.js\"));\n```\n打包\n```\nwebpack ./test.js ./test2.js --mode porducation\n```\n再次访问index.html，查看是否正常\n\n##  调用js中的函数\n接下来，我们创建test3.js，里面添加一个函数，然后在index.html中调用.\ntest3.js内容如下:\n```\nwindow.clearSgline = function  () {\n    console.log(\"test function \")\n}\n```\n> 提示：如果不这么写，index.html中调用不到，可参考文末链接\n\n在index.html中调用函数clearSgline,如下：\n```\n<body>\n    window.onload=function(){\n        clearSgline();\n    }\n</body>\n```\n\n修改test.js文件，引入test3.js,如下:\n```\nrequire('./test3.js');\n```\n打包:\n```\nwebpack ./test.js ./test2.js ./test3.js\n```\n在浏览器中查看index.html,观察函数是否被成功调用\n\n##  webpack打包css文件\nWebpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。\n\n安装css-loader和style-loader\n```\nnpm install css-loader style-loader --save-dev\n```\n首先创建一个样式文件style.css，如下：\n```\nbody{\n    background:yellowgreen;\n}\n```\n修改test.js文件，添加如下内容:\n```\nrequire(\"!style-loader!css-loader!./style.css\");\n```\nrequire CSS 文件的时候都要写 loader 前缀 !style-loader!css-loader!，当然我们可以根据模块类型（扩展名）来自动绑定需要的 loader\n> 到这里，其实可以发现test.js好似所有js和css的入口\n\n打包,\n```\nwebpack ./test.js ./test2.js ./test3.js  --mode development\n```\n或者，在打包时指定需要的loader，修改test.js中style.css的引用，如下：\n\n```\nrequire(\"./style.css\");\n```\n在打包时，加入对应的loader\n```\nwebpack ./test.js ./test2.js ./test3.js  --mode development --module-bind 'css=style-loader!css-loader'\n```\n\n##  webpack配置文件的使用\n创建一个webpack.config.js,打包时就会直接使用它了，webpack.config.js内容如下：\n```\nconst path =require('path');\nmodule.exports = {\n    entry: \"./test.js\",\n    mode: 'production',\n    output: {\n        path: path.join(__dirname,'dist'),\n        filename: \"bundle.js\"\n    },\n    module: {\n        rules: [\n            { \n                test: /\\.css$/,\n                use: ['style-loader','css-loader'] ,\n            }\n        ]\n    }\n};\n```\n打包时使用以下命令即可：\n```\nwebpack \n```\n##  webpack代码混淆\n如果不想让其它人轻易的看到自己的代码，可以通过web-obfuscator插件对代码进行混淆。\n安装：\n```\nnpm install --save-dev javascript-obfuscator webpack-obfuscator\n```\n修改webpack.config.js,如下：\n```\nvar WebpackObfuscator = require('webpack-obfuscator');\n\n// ...\n\n// webpack plugins array\nplugins: [\n    new WebpackObfuscator ({\n        rotateStringArray: true\n    }, ['excluded_bundle_name.js'])\n]\n```\n> 其中数组中的excluded_bundle_name.js为需要排除的文件\n如果觉得混淆到此种程度还不够，那还可以添加更多的参数,具体有那些参数，在你安装完javascript-obfuscator之后，可以在其README.md文件中找到，或者参考文末提供的文章链接。\n\n##  Reference\n[1、Webpack 入门教程](https://www.runoob.com/w3cnote/webpack-tutorial.html)\n[2、webpack 打包后如何调用JS自定义函数？](https://segmentfault.com/q/1010000012739169/a-1020000012739755)\n[3、webpack.config.js配置](webpack安装css-loader,style-loader心得)\n[4、vue项目配置 webpack-obfuscator 进行代码加密混淆](https://www.cnblogs.com/dragonir/archive/2021/02/25/14445767.html)\n[5、webpack代码混淆](https://www.npmjs.com/package/webpack-obfuscator)\n[6、 封面图源](https://huadou145.lofter.com/post/205d4db3_1c71e6ba8)","tags":["NodeJS","webpack"],"categories":["前端"]},{"title":"Android ImageView加载gif图片","slug":"102","url":"/2021/05/28/102/","content":"默认情况下，ImageView中gif图片不能播放，通过glide来实现ImageView展示gif图片。\n<!--more-->\n##  应用环境\nOS：优麒麟20.04\nAndroid Studio:4.2.1\n\n##  添加glide包\n在build.gradle中添加glide,版本可从maven中查询：\n```\nimplementation group: 'com.github.bumptech.glide', name: 'glide', version: '4.12.0'\n```\n##  ImageView中加载图片\n```\nImageView view= (ImageView) findViewById(R.id.welcome_gif);\nGlide.with(this).load(R.drawable.loading).into(view);\n```\n这样，就能在ImageView中正常显示gif了。\n\n##  Referenced\n[1.Android studio 使用 ImageView 加载 gif 文件](https://www.cnblogs.com/lyw-hunnu/p/12151807.html) \n[2、封面图源](https://lyla7784.lofter.com/post/30a15a3d_1c8923399)","tags":["Android","Gif"],"categories":["移动端"]},{"title":"Linux为Android Studio创建快捷方式","slug":"101","url":"/2021/05/26/101/","content":"Linux下安装完AndroidStudio后没有自动创建桌面快捷方式，本文为AndroidSt udio创建桌面快捷方式的过程作简单记录。\n\n<!--more-->\n##  操作环境\nOS: 优麒麟20.04\nAndroidStudio:4.2.1\n\n##  创建desktop文件\n\n创建文件\n```\nsudo touch 添加如下内容：/usr/share/applications/android_studio.desktop\n```\n添加如下内容：\n```\n[Desktop Entry]\nType=Application\nName=Android Studio\nExec=\"/opt/android-studio/bin/studio.sh\" %f\nIcon=/opt/android-studio/bin/studio.png\nCategories=development;IDE;\nTerminal=false\nStartupNotify=true\nStartupWMClass=jetbrains-android-studio\n```\n> 其中/opt/android-studio 替换为你自己的android studio安装路径\n\n##  增加可执行权限\n```\nchmod +X /usr/share/applications/android_studio.desktop\n```\n创建文件的快捷方式到桌面即可。\n\n##  Referenced\n[1、ubuntu中在Launcher上添加Android Studio的运行图标](https://www.cnblogs.com/lanma/p/5079702.html)\n[2、封面来源](https://huadou145.lofter.com/post/205d4db3_1c7247e32)\n","tags":["Android"],"categories":["移动端"]},{"title":"Nexus管理员密码重置","slug":"100","url":"/2021/05/21/100/","content":"Nexus是一个强大的包管理管理，可以用它来搭建自己的maven、npm、nuget等私服。本文主要记录对Nexus管理员密码进行重置的过程。\n<!--more-->\n##  环境\nOS:Ubuntu 16.04\nNexus:3.25.0-03\n\n##  密码重置\n找到 sonatype-work/nexus3/db/security/user.pcl文件\n```\nfind / -name user.pcl\n```\n找到文件的如下地方：\n```\nadmin^ZAdministrator^HUser^Lactive&tianya@zifangdt.com<8c>^B$shiro1$SHA-512$1024$\n\nNE+wqQq/TmjZMvfI7ENh/g==$V4yPw8T64UQ6GfJfxYq2hLsVrBY8D1v+bktfOxGdt4b/9BthpWPNUy/CBk6V9iA0nHpzYzJFWO8v/tZFtES8CA==\n\n^Aÿÿÿÿÿÿÿÿÿþÿÿ\n```\n把$和^之间的内容替换^Aÿÿÿÿÿÿÿÿÿþ成上面第二行的内容，修改后的密码为amdin123,用户名admin\n> Tips:需要重启nexus\n\n##  密码重置之后引起的数据库只读\n重置完密码之后，再次修改密码发现出现了以下问题：\n```\n['user.pcl' :1;], storage is switched to 'read only' mode\n```\nuser所在的security数据库变成了只读,此时需要把此数据库删除再新建，具体过程如下：\n###  备份数据库\n```\n./nexus stop\ncp -r /opt/nexus/sonatype-work/nexus3/db/security /opt/nexus/\n```\n###  数据库删除及恢复\n到Nexus安装目录下/lib/support下，运行nexus-orient-console.jar\n```\njava -jar nexus-orient-console.jar\n```\n然后连接出错的数据库\n```\norientdb> connect PLOCAL:/opt/nexus/sonatype-work/nexus3/db/security admin admin\n\n# 导出\norientdb {db=security}> EXPORT DATABASE /opt/backup\n\n# 关闭连接\norientdb {db=security}> DISCONNECT\n\n# 删除出问题的库\norientdb> DROP DATABASE PLOCAL:/opt/nexus/sonatype-work/nexus3/db/security admin admin\n\n# 重新创建出问题的库\norientdb> CREATE DATABASE PLOCAL:/opt/nexus/sonatype-work/nexus3/db/security admin admin\n\n# 导入\norientdb {db=security}> IMPORT DATABASE /backup/backup.json.gz\n\n# 关闭连接\norientdb {db=security}> DISCONNECT\n\n# 退出控制台\norientdb> EXIT\n```\n重启nexus即可：\n```\nnohup ./nexus run >nexus.out 2>&1 &\nor\n./nexus start\n```\n\n##  Referenced\n[1、nexus3.2重置admin密码](https://blog.51cto.com/ywliyq/2451936)\n[2、Nexus搭建Maven私服](https://blog.lightmao.cn/2020/07/24/67/)\n[3、Nexus因异常重启导致OrientDB数据库变为只读的问题修复](https://blog.csdn.net/mutian6655/article/details/112758278)\n[4、封面图源](https://huadou145.lofter.com/post/205d4db3_1c81c6e8f)","tags":["Nexus","私服"],"categories":["运维"]},{"title":"Vue组件的基本使用","slug":"99","url":"/2021/05/21/99/","content":"最近看代码时发现根据名称找不到组件的定义位置，因此就找了下vue组件的命名规范，大致就是组件声明及在脚本中按Pascal命名，在dom中按照kebab-case的方式引入即可。\n<!--more-->\n##  组件的命名\n组件名称一般使用PascalCase命名方法，即每个单词的首字母大写，如下:Sm3dMeasure,在script中使用的时候，均按照这个命名来写。\n\n但在template节点下引用的时候，则使用kebab-case，即每个单词之间用-来连接。如下：\n```\n<template>\n    <sm3d-measure></sm3d-measure>\n</tempalte>\n\nimport Sm3dMeasure from '@/componets/Measure/Sm3dMeasure'\n...\n```\n> 关于命名更详细的说明可参考[Vue.js风格指南](https://cn.vuejs.org/v2/style-guide/# %E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E5%90%8D%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90)\n\n##  组件的使用\n###  组件的导入\n```\nimport Sm3dMeasure from '@/components/Measure/Sm2dMeasure.vue'\n```\n> 其中@ 符号代表的是src目录,也可以使用./表示同级目录,../表示上级目录\n> 这里的Sm3dMeasure可以看做是组件Sm2dMeasure的名字,可以和Sm2dMeasure.vue中定义的name属性不一致;\n\n###  使用组件\n```\ncomponets:{\n    Sm3dMeasure\n}\n```\n###  在template下引入\n\n```\n<sm3d-measure></sm3d-measure>\n```\n> 注意此处使用kebab-case命名法\n\n##  Reference\n[1、vue---组件引入及使用的几种方式](https://www.cnblogs.com/e0yu/p/10795176.html)\n[2. 封面图](https://huadou145.lofter.com/post/205d4db3_1c8bfba2e)","tags":["VUE"],"categories":["前端"]},{"title":"升级Nginx的Openssl版本","slug":"98","url":"/2021/05/07/98/","content":"叮咚，你家的系统又有漏洞了，这次是openssl相关的漏洞：CVE-2016-8610，本次记录漏洞修复过程，主要为升级opnessl至最新版。\n\n<!--more-->\n##  应用配置\nNginx:1.18.0\nOpenssl:1.1.1k\nOS:Asianux SP4\n\n##  升级Openssl版本\n###  g++的安装\n从源码编译Openssl需要g++,因此可以先看系统有没有安装g++:\n```\ng++ -v\n```\n如果没有安装，需要安装g++,安装g++涉及到的库大概有10+，因此要有一定的耐心,可参考：\n```\nrpm -ivh kernel-headers-2.6.32-431.20.3.el6.x86_64.rpm\nrpm -ivh glibc-headers-2.12-1.132.AXS4.2.x86_64.rpm\nrpm -ivh glibc-devel-2.12-1.132.AXS4.2.x86_64.rpm\nrpm -ivh mpfr-2.4.1-6.AXS4.x86_64.rpm\nrpm -ivh ppl-0.10.2-11.AXS4.x86_64.rpm\nrpm -ivh cloog-ppl-0.15.7-1.2.AXS4.x86_64.rpm\nrpm -ivh cpp-4.4.7-4.AXS4.x86_64.rpm\nrpm -ivh libgomp-4.4.7-4.AXS4.x86_64.rpm\nrpm -ivh gcc-4.4.7-4.AXS4.x86_64.rpm\nrpm -ivh libstdc++-devel-4.4.7-4.AXS4.x86_64.rpm\nrpm -ivh libstdc++-4.4.7-4.AXS4.x86_64.rpm\nrpm -ivh gcc-c++-4.4.7-4.AXS4.x86_64.rpm\n```\n查看gcc版本：\n```\ngcc -v\n```\n###  openssl的升级\n下载openssl的[最新版本](https://www.openssl.org/source/)，这里下载的是1.1.1k\n解压及进入目录:\n```\ntar -zxvf openssl-1.1.1k.tar.gz\ncd openssl-1.1.1k\n```\n配置、编译、安装：\n```\n./config --prefix=/usr/local/openssl --openssldir=/usr/local/openssl no-ssl2\nmake\nmake install\n```\n修改环境变量\n```\nvi /etc/profile\n```\n末尾添加如下内容:\n```\nexport PATH=/usr/local/openssl/bin:$PATH\nexport LD_LIBRARY_PATH=/usr/local/openssl/lib\nexport LC_ALL=\"en_US.UTF-8\"\nexport LDFLAGS=\"-L/usr/local/openssl/lib -Wl,-rpath,/usr/local/openssl/lib\"\n```\n保存并使环境变量刷新\n```\nsource /etc/profile\n```\n检查openssl版本\n```\nopenssl version\n```\n\n##  重新安装Nginx\n> 需要先停止在运行的Nginx\n\n查看已安装Nginx的配置：\n```\nnginx -V\n```\n配置:\n```\n./configure --without-http_rewrite_module --with-http_ssl_module --with-openssl=/home/user/soft/openssl-1.1.1k\n```\n其中with-openssl的参数值为openssl的源码地址\n编译及安装:\n```\nmake&make install\n```\n此时再执行以下命令即可看到Nginx使用的Openssl版本\n```\nnginx -V\n```\n##  Referenced\n[1、编译和安装openssl](https://www.cnblogs.com/music-liang/p/11888672.html)\n[2、nginx升级并且使用最新版本openssl](https://www.cnblogs.com/levcon/p/13409531.html)\n[3、封面图](https://alisonmarket.lofter.com/post/2b1789_1c808c676)\n","tags":["Nginx","安全","Openssl"],"categories":["应用安全"]},{"title":"消息队列之RabbitMQ的基本使用-基于Python","slug":"97","url":"/2021/04/30/97/","content":"本文主要对RabbitMQ的几个概念以及基本使用作小结。\n\n<!--more-->\n\n##  应用环境\nOS:ubuntu+centos\nPika:1.2.0\npython:3.7\n\n##  RabbitMQ的安装及配置\n###  centos8安装rabbitmq\n\n```\nrpm -ivh erlang-23.1.4-1.el8.x86_64.rpm\nrpm -ivh socat-1.7.3.3-2.el8.x86_64.rpm\nrpm -ivh rabbitmq-server-3.8.9-1.el8.noarch.rpm\n```\n###  rabbitmq的启动\n\n```\n# 开机启动\nchkconfig rabbitmq-server on\n/sbin/service rabbitmq-server start\n/sbin/service rabbitmq-server stop\nrabbitmq-plugins enable rabbitmq_management\n```\n放开15672端口：\n```\nfirewall-cmd --zone=public --add-port=15672/tcp --permanent\nfirewall-cmd --reload\n```\n\n这样就可以通过http://xx:15672来访问rabbitmq的管理界面了，默认用户名和密码：guest/guest，默认只能本地登录。\n\n###  添加用户并设置远程登录\n\n```\nrabbitmqctl add_user test test123\nrabbitmqctl set_user_tags test administrator\n```\n\n##  RabbitMQ的几个基本概念\n\n生产者：发送消息\n消费者：接收消息\n队列：类似一个临时存储空间，存储消息的\nExchange:类似快递员，生产者都会把消息发送它，再由它发送到某个队列\n\n##  RabbitMQ的几种消息模型\n简单来说，就2类，一类是1条消息只能发送给1个人的，另一类是同一条消息会发送给多个人的订阅模型。\n**one-to-one:**\n> 通常情况下，为了加快业务的处理速度，我们会用多个消费者来处理队列中的消息,这种就可以完全避免信息的重复处理\n\n**one-to-many:**\n> 这种我们称之为订阅模型，又包含多种类型，我们根据exchange_type进行区分\n其对应的exchange_type有：fanout、direct、topic，这几个类型的区别在于消息过滤的灵活性。\n其中：\nfanout无法过滤消息，消费者只能拿到绑定的exchange的全部消息；\ndirect：可以根据关键字过滤，如日志的响应级别info、warn、error,只能拿其中一类或几类\ntopic:最为灵活，有*和# 两个特殊字符，前者匹配一个单词，后者匹配所有，即只要符合这个规则的消息都可以拿来。\n\n另外需要注意的是订阅模型中，拿不到历史消息，只能拿到实时消息。\n\n##  RabbitMQ的使用\n\n###  临时队列\n\n```\nresult = channel.queue_declare(queue='', exclusive=True)\nqueue_name = result.method.queue\n```\n这里，exclusive为关闭连接之后就删除此队列\n\n###  消息持久化\n```\nchannel.queue_declare(queue='hello', durable=True)\n```\n除此之外，在发布消息的时候，还需设置delivery_mode=2\n```\nchannel.basic_publish(exchange='',\n                      routing_key=self.queue,\n                      body=msg,\n                      properties=pika.BasicProperties(\n                         delivery_mode = 2, # make message persistent\n                      ))\n```                     \n这样如果rabbitmq服务出现问题，重启后消息还会恢复,此种模式不适用于订阅模式。\n\n###  basic_qos\n通过设置prefech_count属性可以设置一次性从队列中拿到的消息个数。\nThe client can request that messages be sent in advance so that when the client finishes processing a message, the following message is already held locally, rather than needing to be sent down the channel. Prefetching gives a performance improvement.\n\n###  应答确认机制\n默认情况下，auto\\_ack属性为true，即自动回复确认消息，如果需要自定义回复时机，需要将auto\\_ack的属性为false,然后在on\\_message_callback中添加如下内容以回复确认：\n```\nch.basic_ack(delivery_tag = method.delivery_tag)\n```\n\n###  路由模式(routing)之绑定多个类型的消息\n\n一个队列可以同时绑定多个类别的消息\n```\nchannel.queue_bind(exchange=self.exchange_name, queue=queue_name,routing_key='info')\n\nchannel.queue_bind(exchange=self.exchange_name, queue=queue_name,routing_key='error')\n```\n\n###  路由模式之Topic模式\n\n为了解决路由模式不够灵活的问题，提出了Topic模式,类似于标签，用句号隔开，如：baidu.com,google.com等\n这里有２个特殊的字符：\n\n> * (star) can substitute for exactly one word.\n> \\# (hash) can substitute for zero or more words.\n\n其中\\# 匹配所有，*代表一个单词\n\n##  python中使用rabbitmq\n\n###   pip安装pika\n\n下载pika包离线安装\n```\npip3 install pika-1.1.0/\n```\n或在线安装：\n```\npip install pika==1.2.0\n```\n> pip安裝指定版本的包\n==,>=,<=,>,<\n\n##  Reference\n[1、centos8安装RabbitMQ](https://www.cnblogs.com/baiyifengyun/p/12446494.html)\n[2、RabbitMQ添加新用户并支持远程访问](https://www.cnblogs.com/gongshun/p/10694659.html)\n[3、RabbitMQ使用详解](https://www.cnblogs.com/ithushuai/p/12443460.html)\n[4、封面图源](https://lyla7784.lofter.com/post/30a15a3d_1c8923399)","tags":["消息队列","RabbitMQ"],"categories":["Python"]},{"title":"Nginx結合http-flv模塊搭建視頻推流服務","slug":"96","url":"/2021/04/27/96/","content":"明明之前在centos上使用Nginx搭建視頻推流服務很順利，結果在Ubuntu上差點翻車，於是把遇到的問題簡單記錄一下。\n\n<!--more-->\n\n##  應用環境\nOS:Ubuntu 18.04\nNginx:1.20.0\nhttp-flv:1.2.9\n\n##  Nginx配置\n```\n./configure --add-module=nginx-http-flv-module-1.2.9\n```\n可能會提示缺少zlib、pcre、openssl：\n對於zlib，這裏直接在其官網上下載zlib-1.2.11.tar.gz進行安裝\n```\n./configure\nmake\nmake install\n```\n至於openssl,可通過以下命令安裝:\n```\napt install openssl\napt install libssl-dev\n```\n\n由於視頻推流不需要依賴pcre模塊的http-rewrite模塊，因此:\n```\n./configure --add-module=nginx-http-flv-module-1.2.9 --without-http_rewrite_module\n```\n\n> 這裏也附上centos下這幾個包的安裝：\nyum install zlib zlib-devel\nyum install pcre pcre-devel\nyum install openssl openssl-devel \n\n##  Nginx安裝\n執行以下命令進行安裝：\n```\nmake\nmake install\n```\n這樣Nginx1.20就被安裝在了/usr/local/nginx下，如果之前有安裝舊版本的Nginx，且Nginx是通過apt進行安裝的，需要把/usr/sbin下面的nginx刪掉或改爲其它名字，然後修改環境變量：\nvi /etc/profile\n添加如下內容：\n```\nexport PATH=$PATH:/usr/local/nginx/sbin\n```\n執行以下命令更新：\n```\nsource /etc/profile\n```\n此時可以通過nginx -v查看Nginx是否生效。\n\n##  配置rtmp\n在http-flv模塊的[github](https://github.com/winshining/nginx-http-flv-module)上，有關於rtmp的詳細配置，可以直接參考。\n\n> 另：如果你不想這麼麻煩，那麼也可以使用[Monibuca](https://monibuca.com/)來部署視頻流服務器。\n\n##  Referenced\n[1、封面图源](https://tiezhuzhuzhu923.lofter.com/post/310ff6d7_1c804cbfb)","tags":["Nginx","RTMP","推流"],"categories":["运维"]},{"title":"JavaScript正则表达式的使用","slug":"95","url":"/2021/04/22/95/","content":"使用Javascript中的正则大表达式对行政区划代码进行判断，确定是省级还是市级行政区划。\n<!--more-->\n\n##  正则表达式的语法\n\n###  常用的元字符\n| 代码     | 说明  | 反义代码|\n| :------- | :---|:---:|\n| [0-9] | 匹配0~9中的任一数字   |/|\n| [A-Z]    | 匹配A~Z中的任一字母  | /|\n|.|匹配除换行符以外的任意字符，可以匹配中文字符|/|\n|\\w|字母、数字、下划线，相当于[A-Za-z0-9\\_] |\\W|\n|\\d|数字|\\D|\n|\\s|匹配任意的空白符，包括空格、制表符、换页符等 |\\S|\n|^|字符串的开始|/|\n|$|字符串的结束|/|\n\n###  常用的限定符\n| 代码     | 说明  |\n| :------- | :---|\n| * | 重复0次或多次   |\n|+  | 1次或多次  |\n|?  | 0次或一次|\n|{n}| n次 |\n|{n,}|重复n次或更多次|\n|{n,m}|重复n次或m次|\n|()|分组|\n>  **提示：** |  表示或\n\n##  Javascript中正则表达式的使用\n在 JavaScript 中，RegExp 对象是一个预定义了属性和方法的正则表达式对象。\n###  test()\n用于检查字符串中是否含有符合给定正则的对象，返回结果为true or false。\n如下这里是判断行政区划代码是省或市\n```\nvar patt1=new RegExp(\"0000\");\ndocument.write(patt1.test(\"441000\")); //false\nvar patt2=new RegExp(\"[0-9]{2}((0[1-9])|[1-9][0-9])00\");\ndocument.write(patt2.test(\"210100\")); //true\n```\n\n###  exec()\n获取正则匹配结果，返回结果为数组类型，没有匹配范围null。\n```\nvar patt1=new RegExp(\"0000\");\ndocument.write(patt1.exec(\"441000\")+\"<br/>\"); //false\n\t\nvar patt2=new RegExp(\"[0-9]{2}((0[1-9])|[1-9][0-9])00\");\ndocument.write(patt2.exec(\"210100\")); //true\n\nvar patt2=new RegExp(\"[0-9]{2}((0[1-9])|[1-9][0-9])00\");\ndocument.write(patt2.exec(\"211000\")); //true\n\n```\n输出结果为：\n```\nnull\n210100,01,01\n210100,10\n```\n> 其中正则表达式里面的（）标记一个子表达式的开始和结束位置，如果匹配到（）里面的内容，都会作为匹配结果中的一个对象。可以好好体会210100和211000这两个不同的输出结果。\n\n##  Referenced\n[1、正则表达式 - 语法](https://www.runoob.com/regexp/regexp-syntax.html)\n[2、JavaScript 正则表达式](https://www.runoob.com/js/js-regexp.html)\n[3、封面图源](https://huadou145.lofter.com/post/205d4db3_1c8bfba2e)\n","tags":["JavaScript","正则表达式"],"categories":["前端"]},{"title":"Oracle设置密码永不过期","slug":"94","url":"/2021/04/21/94/","content":"Oracle数据库的密码默认半年有效，过了时间再重启数据库可能就会连不上数据，为了方便使用故调整为密码永不过期。\n<!--more-->\n##  应用环境\nOracle:11g r2\nOS:win server 2016\n\n##  设置密码永不过期\n1、查看用户的proifle是哪个，一般是default：\n```\nSELECT username,PROFILE FROM dba_users;\n```\n2、查看指定概要文件（如default）的密码有效期设置：\n```\nSELECT * FROM dba_profiles s WHERE s.profile='DEFAULT' AND resource_name='PASSWORD_LIFE_TIME';\n```\n3、将密码有效期由默认的180天修改成“无限制”：\n```\nALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;\n```\n>**注意：**此操作无需重启数据库;\n> 如果用户密码已经过期，那么还需要重新设置一次密码，\n\n##  解锁用户之后用户又被锁\n\n这个情况发生下修改用户密码之后，这是因为此时有连接使用了旧的密码，而用户在登陆失败次数超过一定数目时会被锁定，因此如果出现解锁用户之后很快用户又被锁定，可以检查下有没有应用在一直使用了旧的密码连接数据库。\n\n##  Referenced\n[1、修改oracle用户密码永不过期](https://www.cnblogs.com/kingwei55555/p/12127854.html)\n[2、Oracle 用户解锁之后总被锁住](https://jingyan.baidu.com/article/046a7b3ec43042f9c27fa937.html)\n[3、封面图源](https://huadou145.lofter.com/post/205d4db3_1c8f12e12)","tags":["安全","数据库","Oracle"],"categories":["数据库"]},{"title":"Jenkins自动打包NodeJS项目","slug":"93","url":"/2021/04/20/93/","content":"随着越来越多的前后端分离项目的落地，对于前端项目的自动化部署能力也随之而来。本文通过Jenkins+Git实现了前端项目的自动构建。\n<!--more-->\n##  应用环境\nCentos:7\nJenkins:容器安装\nNode:14.16\n\n##  在Jenkins容器中安装NodeJS\n直接下载最新的NodeJS安装包，然后将其复制到jenkins容器中或主机中映射到jenkins容器中的那个目录。\n解压nodejs(这里下载到的node为xz格式的)\n```\nxz -d node-v14.16.1-linux-x64.tar.xz\ntar -xvf node-v14.16.1-linux-x64.tar\n```\n配置NodeJS环境变量\n```\nexport NODE_HOME=/xxx/node-v14.16.1-linux-x64\nexport PATH=$PATH:$NODE_HOME/bin\nexport NODE_PATH=$NODE_HOME/lib/node_modules\n```\n**Tips**：root账户登录jenkins容器：\n```\ndocker exec -ti -u root ContainerId /bin/bash\n```\n然后确认以下命令能够正确输出node和npm的版本\n```\nnode -v\nnpm -v\n```\n##  Jenkins Job配置\n###  Jenkins配置NodeJS\n登录你的Jenkins,管理Jenkins->Global Tool Configuration中,配置NodeJS的目录。\n\n###  创建Job\n创建一个Freestyle Project，然后输入对应的参数，在构建环境那里勾选Provide Node&npm 设置一个NodeJS的配置名称。\n构建步骤：新增执行shell，命令如下：\n```\nnpm install\nnpm run build\n```\n###  测试\n保存之后，可以立即构建测试一下\n\n##  在Git中配置自动部署\n添加web钩子，地址如下：\n```\nhttp://jenkins-location/gogs-webhook/?job=jobname\n```\n然后测试一下，应该就可以每次合并代码的时候就会自动打包项目了。\n\n##  Referenced\n[1、Jenkins+Gogs搭建自动化部署平台](https://www.jianshu.com/p/14e356cf8bb4)\n[2、jenkins学习之自动打包构建nodejs应用](https://www.cnblogs.com/vipzhou/p/7890016.html)\n[3、封面图](https://melare.lofter.com/post/1f010e23_1c71032c6)","tags":["Jenkins","Docker","NodeJS"],"categories":["运维"]},{"title":"Npm全局安装VS本地安装、生产依赖VS开发依赖等概念","slug":"92","url":"/2021/04/20/92/","content":"nodejs、npm、vue等概念已经出现了很久，之前只是简单的使用，对其中的一些概念感觉有些模糊，本文就几个似识非识的概念一一明确。\n<!--more-->\n\n##  Npm是什么\nNpm是一个Javascript包管理工具,通过它我们可以下载项目所需要的各种Javascript类库，而无需互相拷贝，当然yarn也可以帮我们做这些事情。\n\n##  全局安装与本地安装\n全局安装：\n```\nnpm install package_name -g\n```\n当我们直接在terminal中使用包的命令时，需要全局安装，如vue-cli、docsify等工具，对于Jquery、element-ui等，我们只需要在当前项目中使用，那这种就不需要全局安装，此时在项目所在目录下执行以下命令即可：\n```\nnpm install element-ui --save\n```\n\n##  生产依赖与开发依赖\n\n生产依赖即生产环境中所用到的依赖；开发依赖即开发环境中用到的依赖。因此究竟是安装为开发依赖还是生产依赖就是判断这个包我们在生产环境中是否用到。\n###  安装生产依赖：\n```\nnpm install element-ui --save\nor\nnpm i element-ui -S\n```\n此后在package.json中的dependencies节点中就可以看到这个包。\n###  安装开发依赖：\n```\nnpm install gulp-htmlmin --save-dev\nor\nnpm i gulp-htmlmin -D\n```\n假如我们用gulp对html进行压缩，我们通常会用到一个插件gulp-htmlmin。我们只希望它把html压缩完就ok了，并不希望它融入我们的项目代码中，即只存在于开发环境，因此把他归类为\"开发依赖\"，此后在package.json中的devependencies节点中就会看到这个包。\n\n##  package.json与package-lock.json\npackage.json文件记录的是安装的软件的大版本，即每次npm install的时候都会根据这个文件里面的大版本去安装最新的版本。\n而package-lock.json则锁定小版本，因此如果想要保证团队所有人用的软件的版本一致，就需要将package-lock.json分发给所有人。\n\n额外的：npm安装指定版本的软件包命令：\n```\nnpm i element-ui@x.x.x --save\n```\n\n##  Referenced\n[1、npm(你怕吗) 全局安装与本地安装、开发依赖和生产依赖](https://www.cnblogs.com/wjlbk/p/12633404.html)\n[2、npm安装时-S -D作用及区别](https://www.cnblogs.com/web-record/p/10904907.html)\n[3、package.json和package-lock.json的区别](https://www.cnblogs.com/tangjiao/p/9603677.html)\n[4、封面图](https://alisonmarket.lofter.com/post/2b1789_1c7361bf1# )\n","tags":["NodeJS","VUE","NPM"],"categories":["前端"]},{"title":"Python矩阵和字符串的互相转换","slug":"91","url":"/2021/04/20/91/","content":"为了保存图像的特征数据，需要将特征矩阵进行保存及还原。\n<!--more-->\n##  环境\nOS：ubuntu18.04\nPython:3.7\n\n##  矩阵转字符串\n```\ndef matrix_to_str(mat):\n    return mat.tostring()\n```\n##  tuple转字符串\n矩阵的shape的数据类型为tuple，因此需要将其转为字符串\n```\ndef tuple_to_str(shape):\n    return shape.__str__()\n```\n\n##  字符串转tuple\n```\ndef str_to_tuple(str):\n    return tuple(eval(str))\n```\n##  字符串转矩阵\n```\ndef str_to_matrix(str,shape):\n    return np.frombuffer(str,dtype=np.float32).reshape(shape)\n```\n\n##  Referenced\n[1、Python字符串、元组、列表、字典互相转换的方法](https://www.jb51.net/article/78541.htm)\n[2、封面图](https://huadou145.lofter.com/post/205d4db3_1c7474e60)","tags":["Python","Numpy"],"categories":["Python"]},{"title":"CentOS7安装MariaDB","slug":"90","url":"/2021/04/20/90/","content":"\n最近在做数据迁移，顺便把mysql替换为mariadb.\n<!--more-->\n##  环境\nOS:centos 7.8\nMariadb：10.5.9~11.x\n\n**提示**:关于mariadb的安装，网上有太多乱七八糟的教程了，最好的办法还是参考mariadb官网文档。\n\n##  软件下载\n```\nwget https://mirrors.cloud.tencent.com/mariadb/mariadb-10.5.9/bintar-linux-systemd-x86_64/mariadb-10.5.9-linux-systemd-x86_64.tar.gz\n```\n##  删除已安装的mysql or mariadb\n这里不仅需要移除mariadb，如果有mysql,也要移除\n```\nrpm -qa | grep mariadb\nrpm -ev mariadb-libs-5.5.68-1.el7.x86_64 --nodeps\nfind / -name mysql # 删除查询出来的文件夹\n```\n##  创建用户和组\n\n创建数据库安装位置:\n```\nmkdir /usr/local/mysql\n```\n然后把mariadb-10.5.9-linux-systemd-x86_64.tar.gz解压并拷贝到这个/usr/local/mysql这个目录下:\n```cmd\ntar -zxvf mariadb-10.5.9-linux-systemd-x86_64.tar.gz\nmv mariadb-10.5.9-linux-systemd-x86_64/* /usr/local/mysql\n```\n> 注：mv命令没有-R这个参数，cp命令有-R，用于递归地赋值目录及内容。\n\n```\ngroupadd mysql\nuseradd -r -g mysql mysql\nchown -R mysql:mysql /usr/local/mysql\n```\n\n##  创建数据目录\n```\nchown -R mysql:mysql /opt/data/mariadb\n```\n\n##  配置数据库的配置文件\n\nmariadb默认使用的配置文件/etc/my.cnf\n```\n[client]\nport = 3306\nsocket = /usr/local/mysql/mysqld.sock\n\n# The MySQL server\n[mysqld]\nport = 3306\nsocket = /usr/local/mysql/mysqld.sock\ndatadir = /opt/data/mariadb\nskip-external-locking\nskip-name-resolve\nback_log = 50\nmax_connections = 2048\nmax_connect_errors = 1000\ntable_open_cache = 1024\nopen_files_limit = 16384\nmax_allowed_packet = 16M\nread_buffer_size = 8M\nread_rnd_buffer_size = 32M\nsort_buffer_size = 2M\njoin_buffer_size = 2M\nthread_cache_size = 64\nquery_cache_size = 64M\nquery_cache_limit = 4M\nslow_query_log = 1\nlong_query_time = 2\nlower_case_table_names = 1\ninnodb_file_per_table = 1\nmax_allowed_packet = 1G\nserver-id = 1\nlog-bin = mysql-bin\nexpire_logs_days = 7\nbinlog_format = ROW\n\ninnodb_data_file_path = ibdata1:12M:autoextend\ninnodb_buffer_pool_size = 2G\ninnodb_write_io_threads = 12\ninnodb_read_io_threads = 8\ninnodb_thread_concurrency = 16\ninnodb_flush_log_at_trx_commit = 2\ninnodb_log_buffer_size = 16M\ninnodb_log_file_size = 170M\ninnodb_lock_wait_timeout = 60\n\n```\n\n##  数据库初始化\n\n切换到/usr/local/mysql目录下:\n```\ncd /usr/local/mysql\n./scripts/mysql_install_db --user=mysql\n\n# 启动\n./bin/mysqld_safe --user=mysql &\n\n```\n\n##  配置开机启动\n\n```\ncd /usr/local/msyql/support-files\ncp mysql.server /etc/init.d/mysql\nchmod 755 /etc/init.d/mysql\nchkconfig --add mysql\nchkconfig --level 345 mysql on\n```\n\n> 注:cp /usr/local/msyql/support-files/mysql.server /etc/init.d/mysql 这个命令可能提示找不到mysql.server这个文件\n\n##  设置环境变量\n```\nexport PATH=/usr/local/mysql/bin:$PATH\n```\nservice mysql start/restart\n\n##  设置用户\n```\nmysql>grant all privileges on *.* to 'root'@'%' identified by 'root' WITH GRANT OPTION;;\nmysql>flush privileges;\n```\n这里注意添加with grant option，通过update会提示没有权限.\n到这一步，就可以通过mysql client连接数据库了。\n\n\n##  Referenced\n[1、CentOS7挂载新数据盘的完整步骤](https://cloud.tencent.com/developer/article/1720967)\n[2、封面图](https://huadou145.lofter.com/post/205d4db3_1c7247e32)","tags":["MariaDB"],"categories":["数据库"]},{"title":"Nginx列出文件目录","slug":"89","url":"/2021/04/19/89/","content":"之前在linux中一直使用Nginx做Ftp服务器，但一直没做目录浏览，这在文件传输时还要提前知道文件名，十分不便，本文记录如何开启Nginx目录浏览。\n<!--more-->\n\n##  应用环境\nOS: ubuntu18.04\nNginx: 1.14\n\n##  Nginx开启目录浏览\n在配置文件的location节点中加入以下内容:\n```\nlocation /rs {\n    autoindex on; # 开启目录列出\n    autoindex_exact_size on;  # 以MB为单位默认BYTE\n    autoindex_localtime on;  # 本地时间显示默认GMT\n    ...\n}\n```\n这样通过访问： http://ip:port/rs 就能直接看到文件列表啦。\n \n\n##  Referenced\n[1、开启Nginx目录文件列表](https://www.rootop.org/pages/2906.html)\n[2、封面图源](https://shiyuhei10456.lofter.com/post/3126465a_1c76bf4d6)","tags":["Nginx"],"categories":["Linux"]},{"title":"隐藏ArcGIS Server服务目录中的服务","slug":"88","url":"/2021/04/19/88/","content":"默认情况下，在知道一个ArcServer的服务地址之后，就可以访问到所有公开的服务列表，本文通过修改服务的属性来隐藏服务地址，以增加应用的安全性。\n<!--more-->\n##  环境\nArcServer:10.2\n\n##  修改服务属性\n登录以下地址：\nhttp://gisserver.domain.com:6080/arcgis/admin\n选中服务，并滑动到底部，可以看到编辑服务， 然后将 \"deprecated\": \"true\", 添加到服务配置的第一行，如下：\n```\n{\n \"deprecated\": \"true\",\n \"serviceName\": \"FireHydrants\",\n \"type\": \"MapServer\",\n ...\n```\n保存重启服务。\n这样我们访问：http://gisserver.domain.com:6080/arcgis/rest/services 就看不到公开的服务列表啦。\n\n\n##  Referenced\n[1、隐藏 ArcGIS Server 服务目录中的服务](https://enterprise.arcgis.com/zh-cn/server/10.4/administer/windows/hiding-a-service-in-the-arcgis-server-services-directory.htm)\n[2. 封面图源](https://huadou145.lofter.com/post/205d4db3_1c71e6ba8)","tags":["ArcGIS"],"categories":["GIS"]},{"title":"应用安全之隐藏Web服务器信息","slug":"87","url":"/2021/04/01/87/","content":"最近在漏洞扫描报告中提出了这样一个问题\"可通过HTTP获取远端WWW服务信息\",本文对修复过程作记录。\n<!--more-->\n\n##  环境\nOS:Asianux Server 4\nNginx:1.18.0\n\n##  获取web服务器的信息\n```\ncurl -I ip:port\n```\n可以输入如下信息：\n```\nHTTP/1.1 200 OK\nServer: Nginx/1.18.0\nDate: Thu, 01 Apr 2021 08:40:07 GMT\nContent-Type: text/html\nContent-Length: 307\nLast-Modified: Wed, 12 Jun 2019 03:14:19 GMT\nConnection: keep-alive\nETag: \"5d006e0b-133\"\nAccept-Ranges: bytes\n```\n\n##  重新编译Nginx以屏蔽Nginx信息\n找到Nginx安装包中src/http/ngx_http_header_filter_module.c,修改以下内容：\n```\nstatic u_char ngx_http_server_string[] = \"Server: unknown\" CRLF;\nstatic u_char ngx_http_server_full_string[] = \"Server: unknown \" CRLF;\nstatic u_char ngx_http_server_build_string[] = \"Server: unknown\" CRLF;\n```\n重新编译安装nginx:\n```\n./configure --without-http_rewrite_module --with-http_ssl_module\nmake\nmake install\n```\n运行Nginx后再次执行\"curl -I ip:port\" 就会发现nginx信息已被替换为unknown;\n\n对于win版本的Nginx，目前只找到如何隐藏版本号,在nginx配置文件中http节点下添加如下内容即可：\n```\nserver_tokens off;\n```\n\n##  关于Tomcat\n目前Tomcat的最新版本9.0.44中已经看不到这个信息，因此可以暂时忽略。\n\n##  Referenced\n[1、详细记录一次Tomcat服务器和Nginx服务器的缺省banner的修改全过程](https://blog.csdn.net/huangbaokang/article/details/88235386)\n[2.封面图源](https://huadou145.lofter.com/post/205d4db3_1c84a2eba)","tags":["安全"],"categories":["运维"]},{"title":"CentOS安装Mysql审计插件","slug":"86","url":"/2021/03/19/86/","content":"\n由于安全测评，要为Mysql数据库安装审计插件，由于最开始选择的时mcafee的审计插件，导致走了很多弯路，这里对审计插件的安装过程做个记录。\n\n<!--more-->\n\n##  软件版本\nMysql: 5.7.32社区版\nCentos:7\nMariaDB: 10.5\n\n##  审计插件\n为Mysql社区版本提供审计的插件主要有三个 McAfee MySQL Audit Plugin、Percona Audit Log Plugin、MariaDB Audit Plugin。关于mcafee的插件安装可以参考文后链接，安装复杂且最终安装失败，因此最后选择了mariadb的审计插件，除了最后修改mysql配置时关于审计的配置没有卸载[mysqld]下导致audit插件不起作用，整个过程还是比较顺利的。\n\n##  安装server_audit.so\n\n###  审计插件配置\n\n下载MariaDB的安装包，在lib/plugin中拿到server_audit.so文件，将其放到mysql的plugin目录下。\n\n修改Mysql的配置文件：\n```\n# 在[mysqld]标签下添加：\nserver_audit_logging=ON\nserver_audit_file_path=/var/log/mariadb/server_audit111.log\nserver_audit=FORCE_PLUS_PERMANENT  # 防止审计插件被卸载\nserver_audit_file_rotate_size=1G\nserver_audit_file_rotations=10\n```\n**注意:**一定要写在mysqld下面哦\n\n###  安装插件\n重启mysql数据库并登录安装插件\n```\nmysql>install plugin server_audit soname 'server_audit.so';\n```\n\n###  查看审计是否开启\n```\nmysql> show variables like '%audit%';\n```\n如果server_audit_logging的属性值为ON则表明开启。\n\n接下来，应该就能看到server_audit.log文件中内容了。\n\n##  最后\n还是maria好啊！！！\n\n##  Referenced\n[1、MySQL5.7审计功能windows系统](http://blog.itpub.net/31441024/viewspace-2213103)\n[2、MySQL 安装 MariaDB Audit Plugin 插件，实现审计日志输出](https://www.isolves.com/it/sjk/MYSQL/2020-05-13/17830.html)\n[3、封面图源](https://lyla7784.lofter.com/post/30a15a3d_1c8923399)","tags":["Mysql","安全"],"categories":["数据库"]},{"title":"Excel隔行提取数据与隔行写入数据","slug":"84","url":"/2021/03/17/84/","content":"本文通过对Excel数据的隔行提取，并结合隔行插入实现数据的对齐，为以后数据统计提供基础。\n\n<!--more-->\n\n##  隔行提取数据\n使用函数：OFFSET(A1,ROW(A1),0)\n其中C1表示引用的单元格，row返回引用单元格的行数，row（A1）\\*2表示获取A1单元格下的第row（A1）*2个单元格。\n\n如下表中的数据：需要提取到隔行的金额，这样就可以只提取到金额了：\n\nA     | B\n-------- |\n床常见品牌: 集美装饰、王氏豪庭、雅兰|\n12,000|\n衣柜常见品牌: 原始原素、ogsweet、源氏木语|\n24,000|\n床头柜常见品牌: 芝华仕、Kartell、安肯家居|\n3,000|\n化妆台常见品牌: 北培、梵思美居、王氏豪庭|\n\n##  隔行插入空行\n创建新列(1-N)，并按顺序排列,行数和待处理数据的行数相同；\n复制新列的数据，放在新列的n+1行；\n选中待插入空行数据，然后点击自定义排序，选择新列，确认即可。\n\n\n##  Referenced\n[1、Excel隔行插入空行的几种小技巧](https://m.wang1314.com/doc/webapp/topic/21102567.html)\n[2、Excel 隔行提取数值](https://jingyan.baidu.com/article/c1a3101eae8ca7de656deb06.html)\n[3、封面图源](https://huadou145.lofter.com/post/205d4db3_1c8bfba2e)","tags":["Excel","Office"]},{"title":"ArcMap制图相关","slug":"83","url":"/2021/03/11/83/","content":"太难了，几年没有使用ArcMap了，又要做水文分析，又要进行数据处理，居然还要制图，那，来吧...\n<!--more-->\n##  操作环境\nOS：win10 x64\nArcGIS:10.2\n\n##  Layout View\n从Data View改到Layout View,ArcMap底部。\n\n##  布局视图是横向的怎么办\n在Layout View中空白处右键，点击**Page and Print Setup**,find **Paper and Page properties**,then set **Orientation** to Landscape.\n\n##  图例样式怎么设置\n插入图例之后，双击图例，打开Legend Properties\n###  图例+Label\n切换至Items处，点击Style,选择图例+Label\n###  图例标题\n切换至General,设置Title即可。\n\n\n##  Referenced\n[1、ArcGIS布局视图怎么设置为横向](https://jingyan.baidu.com/article/b0b63dbfa340bd0b4930707f.html)\n[2、封面来源](https://huadou145.lofter.com/post/205d4db3_1c7247e32)"},{"title":"ArcMap水文分析-提取河网和流域","slug":"82","url":"/2021/03/11/82/","content":"本文记录了使用ArcMap对DEM数据进行水文分析，提取河网和流域的过程，对栅格和矢量数据的切割也略有涉及。\n<!--more-->\n##  运行环境\nArcGIS:10.2\nOS:Win10 x64\n\n##  数据预处理\n\n原始数据是从地理空间数据云中下载到的30m dem\n水文分析不支持个人地理数据库\n\n###  DEM数据切割(Optional)\n\nSpatial Analyst Tools->Extraction->Extract By mask\n\n###  对DEM数据进行拼接(Optional)\n\nData Management tools->Raster->Raster Dataset->Mosaic\n\n###  为栅格数据创建属性表(Optional)\n\nData Management tools->Raster->Raster Properties->Build Raster Attribute Table\n**提示：**在进行水文分析时，如果中途生成的栅格数据没有属性表，后续操作可能会有NoData的错误，如果遇到，可以创建属性表。\n\n##  DEM填坑\n\nSpatial Analyst Tools——>Hydrology->Flow Direction\n处理结果如果是黑白的1-255的,那么说明DEM数据需要进行填坑处理，否则进行下一步\n\n###  sink\n输入：flowdir\n结果：sink\n\n###  watershed\n输入：\n\n    input flow direction raster:flowdir\n\n    input raster or feature pour point data:sink\n\n结果：sinkshed\n\n这一步是通过watershed工具推算出哪些区域的水会流到这些坑里\n\n###  zonal statistics\n输入：\n\ninput raster or feature zone data: sinkshed\n\nzone field: Value\n\nInput value raster: dem\n\nstatistics type: minimum\n\n输出：sink_min\n\n通过区域统计得到“坑”的流域内高程的最低值\n\n###  zonal fill\n输入：\n\ninput zone raster:sinkshed\n\ninput weight raster:dem\n\n输出：\n\nsink_max\n\n使用区域填充的结果是沿着“坑”流域的边界，也就是分水岭，把整个流域填平。这样就获得了“坑”流域的最高高程\n\n###  raster calculator\n输入：\n\nsink_max - sink_min\n\n输出：\n\nsink_depth\n\n这步没什么好说的，大值减小值得到“坑”的最大深度\n\n###  fill\n输入：\n\ninput surface raster: dem\n\nZ limit: sink_depth(max)\n\n输出：filldem\n\nZ limit中要填sink_depth中的上限值，我这里就是510。\n\n###  flow direction\n输入：filldem\n\n输出：fill_dir\n\n如果这次的输出和之前一样，那么请重新开始填坑。\n\n##  计算径流量\n\nflow accumulation\n输入：fill_dir\n\n输出：accu\n\n##  提取河网\n\nSpatial Analyst Tools->Map Algebra->Raster Calculator\n\nCon(accu>X,1)\n其中X为径流量，此值越大，河网越稀疏\n\n输出：河网\n\n##  Stream Link &Stream Order\n连接及分级\n\n##  Stream To Feature\n\n将河网转为Polyline\n对河网分级设色：在矢量河网图层中的属性对话框中，Symbology->Quantities->Graduated colors.\n\n##  流域提取\n\n使用watershed\n\n##  Referenced\n[1、简明Arcgis流域提取方法](https://www.jianshu.com/p/371b81b3e24b)\n[2、arcgis水文分析](https://www.cnblogs.com/crazytao/p/8108829.html)\n[3、封面图源](https://huadou145.lofter.com/post/205d4db3_1c81c6e8f)","tags":["ArcGIS"],"categories":["GIS"]},{"title":"ArcMap计算栅格数据的面积","slug":"81","url":"/2021/03/09/81/","content":"本文主要记录使用ArcMap对某区域土壤数据面积的统计过程。\n<!--more-->\n##  软件环境\nGIS软件：ArcGIS 10.6\nOS:win10\n##  将栅格数据导入数据库\n首先再ArcCatalog中创建一个PersonGeodatabase或FileGeoDatabase，然后将栅格数据导入到数据库中。\n\n##  定义投影\nArcToolbox—DataManagementTools—Projections andTransformations—Raster—Project Raster\n\n##  对数据进行重分类(Optional)\n首先，如果需要，可以连接外部数据表,在Toc窗口，选中图层,Join and relates,进行属性数据关联；\n关联完成之后，可以对数据进行重分类ArcToolbox->Spatial Analyst Tools->Reclass->Reclassify,这样就可以将有相同属性的数据合并。\n\n##  计算面积\n查看图层属性，找到cellsize,并记录下来；\n然后打开属性表,添加字段Area,并打开字段计算器，使用Count*cellsize/1000/1000,这样计算出来的结果就是平方公里。\n\n##  Referenced\n[1、使用ArcGIS统计栅格数据面积 ](https://www.sohu.com/a/289205642_488161)\n[2、封面图](https://alisonmarket.lofter.com/post/2b1789_1c808c676)","tags":["ArcGIS"],"categories":["GIS"]},{"title":"基于TDEngine的轨迹数据存储及数据利用","slug":"80","url":"/2021/01/17/80/","content":"本文对TDEngine超级表及其python connector的使用做了简单的记录。\n\n<!--more-->\n##  运行环境\nOS:centos 8.2\nTDEngine版本：2.0.7.0\n\n##  背景\n随着轨迹数据的越来越多，现有Oracle数据无论是从性能还是从可维护性的角度都不足支撑现有系统的运行。通过对现有时序数据的评估，最终使用TDEngine对轨迹数据进行存储。\n##  TDEngine的安装及启动\n###  配置FQDN\n当前版本连接TDEngine都是通过FQDN进行的，因此如果后续想要通过各种驱动访问tdengine,必须要配置这个属性。\n修改/etc/hostname配置主机名 \n修改/etc/hosts配置主机名和ip地址的关系  \n修改完毕之后如果能ping通主机名，则表示配置完成。\n\n###  安装及启动命令\n```\nrpm -ivh TDengine-server-2.0.7.0-Linux-x64.rpm\nsystemctl start taosd\nsystemctl stop taosd\nsystemctl status taosd\n```\n\n###  卸载TDEngine\n```\nrpm -e tdengine\n```\n\n##  TDEngine中的SQL语法\n连接tdengine\n```\ntaos -h hostname\n```\n###  数据库创建\n```\ncreate database if not exists ship_track keep 3650 precision \"us\";\nuse ship_track;\ndrop database if exists ship_track;\n```\n[keep] 数据存储的天数，最长为10年，过期数据会自动删除\n[precision]时间的精度,默认为毫秒，这里取微秒\n\n###  创建表\nTDEngine中有超级表的概念，即对于同一类的数据我们可以把他们存储到一个超级表中，然后每个设备的数据再存储到超级表下的子表，这样在针对单个子表进行查询时会极大的挺高查询的效率。\n\n超级表有一个tags属性,TAGS 列名不能与其他列名相同,这里我们指定的是设备编号，如下：\n```\ncreate table if not exists S_SHIPS(UPDATETIME TIMESTAMP,SHIPNAME BINARY(50),LNG DOUBLE,LAT DOUBLE,CS BINARY(20),MESSAGETEXT BINARY(4000)) tags(USERID BINARY(20));\n\n```\n创建子表\n```\nCREATE TABLE IF NOT EXISTS tb_name USING S_SHIPS TAGS (tag_value1, ...);\n```\n\n###  数据写入\n```\nINSERT INTO tb_name VALUES (field_value, ...);\nINSERT INTO tb_name (field1_name, ...) VALUES (field1_value, ...)\n-- 可以在写入时创建超级表的子表\nINSERT INTO tb_name using S_SHIPS tags(xx) VALUES(field1_value, ...)\n```\n\n###  查询\n查询超级表下的子表数量：\n```\nselect count(TBNAME) from S_SHIPS;\n```\n这里的TBNAME是一个关键字，可用于统计分析。  \n根据时间间隔查询数据：\n```\nselect AVG(lng) from t985000989 interval(30s);\n```\ninterval单位： a(毫秒)、s(秒)、 m(分)、h(小时)、d(天)、w(周)。 \n##  使用Python写入及查询taos数据\n###  安装python-connector\n```\npip3 install /usr/local/taos/connector/python/linux/python3\n```\n###  数据写入\n```\nimport taos \nimport datetime\n\nconn = taos.connect(host=\"test\", user=\"root\", password=\"taosdata\", config=\"/etc/taos\")\ndt=datetime.datetime.now()\ninsertsql='insert into t '\nc1 = conn.cursor()\nc1.execute('use dbaseName')\nc1.execute(insertSql)\nc1.close()\n```\n###  查询数据\n```\nimport taos \nimport json\n\nconn = taos.connect(host=\"test\", user=\"root\", password=\"taosdata\", config=\"/etc/taos\")\nquerySql=''\nc1 = conn.cursor()\nc1.execute('use dbaseName')\nc1.execute(querySql)\nships=[]\nfor data in c1:\n    ship={}\n    ship[\"mmsi\"]=data[0]\n    ship[\"count\"]=data[1]\n    ships.append(ship)\nshipsStr=json.dumps(ships)\nc1.close()\n```\n##  Referenced\n[1、保姆级演示一分钟搞定TDengine的下载安装](https://www.jianshu.com/p/066677035940)\n[2、Cover](https://tiezhuzhuzhu923.lofter.com/post/310ff6d7_1c804cbfb)","tags":["GIS","大数据","时序数据"],"categories":["Python"]},{"title":"Oracle数据库小结","slug":"79","url":"/2021/01/17/79/","content":"最近在维护一个oracle数据库的项目，本文把遇到的一些问题做了一个小结。\n\n<!--more-->\n\n##  运行环境\n\nOS: win server 2016\n\nOracle:11g\n\n##  数据库连接问题\n\nOracle数据库与其它数据库（如mysql、sql server等）最大的区别可能就是必须要安装oracle客户端，通过其Net Manager配置网络服务名。但如果是Java则可以使用thin进行连接，而不需要安装oracle客户端。[1]\n\n##  表空间(tablespace)\nOracle数据库被划分成称作表空间的逻辑区域，形成Oracle数据库的逻辑结构，类似与其他关系型数据的database的概念，用来存储如表、视图、索引等信息。一个数据库实例可以有多个表空间，一个表空间可以有多个数据文件，一个数据文件的最大大小32GB,当超过32G时，需要为表空间添加数据文件。\n\n注：关于对表空间的相关操作可以通过Toad来进行。\n\n###  创建表空间\n这里创建了一个大小200M的、可自动扩展的、最大大小没有限制(32G)的表空间：\n```\ncreate tablespace GMAP datafile 'D:\\xx\\xx.dbf' size 200M AUTOEXTEND ON NEXT 5M MAXSIZE UNLIMITED;\n```\n###  新增数据文件\n当表空间的数据文件达到32G时，表空间的大小无法自动增加，可以通过新增数据文件的方式继续向表空间中写入数据。\n```\nALTER TABLESPACE app_data ADD DATAFILE\n'D:\\xx.DBF' SIZE 50M\nAUTOEXTEND ON NEXT 5M MAXSIZE 100M; \n```\n##  临时表空间\n临时表空间用来管理数据库排序操作以及用于存储临时表、中间排序结果等临时对象,当ORACLE里需要用到SORT的时候，并且当PGA中sort_area_size大小不够时，将会把数据放入临时表空间里进行排序。像数据库中一些操作： CREATE INDEX、 ANALYZE、SELECT DISTINCT、ORDER BY、GROUP BY、 UNION ALL、 INTERSECT、MINUS、SORT-MERGE JOINS、HASH JOIN等都可能会用到临时表空间。当操作完成后，系统会自动清理临时表空间中的临时对象，自动释放临时段。这里的释放只是标记为空闲、可以重用，其实实质占用的磁盘空间并没有真正释放。这也是临时表空间有时会不断增大的原因。[2]\n\n当我们进行部分查询或者创建索引的时候，会遇到ora-01652无法通过128(在表空间temp中)扩展temp段的错误，这个就是提示我们临时表空间爆了，可以通过更换临时表空间解决。\n\n###  创建临时表空间\n```\ncreate temporary tablespace temp02 tempfile 'E:\\xxx.DBF' size 1024M autoextend on;\n```\n###  修改默认临时表空间\n```\n-- 查看临时表空间\nSELECT USERNAME,TEMPORARY_TABLESPACE FROM DBA_USERS;\n-- 更换临时表空间\nalter database default temporary tablespace temp02;\n-- 删除旧的临时表空间\ndrop tablespace temp including contents and datafiles;\n-- 确认是否删除\nselect tablespace_name from dba_tablespaces; \n```\n\n##  管理员账户无法登陆\n重置密码文件PWDorcl2.ora\n```\norapwd file=C:\\app\\xx\\product\\11.2.0\\dbhome_1\\database\\PWDorcl2.ora password=admin entries=40 force=y;\n```\n使用dba账户登陆，给用户授权\n```\nsqlplus /nolog\nconn sys/admin as sysdba\n```\n\n##  监听日志文件达到4G,导致数据库无法连接[4]\nlistener的日至文件位于：\n```\napp\\Administrator\\diag\\tnslsnr\\pc-name\\listener\\trace\\listener.log\n```\n当此文件的大小超过4G时，windows下就无法连接了，可通过清空此文件或者关闭监听器日志,命令如下：\n```\nlsnrctl set log_status off      \nlsnrctl set log_status on  \n```\n清空日志的时候需要关闭日至，即off命令。\n\n##  数据导入及导出\n###  导出(exp)\n```\nexp user/pwd@localhost:1521/orcl owner=user rows=y indexes=n compress=n buffer=500000000 file=xx.dmp log=xx.log\n```\n###  导入\n```\nimp user/pwd@localhost/orcl file=xx.dmp full=y ignore=y\n```\n\n##  Referenced\n[1、连接ORACLE数据库，是不是必须要安装oracle客户端的运行时](https://www.cnblogs.com/arxive/p/10147641.html)\n[2、ORACLE临时表空间总结](https://www.cnblogs.com/zhangyingai/p/7082594.html)\n[3、关于Oracle使用管理员账号登录失败的问题](https://www.cnblogs.com/sunnor/p/7097998.html)\n[4、oracle 监听日志文件达到4G，导致监听报错的解决方法 ](http://blog.itpub.net/29578568/viewspace-2140148/)\n[5、Cover](https://huadou145.lofter.com/post/205d4db3_1c7474e60)\n","tags":["数据库","Oracle"],"categories":["数据库"]},{"title":"Linux磁盘挂载","slug":"78","url":"/2021/01/17/78/","content":"本文主要记录linux磁盘挂载相关命令。\n<!--more-->\n\n##  运行环境\n\nOS:Manjaro 20.01&Win10双系统\n\n##  确定要挂载的分区信息\n\n###  lsblk\n\n作用：确定分区的位置及空间\n\n###  ls -l /dev/disk/by-uuid\n\n作用：确定分区的UUID\n\n##  临时挂载\n使用mount命令临时挂载：\n```\nmkdir /exstore\nmount /dev/vdb /exstore\n```\n##  永久挂载\n编辑/etc/fstab文件\n```\nUUID=xx                     /media/Documents  ntfs defaults 0 0  \n```\n其中/media/Documents为挂载点，也就是以后通过这个位置访问此分区。\n\n重新加载fstab文件的内容：\n```\nmount -a\n```\n或者重启：\n```\nshutdown -r now\n```\n##  关闭win10的快速启动\n如果是win10+manjaro双系统，在从win10进入manjaro时，可能会出现挂载的硬盘无法写入，此时需要重新进入win10关闭快速启动，执行以下命令即可：\n```\npowercfg /h off\n```\n##  Referenced\n[1、linux的mount -a命令](http://blog.chinaunix.net/uid-28458801-id-5789504.html)\n[2.封面图源](https://huadou145.lofter.com/post/205d4db3_1c8a36320)","tags":["Linux","Manjaro"],"categories":["Linux"]},{"title":"win10下使用xrdp远程连接ubuntu18.04","slug":"77","url":"/2021/01/04/77/","content":"之前使用vnc方式及桌面共享远程ubuntu18.04时，光标位置移动很慢，并且还是一个小远点，效果非常不好，这里使用win10的xrdp方式远程ubuntu18.04,效果还不错。\n<!--more-->\n##  环境\nubuntu:18.04\n##  安装xrdp\n```\nsudo apt install xrdp\n```\n修改配置：\n```\nsudo vim /etc/xrdp/startwm.sh\n```\n把最下面的test和exec两行注释掉，添加一行\n```\ngnome-session\n```\n重启ubuntu,不登陆\n\n##  win10远程连接ubuntu\n打开远程桌面，输入ubuntu的ip地址，然后输入用户名和密码即可。  \n此时我们可能只能看到一个青色背景，什么都没有，稍等几分钟会看到一个错误的提示。\n执行以下命令解决：\n```\nsudo apt-get install xorgxrdp  \n```\n此时重新连接时就会看到ubuntu的背景的，会提示几次授权修改主机的颜色设置什么的，都可以cancel掉，然后即可登陆成功\n\n\n\n##  Referenced\n[1、xrdp方式windows 10连接ubuntu 18.04](https://zhuanlan.zhihu.com/p/40937988)\n[2、Issues with xRDP and Ubuntu 18.04.2 – How to fix it](http://link.zhihu.com/?target=http%3A//c-nergy.be/blog/%3Fp%3D13390)\n[3、封面图源](https://huadou145.lofter.com/post/205d4db3_1c8bfba2e)","tags":["RDP","SSH"],"categories":["Linux"]},{"title":"Centos8的一些基本配置","slug":"76","url":"/2020/11/28/76/","content":"最近在搞centos8，把其常用操作及配置做个简单的记录，包括静态ip配置、gui的安装、防火墙配置、vnc配置等。\n\n<!--more-->\n\n##  环境\n\nos: centos8.2\n\n##  配置静态IP\n\n```\n/etc/sysconfig/network-scripts\nvi ifcfg-ens160\n```\n\n这里en(ethernet)后面可能是其它值，具体如下：\n\n>o:主板板载网卡，集成的是设备索引号\n>\n>p:独立网卡，PCI网卡\n>\n>s:热插拔网卡，usb之类的扩展槽索引号\n>\n>后面的数字：MAC地址+主板信息计算得出的唯一序号\n>\n\n修改以下内容：\n\n```\n# 设置静态IP\nBOOTPROTO=\"static\"\n# 开机启动\nONBOOT=\"yes\"\n# 设置IP地址\nPREFIX=24\nIPADDR=192.168.1.80\nGATEWAY=192.168.1.1\nNETMASK=255.255.255.0\nDNS1=192.168.1.1\n```\n\n重启网卡\n\n```\nnmcli c reload ens160\n```\n\n##  GUI界面安装\n\n这里如果使用的centos8.2 dvd版的安装镜像安装时，可以直接选择安装图形界面的，如果没有安装可以执行以下命令配置\n\n```\nyum groupinstall \"Server with GUI\" -y\n\nsystemctl get-default\n\nsystemctl set-default graphical.target\n\nreboot\n```\n\n\n\n##  VNC Server安装及配置\n\n执行以下命令安装\n\n```\nyum groupinstall \"X Window System\"\nyum install gnome-classic-session gnome-terminal nautilus-open-terminal control-center liberation-mono-fonts\nunlink /etc/systemd/system/default.target\nln -sf /lib/systemd/system/graphical.target /etc/systemd/system/default.target\n\nreboot # 重启机器\n\nyum install tigervnc-server -y\n\ncp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service\n\n```\n\n修改配置文件,这里以test用户为例：\n\n```\nvim /etc/systemd/system/vncserver@:1.service\n添加User=test\n并将里面的<User>替换为test\n```\n\n修改完成之后\n\n```\nsystemctl daemon-reload\n# 设置密码\nvncpasswd\n```\n\n启动及重启命令\n\n```\nsystemctl enable vncserver@:1.service # 设置开机启动\nsystemctl start vncserver@:1.service # 启动vnc会话服务\nsystemctl status vncserver@:1.service # 查看nvc会话服务状态\nsystemctl stop vncserver@:1.service # 关闭nvc会话服务\n```\n\n接下来就可以通过vnc viewer远程连接centos8的图形界面了。\n\n\n\n##  防火墙配置\n\ncentos8安装完成之后，防火墙默认是启动的，可以通过以下命令对防火墙进行控制\n\n```\n# 查看防火墙状态\nsystemctl status firewalld.service\n# 停止\nsystemctl stop firewalld.service\nfirewall-cmd --zone=public --add-port=80/tcp --permanent   # 开放80端口\nfirewall-cmd --zone=public --remove-port=80/tcp --permanent # 删除开放的80端口\nfirewall-cmd --reload   # 配置立即生效\n# 查看已经开放的端口\nfirewall-cmd --zone=public --list-ports\n```\n\n\n\n##  硬盘扩容\n\n首先给硬盘分配空间，然后使用gparted对分区扩容\n\n##  安装gparted\n\n可以使用gparted.iso，也可以在系统内安装gparted应用，系统内安装gparted应用可通过以下命令：\n\n\n```\n sudo yum install epel-release\n sudo yum install gparted\n```\n\n安装完成之后通过gparted修改分区大小，然后扩容逻辑分区大小：\n\n```\n# 查看逻辑分区名：\ndf -h\n# 扩容，这里+2G指添加的容量\nlvextend -L +2G /dev/mapper/cl-root\nxfs_growfs /dev/mapper/cl-root\n# 查看各个分区容量\nlsblk\n```\n\n##  Referenced\n\n[1、网卡不叫eth0，而叫ens33、ens160、eno1 or enp0s](https://www.jianshu.com/p/5fc492060e70)\n\n[2、CentOS8安装图形界面](https://www.cnblogs.com/whereGo/p/13486157.html)\n\n[3、Windows远程连接CentOS图形化界面 - 如梦幽香 - 博客园 (cnblogs.com)](https://www.cnblogs.com/bumengru/p/10244207.html) \n\n[4、centOS 6.8下使用Gparted进行分区扩容](https://www.cnblogs.com/DavonC/p/12707728.html)\n\n[5、封面图](https://alisonmarket.lofter.com/post/2b1789_1c7361bf1# )\n\n","tags":["centos"],"categories":["Linux"]},{"title":"JQuery的Deferred对象获取多个耗时操作的结果","slug":"75","url":"/2020/11/18/75/","content":"最近在做涉及到多个图层的空间查询时，由于前端要对多个查询结果进行整合后处理，之前的写法是添加好几个flag，但还是没有做好控制，偶然看到了Jquery的Deferred，这里对其使用做简单的总结\n\n<!--more-->\n\n##  开发环境\nOS: win10 x64\nJQuery: 1.9.1\nBrowser: IE8\n\n##  Deferred对象简介\n\nDeferred对象是jQuery1.5开始引入的对象，用来弥补jQuery在回调函数方面功能不足的情况。Deferred对象有以下几种状态：  \n> resolved: 已完成 , 调用此方法后，表示当前Deferred对象已经执行完成，会调用到done()\n> reject: 失败，会调用到fail()\n\n$.Deferred对象的几个操作：\n> $.when()：为多个操作指定回调\n> deferred.then(): done和fail的结合\n\n##  ajax的链式写法\n\n```\n$.ajax('test.html').done(function(){ }).fail(function(){ });\n```\n其中：done()相当与success(),fail相当于error()。\n\n##  等待多个操作的返回结果\n如果是这几个操作是确定，那我们直接使用$.when().done就可以了，如下：\n```\nvar d1 = $.Deferred();\nvar d2 = $.Deferred();\nvar d3 = $.Deferred();\n\nfunction async1() {\nd1.resolve(\"Fish\");\n}\n\nfunction async2() {\nd2.resolve(\"Pizza\");\n}\n\nfunction async3() {\nd3.resolve(\"Chicken\");\n}\n\n$.when(d1, d2,d3).done(function (v1, v2,v3) {\n\tconsole.log(v1 + v2 +v3+ '已完成');\n});\nasync1();\nasync2();\nasync3();\n```\n这里的v1，v2,v3就是deferred对象在调用resolve函数时的参数。\n\n##  等待未知数量的请求的返回结果\n对于有些循环的请求，只能通过数组的方式创建Deferred对象的场景，可以使用$.when().apply,如下：\n```\nvar defArr=[];\ndefArr[0]=$.Deferred();\n...\n$.when.apply($,defArr).then(function(){\n//参数处理：https://www.imooc.com/wenda/detail/564295\nvar objects=arguments;\nfor(var i=0;i<objects.length;i++){\nconsole.log(objects[i]);\n}\n})\n```\n\n##  Referenced\n[1、jQuery的deferred对象详解](http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html)\n[2、Deferred参数的处理](https://www.imooc.com/wenda/detail/564295)\n[3、封面图](https://shiyuhei10456.lofter.com/post/3126465a_1c76bf4d6)","tags":["JQuery"],"categories":["前端"]},{"title":"bat的简单使用","slug":"74","url":"/2020/11/15/74/","content":"最近在windows上写了简单nginx重新加载配置的脚本，用到了bat,本文就用到的一些bat语法作简单记录。\n\n<!--more-->\n\n##  开发环境\nOS: win server 2008\n\n##  Bat文件的注释\n:: 注释内容\n其它类型的注释：\n```\n1、rem 注释内容（不能出现重定向符号和管道符号）\n2、echo 注释内容（不能出现重定向符号和管道符号）〉nul\n3、if not exist nul 注释内容（不能出现重定向符号和管道符号）\n4、:注释内容（注释文本不能与已有标签重名）\n5、%注释内容%（可以用作行间注释，不能出现重定向符号和管道符号）\n6、goto 标签 注释内容（可以用作说明goto的条件和执行内容）\n7、:标签 注释内容（可以用作标签下方段的执行内容）\n```\n##  拷贝\n###  拷贝文件\n\n1. 仅拷贝\n\n```\ncopy c:\\123.txt d:\\\n```\n\n2. 重命名文件\n\n```\ncopy c:\\123.txt d:\\234.txt\n```\n\n###  文件夹\n\n```\ncopy c:\\123\\*.conf d:\\123\n```\n会默认覆盖重名文件，测试环境：win server 2008，后面不用添加 /y\n\n##  nginx重新加载配置bat\n```\n@echo off\ntaskkill /f /fi \"IMAGENAME eq nginx.exe\"\n::拷贝配置文件\ncopy D:\\generateConf\\*.conf C:\\Users\\xxx\\Desktop\\nginx-1.xx.0\\conf\nstart nginx.exe\n::pause\n```\n\n##  Referenced\n[1、BAT文件如何注释](https://www.cnblogs.com/guoguochong/p/7651651.html)\n[2、cmd copy命令 文件复制](https://www.jb51.net/article/18981.htm)\n[3、封面图源](https://lyla7784.lofter.com/post/30a15a3d_1c8923399)","tags":["Nginx","bat","Windows"],"categories":["运维"]},{"title":"容器部署SiteServer7.0.4后解析word包Gdip的错","slug":"73","url":"/2020/11/14/73/","content":"最新版的SiteServer使用ASP.NET Core开发，网站的响应速度提升非常明显，在使用Docker部署之后，使用过程中出现了The type initializer for 'Gdip' threw an exception.的问题，本文记录如何解决\n<!--more-->\n\n##   环境\nOS:ubuntu 16.04\nSiteServer:7.0.6\nDocker部署\n\n##  安装Gdip\n出现这个问题是因为docker中没有安装Gdip，安装即可。\n这里SiteServer的docker使用的Ubuntu18.04，首先换源\n```\ncat >/etc/apt/sources.list<<'EOF'\ndeb http://mirrors.aliyun.com/debian/ buster main non-free contrib\ndeb-src http://mirrors.aliyun.com/debian/ buster main non-free contrib\ndeb http://mirrors.aliyun.com/debian-security buster/updates main\ndeb-src http://mirrors.aliyun.com/debian-security buster/updates main\ndeb http://mirrors.aliyun.com/debian/ buster-updates main non-free contrib\ndeb-src http://mirrors.aliyun.com/debian/ buster-updates main non-free contrib\ndeb http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib\ndeb-src http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib\nEOF\n```\n安装gdip  \n```\napt-get update && apt-get install -y apt-utils libgdiplus libc6-dev\n```\n\n##  重启容器\n```\ndocker restart containerId\n```\n\n##  Referenced\n[1、Ubuntu 18.04更换阿里源](https://blog.cnrainbird.com/index.php/2020/04/19/linux_debian10_buster_geng_huan_a_li_yuan/)\n[2、asp .net core 部署在docker中，报错 The type initializer for 'Gdip' threw an exception.](https://www.cnblogs.com/youngsheep/p/11890069.html)\n[3、 封面图源](https://huadou145.lofter.com/post/205d4db3_1c8f12e12)\n","tags":["Docker","ASP.NET","SiteServer"],"categories":["CMS"]},{"title":"Mysql限制密码输入错误次数","slug":"72","url":"/2020/09/23/72/","content":"通过使用mysql内置的插件来限制异常登录，以防止异常登录。\n<!--more-->\n\n##  安装插件\n登录mysql server: mysql -uroot -p\n\n先确定mysql是否安装了connection\\_control 和 CONNECTION_CONTROL_FAILED\\_LOGIN_ATTEMPTS插件\n```\n>show plugins;\n```\n如果没有安装上述插件，进行安装：\n\n```\ninstall plugin CONNECTION_CONTROL soname 'connection_control.so';\ninstall plugin CONNECTION_CONTROL_FAILED_LOGIN_ATTEMPTS soname 'connection_control.so';\n```\n##  修改mysql配置文件\n\n如果不确定mysql的配置文件的位置\n```\nmysql --help|grep 'my.cnf'\n```\n此命令会列出配置文件的路径\n\n然后在[mysqld]下添加：\n```\nconnection-control-failed-connections-threshold=5   \nconnection-control-min-connection-delay=108000\n```\nservice mysql restart\n登录mysql查看配置：\nshow variables like '%connection_control%';\n\n##  Referenced\n[1. MySQL数据库限制多次登录失败重试时间](https://blog.csdn.net/ywd1992/article/details/83865537)\n[2. mysql配置文件路径](https://blog.csdn.net/qq_37502106/article/details/80199321)\n[3. 封面图](https://huadou145.lofter.com/post/205d4db3_1c8bfba2e)","tags":["Mysql","安全","数据库"],"categories":["数据库"]},{"title":"Nginx添加Stream模块代理tcp服务","slug":"71","url":"/2020/09/08/71/","content":"在百度云上部署了一个tcp服务，但是服务ip只能使用云服务器的内网ip,这样外网就没法访问到了，因此这里使用Nginx的stream模块代理tcp服务。\n<!--more-->\n##  环境\nNginx：1.19.1\nOS:ubuntu 18.04\n\n##  Nginx查看版本及配置\n```\nnginx -V\n```\n##  编译Nginx源码\n根据已安装nginx版本下载源码，这里给nginx添加stream模块\n```\n./configure --with-http_ssl_module --with-stream \nmake\n```\n编译完成之后，将objs目录中的nginx复制到/usr/local/nginx/sbin下，覆盖即可\n此时再执行nginx -V,会看到配置参数有了with-stream\n\n##  Nginx代理TCP端口[1]\n配置如下,其中stream和http同级\n```\nstream \n{\n    upstream cloudsocket \n    {\n        hash $remote_addr consistent;\n        server 10.x.xx.14:1831 weight=5 max_fails=3 fail_timeout=30s;\n    }\n    server \n    {\n        listen 8081;\n        proxy_connect_timeout 1s;\n        proxy_timeout 3s;\n        proxy_pass cloudsocket;\n    }\n}\n```\n\n##  nginx替换或版本升级\n把apt install nginx安装的nginx替换为源码编译的：\n1. 通过apt install nginx安装的nginx在/usr/sbin下，把此目录下的nginx重新命名\n2. 修改环境变量，添加源码编译的nginx的路径\n```\nexport PATH=$PATH:/usr/local/nginx/sbin\n```\n再通过nginx -V查看nginx的版本即可验证。\n\n##  Reference\n[1、Nginx代理Tcp端口](https://www.cnblogs.com/kamil/p/6066715.html)\n[2、封面图源](https://shiyuhei10456.lofter.com/post/3126465a_1c76bf4d6)\n","tags":["Nginx","TCP"],"categories":["Linux"]},{"title":"记一次Mysql版本升级","slug":"70","url":"/2020/08/26/70/","content":"由于线上的mysql爆出了安全漏洞，因此要把mysql升级到最新版本5.7.31,本文主要对mysql版本升级过程做简单记录。\n<!--more-->\n##  环境\nOS:centos7\nMysql:5.7.26\n\n##  升级Mysql版本\n之前mysql的安装文件：mysql-5.7.25-linux-glibc2.12-x86_64.tar.gz,由于之前并没有通过yum命令安装，而是通过二进制文件安装的，因此只需要将mysql-5.7.31-linux-glibc2.12-x86_64.tar.gz中的文件复制到mysql的安装目录中即可。\n解压mysql:\n```\ntar -zxvf mysql-5.7.31-linux-glibc2.12-x86_64.tar.gz\n```\n将新版本的mysql复制到mysql安装路径中：\n```\ncp -r -f mysql-5.7.25-linux-glibc2.12-x86_64/* /usr/local/mysql\n```\n如果在拷贝时，即便有-f还是需要一个个输入yes确认覆盖。可参考如下方法解决：\n```\nunalias cp\n```\n之后就可以强制覆盖文件了(仅限本次会话使用)。\n\n##  查看mysql版本\n登陆mysql\n```\nmysql -uroot -p\n```\n查看版本\n```\nselect version();\n```\n\n##  Reference\n[1、CentOS下cp/rm/mv等命令强制覆盖操作](https://www.centoschina.cn/command/help/4292.html)\n[2、封面图源](https://huadou145.lofter.com/post/205d4db3_1c81c6e8f)","tags":["Mysql"],"categories":["数据库"]},{"title":"Nginx控制TerraGate地形服务的访问权限","slug":"69","url":"/2020/08/18/69/","content":"本文主要解决TerraGate地形服务的权限控制问题，这里通过Nginx对访问者的ip及useragent分别不同的地形服务的访问权限进行控制。\n\n<!--more-->\n\n##  环境\nTerraGate:5.6.1\nOS:Win Server 2008 R2\nNginx:1.9\n\n##  UserAgent\n调用terragate的地形服务的系统，一般只有TerraExplorer，因此UserAgent这里只有\"TerraExplorer\",如果是其他的UA,直接返回403即可\n\n```\nif ($http_user_agent !~ \"TerraExplorer\"){\n                return 403;\n            }    \n```\n\n##  使用Nginx中的if\n这里主要对用户访问的地形文件的名字和用户ip进行判断,限制特定ip只能访问某个或某些地形文件服务。\nNginx是不支持if...else的，要实现多条件判断，只能通过添加变量来实现\n\n```\nset $flag 0;\nif ($remote_addr ~ '(192)\\.(168)\\.(10)\\.(.*)'){\n                set $flag \"${flag}1\";\n            }\n            if ($request_uri ~ '/\\d+\\?1226xuanran\\.mpt'){\n                set $flag \"${flag}1\";\n            } \n       \n            if ($flag = \"011\"){\n                proxy_pass http://xxx:8081;\n            }\n         \n```\n注意，这里由于访问mpt服务之前，会访问一个类似全图的图片，但此地址中又不包含1226xuanran，因此添加了如下部分\n```\n if ($request_uri !~ '/\\d+.*mpt.*'){\n                set $flag \"${flag}2\";\n            }      \n   if ($flag = \"012\"){\n                 proxy_pass http://xxx:8081;\n            }\n```\n即当请求uri中不包含mpt时，直接放行，代理到真实的地形服务中去。\n\n##  其它Nginx正则表达式相关\n\n=\t开头表示精确匹配\n~\t开头表示区分大小写的正则匹配\n~*\t开头表示不区分大小写的正则匹配\n!~和!~*\t分别为区分大小写不匹配及不区分大小写不匹配 的正则\n/\t通用匹配，任何请求都会匹配到。\n\n##  Reference\n[1. Nginx 判断访问者IP](https://www.blyoo.com/3865.html)\n[2. nginx if多条件判断](https://www.cnblogs.com/lazy-sang/p/12394649.html)\n[3. OpenResty最佳实践](https://www.kancloud.cn/allanyu/openresty-best-practices/82607)\n[4.封面图源](https://huadou145.lofter.com/post/205d4db3_1c84a2eba)\n\n","tags":["Nginx","GIS","TerraGate"],"categories":["GIS"]},{"title":"Nginx为ArcServer做反向代理","slug":"68","url":"/2020/07/31/68/","content":"通过使用Nginx中的ngx_http_access_module,来为我们的ArcServer保驾护航,实现只允许特定的IP可以访问我们的ArcServer发布的服务。\n<!--more-->\n##  环境\nArcServer:10.2\nNginx:1.19.1\nOS:windows server 2008 R2\n\n##  调整ArcServer的端口\n调整之前，先停止ArcServer服务。\nArcServer10.2的manager是部署在tomcat中提供服务的，首先需要调整tomcat的端口，tomcat位于：C:\\Program Files\\ArcGIS\\Server\\framework\\runtime,打开conf/server.xml：\n将其中的默认端口6080调整为需要的端口，如6090。\n\n然后还要修改arcgisserver\\config-store\\machines下的一个*.json文件，文件名和主机名是一致的，将其中的6080调整为上面修改的端口号：6090即可。\n\n重启ArcServer服务，如果http://localhost:6090/arcgis/manager访问没有问题，那说明调整成功。\n\n##  Nginx配置反向代理\n\n修改nginx.conf文件，添加如下内容：\n\n```\n{\n    ...\n    server {\n        listen 6080;\n        location /{\n            proxy_pass http://host:6090;\n        }\n\n    }\n    ...\n}\n```\nwindows下启动Nginx:start nginx.exe\n\n此时如果通过6080端口能够正常访问ArcServer则证明没有问题。\n\n##  Nginx配置指定的IP访问\n\n以下包含局部配置和全局配置，可根据实际情况选择。\n###  在location下配置[局部配置]\n如:\n```\n{\n    location /{\n        ...\n\n        allow 192.168.10.111;\n        deny all;\n    }\n\n}\n```\n这样配置就仅针对当前server的location,非整个Nginx.\n\n###  全局配置\n创建一个blockips.conf文件，里面加入如下内容：\n```\nallow 192.168.10.111;\ndeny all;\n```\n在nginx.conf文件的http节点的末尾加入如下内容：\n```\ninclude blockips.conf;\n```\n\n这样针对的就是整个Nginx。\n\n##  Referenced\n\n[1. nginx 访问控制之deny allow](https://www.cnblogs.com/yyxianren/p/10837189.html)\n[2. Arcgis Server 默认服务端口号修改方法](https://www.cnblogs.com/tiandi/p/5967929.html)\n[3. 封面图源](https://huadou145.lofter.com/post/205d4db3_1c71e6ba8)","tags":["Nginx","GIS","ArcServer"],"categories":["GIS"]},{"title":"Nexus搭建Maven私服","slug":"67","url":"/2020/07/24/67/","content":"本文主要介绍Sonatype Nexus搭建Maven私服，以及jar包的上传及使用过程,通过使用maven私服，可极大减轻维护多个有相同模块的项目负担。\n\n<!--more-->\n##  环境\n1. Nexus版本：Nexus Repository OSS 3.25\n2. Nexus部署环境: win10 x64\n3. 开发环境：deeepin v20\n3. 项目类型：Spring Cloud 2.x\n\n##  Nexus搭建过程\n\n###  启动\n\n这里我下载的是win版本，通过nexus.exe /run 启动。如果启动成功，可在浏览器中输入http://localhost:8081/查看,然后进行账户初始化即可。\n\n###  创建Repositry\n\n几种Reposity的说明：\n1. maven-central:中央库，默认从https://repo1.maven.org/maven2/拉取jar\n2. maven-releases：私库发行版jar\n3. maven-snapshots：私库快照（调试版本）jar\n4. maven-public:仓库分组，把上面三个仓库组合在一起对外提供服务\n\n这里创建两个maven2(hosted)类型的私库，如omgis-release,omgis-snap,以后把jar推送到这两个库里面，但是，这两个仓库对外是不能public访问的，因此，\n需要在maven-public仓库中引入这两个私有仓库：System-status->Repository->Repositories,找到maven-public,将创建的两个私库添加到maven-public\n的成员中，这样如果有jar推送至私库，在maven-public中就能看到和引用了。\n\n##  将jar包上传到私库中\n\n###  修改项目pom文件\n打开你项目的pom文件，添加如下内容：\n```\n<distributionManagement>\n    <repository>\n        <id>omgis-release</id>\n        <name>Release Repository of omgis</name>\n        <url>http://your ip:8081/repository/omgis-release</url>\n    </repository>\n    <snapshotRepository>\n        <id>omgis-snap</id>\n        <name>Snapshot Repository of omgis</name>\n        <url>http://your ip:8081/repository/omgis-snap/</url>\n    </snapshotRepository>\n</distributionManagement>\n```\n###  添加用户信息\n\n打开你本地maven的配置文件settings.xml,在servers节点加入如下配置:\n```\n<server>\n    <id>omgis</id>\n    <username>admin</username>\n    <password>123456</password>\n</server>\n<server>\n    <id>omgis-snap</id>\n    <username>admin</username>\n    <password>123456</password>\n</server>\n```\n在Intellij idea右侧Maven中，执行maven clean &maven deploy即可将当前模块生成的jar包部署到maven私服中去了，\n现在你可以到maven-public中看下有没有新生成的jar包了。\n\n##  使用私服中的jar\n\n在你项目的pom文件中添加即可\n```\n<repository>\n    <id>omgis</id>\n    <name>omgis repo</name>\n    <url>http://your ip:8081/repository/maven-public/</url>\n    <releases>\n        <enabled>true</enabled>\n    </releases>\n</repository>\n```\n这样在维护多个项目时，就可以把它们通用的部分提取出来，只用维护一个，有更新时，直接上传到私服中去，另一个项目直接引用jar即可。\n\n##  后记\n天哪，这是什么神仙手段，鬼知道我以前同时维护多个项目时更新有多么难受...\n\n\n##  Referenced\n[1.使用Nexus搭建Maven私服](https://www.cnblogs.com/knowledgesea/p/11190579.html)\n[2.Maven私服搭建与使用](http://zhaoyh.com.cn/2020/07/16/Maven%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/)\n[3.封面图源](https://tiezhuzhuzhu923.lofter.com/post/310ff6d7_1c804cbfb)\n","tags":["Nexus","Maven"],"categories":["Devops"]},{"title":"Javascript数组的插入和删除方法","slug":"66","url":"/2020/07/07/66/","content":"本文主要介绍Javascript数组的添加和删除的几个方法。\n<!--more-->\n##  数组的几个方法\n\n###  向数组中添加元素\n\nunshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。\n\npush() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。\n\n###  从数组中删除元素\n\nshift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。\n\npop()方法删除并返回数组的最后一个元素\n\n##  清空数组\n\n可直接设置length的属性为0\n\n##  Referenced\n[1、JavaScript unshift() 方法](https://www.w3school.com.cn/jsref/jsref_shift.asp)\n[2、封面图](https://huadou145.lofter.com/post/205d4db3_1c7474e60)","tags":["JavaScript"],"categories":["前端"]},{"title":"Magento2更新数据库配置","slug":"65","url":"/2020/07/06/65/","content":"本文主要介绍Magento2修改数据库及应用的ip地址。\n\n<!--more-->\n\n##  开发环境\nOS:Ubuntu 18.04\nPHP:7.2\nMagento:2.3.1\n\n##  Magento更换数据库ip\n在magento2的部署路径中找到/app/etc/env.php,找到数据库的相关配置，直接修改即可\n\n##  修改Magento的访问ip\n\n###  修改数据库中的配置\nMagento的访问ip是写入到数据库中的，先找到core_config_data表，然后修改web/unsecure/base_url和web/secure/base_url,改为新的域名或ip即可。\n\n###  更新缓存\n删除magento部署目录下的 /var/cache ，然后使用新地址登录magento管理后台，系统->缓存管理，更新所有相应的缓存。\n\n##  Referenced\n[1、Magento 2数据库配置文件](https://www.howtoing.com/magento-2-database-configuration-file)\n[2、为magento2站点更换访问网址（域名）](https://liujia.anqun.org/index.php/archives/963/)\n[3、封面图](https://alisonmarket.lofter.com/post/2b1789_1c808c676)","tags":["Magento"]},{"title":"ASP.NET WebSite动态编译实现线上快速调试","slug":"64","url":"/2020/06/07/64/","content":"从接触.NET到现在接近10年了，才发现ASP.NET网站项目可以实现c# 代码的动态编译及部署，妈妈再也不用担心我部署接口麻烦了～。\n\n<!--more-->\n\n##  背景\n\n最近在维护一个比较古老的ASP.NET的项目，只支持IE8的那种。项目是直接部署在IIS中的，接口使用的是一般处理程序(.ashx),无需编译，只要修改代码就会自动编译，当时觉得好厉害啊，之前做.NET的时候没有注意过这块内容，因此趁此机会就看下ASP.NET中的网站和Web应用程序的区别。\n\n##  开发环境\n\nOS: Win 10 x64\nIDE: VS 2010\n\n##  ASP.NET网站\n\n1. 可以直接把代码部署在IIS中，这样只要修改代码，代码就会动态编译，自定义的类会被放在App_Code目录中，这个目录在添加类时会自动创建的；\n2. 一个文件出错不影响整个项目；\n\n##  与ASP.NET Web应用程序的区别\n\n相对来讲，ASP.NET Web应用程序可能会更加麻烦一点，它需要重新生成，再部署，而ASP.NET 网站则可直接编辑线上的文件，并且不会影响到其他的文件。\n\n\n##  Referenced\n\n[1、Introduction to Web Application Projects](https://docs.microsoft.com/en-us/previous-versions/aa730880(v=vs.80))\n[2、[ASP.NET]Web网站与Web应用程序区别](https://www.cnblogs.com/wfy680/p/11961305.html)\n","tags":["ASP.NET"],"categories":["语言"]},{"title":"Vue部署Nginx刷新页面404","slug":"63","url":"/2020/06/07/63/","content":"最近在把vuejs项目部署到Nginx去的时候，出现了两个问题：1. 刷新404 2. 菜单处的链接点击没反映。\n\n<!--more-->\n\n##  开发环境\nOS: Deepin V20\n\n##  刷新页面404的问题\n这个是vue-router的mode配置成了history的原因，可以通过在Nginx的配置文件中添加如下内容:\n```\nlocation /{\n...\ntry_files $uri $uri/ /index.html;\n}\n\n```\n\n##  点击菜单进行页面跳转报错\n我这里是静态资源的路径错误，路径中多了一部分当前链接的内容，而不是/static/...,这里通过修改vue.config.js的publicPath的属性来解决。\n\n1. publicPath\n\n这个属性是页面js和css的静态资源路径，如果有需要，可以修改,也可以根据当前环境进行配置，如下：\n```\npublicPath: process.env.NODE_ENV === \"production\" ? \"./\" : \"/\",\n```\n\n2. outputDir\n\n这个属性是打包时生成的路径，可自行定义，也是在vue.config.js中设置。\n\n##  Referenced\n\n[1、Vue路由history模式踩坑记录：nginx配置解决404问题](https://www.cnblogs.com/goloving/p/9170508.html)","tags":["NodeJS","VUE"],"categories":["前端"]},{"title":"CSharp使用log4net记录日志的一次意外","slug":"62","url":"/2020/04/30/62/","content":"本文主要记录一次 在asp.net中使用log4net记录日志 的部署事故。深觉还是祖传代码好啊，就像有些人说不出哪里好，但谁也替代不了。\n<!--more-->\n\n##  运行环境\n\n###  开发环境\nOS:win10 x64\n.net framework 4.0\nvs 2010\nasp.net\n\n###  线上环境\nOS:windows server 2008 r2\n.net framework 4.0\n\n##  安装Log4Net的包\n如果是VS2012以上版本，可以直接使用Nuget包管理器进行安装，VS2010直接去log4net官网下载手动引用即可。\n\n##  Log4Net的初始化\n\nLog4Net的初始化有以下两种方式：在修改AssemblyInfo.cs中初始化、在代码中初始化。\n\n###  修改AssemblyInfo.cs\n\n[assembly: log4net.Config.XmlConfigurator(ConfigFile = \"log4net.config\", ConfigFileExtension = \"config\", Watch = true)]\n\n###  使用代码初始化\n\n这里log4net.config的读取方式同你的应用类型有关，这里是winform类型的应用程序：\n```\nstring path = AppDomain.CurrentDomain.BaseDirectory + \"log4net/log4net.config\";\nlog4net.Config.XmlConfigurator.ConfigureAndWatch(new System.IO.FileInfo(path));\n```\n\n##  添加Log4net.config\n\n可通过vscode创建配置文件，将log4net的配置写入到<configuration>节点内\n\n###  配置一\n\n这段配置了两类日志：Info和Error，全部写到文件中去;\n注意：这段可能有问题，部署到线上时，无法写入变量，但是有记录的，暂不明原因;\n\n```\n<!-- Level的级别，由高到低 --> \n<!-- None > Fatal > ERROR > WARN > DEBUG > INFO > ALL--> \n<!-- 解释：如果level是ERROR，则在cs文件里面调用log4net的info()方法，则不会写入到日志文件中-->\n<log4net>\n  <!--错误日志类-->\n  <logger name=\"logerror\"><!--日志类的名字-->\n    <level value=\"ALL\" /><!--定义记录的日志级别-->\n    <appender-ref ref=\"ErrorAppender\" /><!--记录到哪个介质中去-->\n  </logger>\n  <!--信息日志类-->\n  <logger name=\"loginfo\">\n    <level value=\"ALL\" />\n    <appender-ref ref=\"InfoAppender\" />\n  </logger>\n  <!--错误日志附加介质-->\n  <appender name=\"ErrorAppender\" type=\"log4net.Appender.RollingFileAppender\"><!-- name属性指定其名称,type则是log4net.Appender命名空间的一个类的名称,意思是,指定使用哪种介质-->\n    <param name=\"File\" value=\"Log\\\\LogError\\\\\" /><!--日志输出到exe程序这个相对目录下-->\n    <param name=\"AppendToFile\" value=\"true\" /><!--输出的日志不会覆盖以前的信息-->\n    <param name=\"MaxSizeRollBackups\" value=\"100\" /><!--备份文件的个数-->\n    <param name=\"MaxFileSize\" value=\"10240\" /><!--当个日志文件的最大大小-->\n    <param name=\"StaticLogFileName\" value=\"false\" /><!--是否使用静态文件名-->\n    <param name=\"DatePattern\" value=\"yyyyMMdd&quot;.htm&quot;\" /><!--日志文件名-->\n    <param name=\"RollingStyle\" value=\"Date\" /><!--文件创建的方式，这里是以Date方式创建-->\n    <!--错误日志布局-->\n    <layout type=\"log4net.Layout.PatternLayout\">\n      <param name=\"ConversionPattern\" value=\"&lt;HR COLOR=red&gt;%n异常时间：%d [%t] &lt;BR&gt;%n异常级别：%-5p &lt;BR&gt;%n异 常 类：%c [%x] &lt;BR&gt;%n%m &lt;BR&gt;%n &lt;HR Size=1&gt;\"  />\n    </layout>\n  </appender>\n  <!--信息日志附加介质-->\n  <appender name=\"InfoAppender\" type=\"log4net.Appender.RollingFileAppender\">\n    <param name=\"File\" value=\"Log\\\\LogInfo\\\\\" />\n    <param name=\"AppendToFile\" value=\"true\" />\n    <param name=\"MaxFileSize\" value=\"10240\" />\n    <param name=\"MaxSizeRollBackups\" value=\"100\" />\n    <param name=\"StaticLogFileName\" value=\"false\" />\n    <param name=\"DatePattern\" value=\"yyyyMMdd&quot;.htm&quot;\" />\n    <param name=\"RollingStyle\" value=\"Date\" />\n    <!--信息日志布局-->\n    <layout type=\"log4net.Layout.PatternLayout\">\n      <param name=\"ConversionPattern\" value=\"&lt;HR COLOR=blue&gt;%n日志时间：%d [%t] &lt;BR&gt;%n日志级别：%-5p &lt;BR&gt;%n日 志 类：%c [%x] &lt;BR&gt;%n%m &lt;BR&gt;%n &lt;HR Size=1&gt;\"  />\n    </layout>\n  </appender>\n</log4net>\n```\n对应的帮助类LogHelper.cs\n```\npublic class LogHelper\n    {\n        public static readonly log4net.ILog loginfo = log4net.LogManager.GetLogger(\"loginfo\");//这里的 loginfo 和 log4net.config 里的名字要一样\n        public static readonly log4net.ILog logerror = log4net.LogManager.GetLogger(\"logerror\");//这里的 logerror 和 log4net.config 里的名字要一样\n        public static void WriteLog(string info)\n        {\n            if (loginfo.IsInfoEnabled)\n            {\n                loginfo.Info(info);\n            }\n        }\n\n        public static void WriteLog(string info, Exception ex)\n        {\n            if (logerror.IsErrorEnabled)\n            {\n                logerror.Error(info, ex);\n            }\n        }\n    }\n```\n\n###  配置二\n这段可以正常部署，也是之前项目中使用过的，当时是winform+owin这种形式，有web,有桌面端的项目。\n\n```\n<configSections>\n    <section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler,log4net\"></section>\n  </configSections>\n  <log4net>\n    <root>\n      <level value=\"ALL\"></level>\n    </root>\n    <logger name=\"OneCardRequest\">\n      <level value=\"INFO\" />\n      <appender-ref ref=\"rollingRequestFile\" />\n    </logger>\n    <logger name=\"OneCardResult\">\n      <level value=\"INFO\" />\n      <appender-ref ref=\"rollingResultFile\" />\n    </logger>\n    <logger name=\"OneCardException\">\n      <level value=\"ERROR\" />\n      <appender-ref ref=\"rollingExceptionFile\" />\n    </logger>\n    <logger name=\"InfoLog\">\n      <level value=\"ALL\" />\n      <appender-ref ref=\"rollingInfoFile\" />\n    </logger>\n    <appender name=\"rollingRequestFile\" type=\"log4net.Appender.RollingFileAppender,log4net\" >\n      <param name=\"File\" type=\"\" value=\"Log/Request/\" />\n      <param name=\"AppendToFile\" value=\"true\" />\n      <param name=\"RollingStyle\" value=\"Date\" />\n      <param name=\"DatePattern\" value=\"yyyyMMdd\" />\n      <param name=\"StaticLogFileName\" value=\"false\" />\n      <layout type=\"log4net.Layout.PatternLayout,log4net\">\n        <param name=\"ConversionPattern\" value=\"%n[%d] %c %n%m%n%n\" />\n        <param name=\"Header\" value=\"-----------BEGIN-----------\" />\n        <param name=\"Footer\" value=\"------------END------------\" />\n      </layout>\n    </appender>\n    <appender name=\"rollingResultFile\" type=\"log4net.Appender.RollingFileAppender,log4net\" >\n      <param name=\"File\" type=\"\" value=\"Log/Result/\" />\n      <param name=\"AppendToFile\" value=\"true\" />\n      <param name=\"RollingStyle\" value=\"Date\" />\n      <param name=\"DatePattern\" value=\"yyyyMMdd\" />\n      <param name=\"StaticLogFileName\" value=\"false\" />\n      <layout type=\"log4net.Layout.PatternLayout,log4net\">\n        <param name=\"ConversionPattern\" value=\"%n[%d] %c %n%m%n%n\" />\n        <param name=\"Header\" value=\"-----------BEGIN-----------\" />\n        <param name=\"Footer\" value=\"------------END------------\" />\n      </layout>\n    </appender>\n    <appender name=\"rollingExceptionFile\" type=\"log4net.Appender.RollingFileAppender,log4net\" >\n      <param name=\"File\" type=\"\" value=\"Log/Exception/\" />\n      <param name=\"AppendToFile\" value=\"true\" />\n      <param name=\"RollingStyle\" value=\"Date\" />\n      <param name=\"DatePattern\" value=\"yyyyMMddHH\" />\n      <param name=\"StaticLogFileName\" value=\"false\" />\n      <layout type=\"log4net.Layout.PatternLayout,log4net\">\n        <param name=\"ConversionPattern\" value=\"%n[%d] %c %n%m%n%n\" />\n        <param name=\"Header\" value=\"-----------BEGIN-----------\" />\n        <param name=\"Footer\" value=\"------------END------------\" />\n      </layout>\n    </appender>\n    <appender name=\"rollingInfoFile\" type=\"log4net.Appender.RollingFileAppender,log4net\" >\n      <param name=\"File\" type=\"\" value=\"Log/Info/\" />\n      <param name=\"AppendToFile\" value=\"true\" />\n      <param name=\"RollingStyle\" value=\"Date\" />\n      <param name=\"DatePattern\" value=\"yyyyMMdd\" />\n      <param name=\"StaticLogFileName\" value=\"false\" />\n      <layout type=\"log4net.Layout.PatternLayout,log4net\">\n        <param name=\"ConversionPattern\" value=\"%n[%d] %c %n%m%n%n\" />\n        <param name=\"Header\" value=\"-----------BEGIN-----------\" />\n        <param name=\"Footer\" value=\"------------END------------\" />\n      </layout>\n    </appender>\n  </log4net>\n```\n\n帮助类：\n\n```\npublic class Log4netUtility\n    {\n        public static void initialLog4Net() {\n            //log4net.Config.XmlConfigurator.ConfigureAndWatch(new )            \n            string path = AppDomain.CurrentDomain.BaseDirectory + \"log4net/log4net.config\";\n            log4net.Config.XmlConfigurator.ConfigureAndWatch(new System.IO.FileInfo(path));\n        }\n        public static string Exception(string id, Exception ex, string attachMessage) {\n            string result = string.Empty;\n            //log4net的初始化有两种形式:1.如下 2.写在应用程序集中(见AssemeblyInfo.cs)\n            //log4net.Config.XmlConfigurator.ConfigureAndWatch(new System.IO.FileInfo(\"log4net.config\"));\n            log4net.ILog log = log4net.LogManager.GetLogger(\"OneCardException\");\n            if (!log.IsErrorEnabled)\n                initialLog4Net();                   \n            if (log.IsErrorEnabled) {\n                string strMessage = string.Format(\"RequestID:{0}\\r\\nMesssage:{1}\\r\\nStackTrace:{2}\\r\\nAttachMessage:{3}\", id, ex.Message, ex.StackTrace, attachMessage);\n                log.Error(strMessage);\n                result = strMessage;\n            }\n            log = null;\n            return result;\n        }\n\n        /// <summary>\n        /// 追加一条一卡通请求日志信息\n        /// </summary>\n        /// <param name=\"id\">请求ID</param>\n        /// <param name=\"ip\">请求的IP地址</param>\n        /// <param name=\"datetime\">时间</param>\n        /// <param name=\"strParam\">请求时传入的参数</param>\n        public static void RequestLog(string id, string ip, string datetime, string strParam)\n        {\n            log4net.ILog log = log4net.LogManager.GetLogger(\"OneCardRequest\");\n            if (!log.IsInfoEnabled)\n                initialLog4Net();\n            if (log.IsInfoEnabled)\n            {\n                string strMessage = string.Format(\"RequestID:{0}\\r\\nIP:{1}\\r\\nDateTime:{2}\\r\\nParam:{3}\", id, ip, datetime, strParam);\n                log.Info(strMessage);\n            }\n            log = null;\n        }\n        /// <summary>\n        /// 追加一条一卡通处理结果日志\n        /// </summary>\n        /// <param name=\"id\">请求ID</param>\n        /// <param name=\"datetime\">时间</param>\n        /// <param name=\"strResult\">处理结果</param>\n        public static void ResultLog(string id, string datetime, string strResult)\n        {\n            log4net.ILog log = log4net.LogManager.GetLogger(\"OneCardResult\");\n            if (!log.IsInfoEnabled)\n                initialLog4Net();\n            if (log.IsInfoEnabled)\n            {\n                string strMessage = string.Format(\"RequestID:{0}\\r\\nDateTime:{1}\\r\\nParam:{2}\", id, datetime, strResult);\n                log.Info(strMessage);\n            }\n            log = null;\n        }\n        /// <summary>\n        /// 追加一条普通的日志信息\n        /// </summary>\n        /// <param name=\"message\">日志内容</param>\n        public static void Info(string message)\n        {\n            log4net.ILog log = log4net.LogManager.GetLogger(\"InfoLog\");\n            if (!log.IsInfoEnabled)\n                initialLog4Net();\n            if (log.IsInfoEnabled)\n            {\n                log.Info(message);\n            }\n            log = null;\n        }\n    }\n```\n\n###  配置小结\n\n1. 每个配置文件中都有logger(通常有多个),每个logger有appender属性，其描述了日志的格式、存储方式、更新方式等信息\n\n2. 代码中引用时通过LogManager获取配置文件中定义的logger,通过logger对象调用Info,Error,Debug等方法\n\n##  Reference\n[1. C# 使用log4net记录日志](https://www.cnblogs.com/kliine/p/10950859.html)\n[2. 封面图源](https://huadou145.lofter.com/post/205d4db3_1c8f12e12)","tags":["日志","C"]},{"title":"ASP.NET Web API中处理跨域请求","slug":"60","url":"/2020/04/10/60/","content":"跨域是非常常见的一个问题，本文主要记录ASP.NET Web API中对跨域请求的处理。\n<!--more-->\n\n##  开发环境\nOS: win10\n编译器：visual studio 2019\n\n##  配置web.config允许跨域\n\n在system.webServer节点中添加如下customHeaders,如下：\n```\n<system.webServer>\n<httpProtocol>\n      <customHeaders>\n        <add name=\"Access-Control-Allow-Origin\" value=\"*\" />\n        <add name=\"Access-Control-Allow-Headers\" value=\"Content-Type\" />\n        <add name=\"Access-Control-Allow-Methods\" value=\"GET, POST, PUT, DELETE, OPTIONS\" />\n      </customHeaders>\n    </httpProtocol>\n  </system.webServer>\n```\n其中Access-Control-Allow-Headers表示IIS允许接受的headers的集合，如果请求头中需要添加自定义内容，value需要设置为如下内容:\n```\n<add name=\"Access-Control-Allow-Headers\" value=\"Origin,X-Requested-With,Content-Type,accept,key\" />\n```\n其中key表示请求头中的键。\n\n##  在Global.asax中添加对OPTIONS请求的处理\n\n###  关于OPTIONS请求\n在 CORS 中，可以使用 OPTIONS 方法发起一个预检请求，以检测实际请求是否可以被服务器所接受。预检请求报文中的 Access-Control-Request-Method 首部字段告知服务器实际请求所使用的 HTTP 方法；Access-Control-Request-Headers 首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。\n\n之前大概2017年我写跨域的解决方案的时候是没有OPTIONS请求的，但现在OPTIONS请求已经成了规范，即满足某些特定条件下，浏览器必须要首先使用OPTIONS发放发送一个预检请求到服务器。可参考MDN中的[HTTP访问控制](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)中对此部分的描述。\n\n###  对所有的options请求返回\n在Global.asax中添加如下内容：\n```\n protected void Application_BeginRequest(object sender, EventArgs e)\n        {\n            var req = System.Web.HttpContext.Current.Request;\n            if (req.HttpMethod == \"OPTIONS\")//过滤options请求，用于js跨域\n            {\n                Response.StatusCode = 200;\n                Response.SubStatusCode = 200;\n                Response.End();\n            }\n        }\n```\n\n##  Reference\n[1、Asp.Net WebApi对js POST带参数跨域请求的支持方案](https://www.cnblogs.com/tlzzu/p/4365112.html)\n[2、OPTIONS-HTTP|MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS)\n[3、什么时候会发送options请求](http://www.fed123.com/javascriptnodejs/4798.html)\n[4、封面图源](https://huadou145.lofter.com/post/205d4db3_1c8bfba2e)","tags":["ASP.NET","CORS"]},{"title":"Nginx中的安全配置","slug":"58","url":"/2020/04/10/58/","content":"本文主要介绍Nginx中的一些安全配置。\n\n<!--more-->\n\n##  屏蔽某些访问链接\n如所有包含有feed的链接都会直接返回403\n```\nlocation /feed {\ndeny all;\n}\n```\n\n##  通过UA禁止某些非正常的客户端的访问\n这里主要禁止爬虫、httpclient等的访问。\n在Nginx安装目录新建一个agent_deny.conf文件，添加如下内容:\n```\nif ($http_user_agent ~* (Scrapy|masscan|Curl|HttpClient|fasthttp)) {\n     return 403;\n}\n# 禁止指定UA及UA为空的访问\nif ($http_user_agent ~ \"zgrab|Go-http-client|Dataprovider.com|bing|Wappalyzer|libwww-perl|bingbot|WinHttp|WebZIP|FetchURL|node-superagent|java/|FeedDemon|Jullo|JikeSpider|Indy Library|Alexa Toolbar|AskTbFXTV|AhrefsBot|CrawlDaddy|Java|Feedly|Apache-HttpAsyncClient|UniversalFeedParser|ApacheBench|Microsoft URL Control|Swiftbot|ZmEu|oBot|jaunty|Python-urllib|lightDeckReports Bot|YYSpider|DigExt|HttpClient|MJ12bot|heritrix|Ezooms|BOT/0.1|YandexBot|FlightDeckReports|Linguee Bot|^$\" ) {\n     return 403;\n}\n\nif ($http_user_agent ~* \"Googlebot|Googlebot-Mobile|Googlebot-Image|Mediapartners-Google|Adsbot-Google|Feedfetcher-Google|Yahoo! Slurp|Yahoo! Slurp China|YoudaoBot|MSNBot|ia_archiver|Tomato Bot\")\n{\nreturn 403;\n}\nif ($http_user_agent ~* \"ApiTool\") {return 403;}\nif ($http_user_agent ~* \"python\") {return 403;}\nif ($http_user_agent ~* \"bingbot\") {return 403;}\nif ($http_user_agent ~* \"Nimbostratus-Bot\") {return 403;}\nif ($http_user_agent ~* \"Go-Ahead-Got-It\") { return 403; }\nif ($http_user_agent ~* \"GetWeb!\") { return 403; }\nif ($http_user_agent ~* \"Go!Zilla\") { return 403; }\nif ($http_user_agent ~* \"Download Demon\") { return 403; }\nif ($http_user_agent ~* \"Indy Library\") { return 403; }\nif ($http_user_agent ~* \"libwww-perl\") { return 403; }\nif ($http_user_agent ~* \"Nmap Scripting Engine\") { return 403; }\nif ($http_user_agent ~* \"~17ce.com\") { return 403; }\nif ($http_user_agent ~* \"WebBench*\") { return 403; }\n# if ($http_user_agent ~* \"spider\") { return 403; } # 这个会影响国内某些搜索引擎爬虫，比如：搜狗\n\n# 禁止非GET|HEAD|POST方式的抓取\nif ($request_method !~ ^(GET|HEAD|POST)$) {\n    return 403;\n}\n```\n然后在server内添加 include ../agent_deny.conf即可，这里输入具体的文件的路径。\n\n##  屏蔽某些ip\n\n在nginx.conf同级目录下创建文件blocksip.conf，在http节点增加以下配置（也可以设置在server节点对单个网站起作用，或location节点只针对特定访问路径的限制）\n```\ninclude blocksip.conf;\n```\nblockip.conf中的内容如下：\n```\ndeny xxx;\nallow xxx;\ndeny all; \n```\n\n##  隐藏X-Powerer\n在http下添加以下内容:\n```\nfastcgi_hide_header X-Powered-By\nproxy_hide_header X-Powered-By\n```\n\n##  响应头配置\n```\n# 减少点击劫持\nadd_header X-Frame-Options SAMEORIGIN;//也可设置为DENY \n# 禁止服务器自动解析资源类型\nadd_header X-Content-Type-Options nosniff;\n# 防XSS攻击\nadd_header X-Xss-Protection 1; mode=block;\n```\n\n##  https配置\n```\nssl_certificate   ../cert/192.168.10.106.pem;\nssl_certificate_key  ../cert/192.168.10.106-key.pem;\nssl_session_timeout 5m;\nssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\nssl_protocols TLSv1 TLSv1.1 TLSv1.2;\nssl_prefer_server_ciphers on;\n```\n\n##  增强cookie的安全性\n```\n# 只支持 proxy 模式下设置，SameSite 不需要可删除，如果想更安全可以把 SameSite 设置为 Strict\nproxy_cookie_path / \"/; httponly; secure; SameSite=Lax\";\n```\n\n##  80自动重定向至443\nserver节点下添加：\n```\nlisten 80;\nserver_name xxx.xxx.xx; # 你的域名\nrewrite ^(.*)$ https://${server_name}$1 permanent;\n```\n\n##  Nginx中IF语句的AND OR等多重判断\nnginx的配置中不支持if条件的逻辑与／逻辑或运算 ，并且不支持if的嵌套语法，我们可以用变量的方式来实现：\n```\nset $flag 0;\nif ($host != 'www.imfeng.com') {\n    set $flag \"${flag}1\";\n}\nif ($http_user_agent != 'spider') {\n    set $flag \"${flag}2\";\n}\nif ($flag = \"012\") {\n    rewrite ^/(.*)$ http://www.imfeng.com/$1 permanent;\n}\n```\n\n##  Reference\n[1、nginx常用配置系列-HTTPS配置](https://www.cnblogs.com/ieinstein/p/7083551.html?utm_source=itdadao&utm_medium=referral)\n[2、用 Nginx 自动给 Cookie 增加 Secure 和 HttpOnly](https://blog.cat73.org/20170802/2017080201.nginx-cookie-sucure/)\n[3、NGINX实现IF语句里的AND，OR多重判断](https://www.cnblogs.com/aguncn/p/4179035.html)\n[4、通过监控Nginx日志来实时屏蔽高频恶意访问的IP](https://www.cnblogs.com/gouyg/p/10632243.html)\n[4、封面图源](https://huadou145.lofter.com/post/205d4db3_1c8bfba2e)","tags":["Nginx","安全"],"categories":["应用安全"]},{"title":"Ubuntu18.04配置深度学习环境","slug":"56","url":"/2020/04/02/56/","content":"这篇文章主要记录Ubuntu18.04.2下新配置深度学习环境的过程。\n<!--more-->\n##  软硬件环境\nOS：Ubuntu 18.04.2\nCUDA: 10.0\n\n##  Ubuntuk开机没有系统选择界面直接进入系统\n修改：/etc/default/grub文件\n调整完之后：\n```\nupdate-grub\n```\n\n固件错误Possible missing firmware解决办法\nhttps://www.cnblogs.com/magikos/p/Possible-missing-firmware.html\n\nlinux ubuntu18.04 update-initramfs -u提示The initramfs will attempt to resume from /dev/nvme0n1p3\n\nhttps://blog.csdn.net/qxqxqzzz/article/details/112025423\n\ncv2.rectangle的一点小坑\nhttps://www.freesion.com/article/99031345965/\n\n详解报错[zmq.error.ZMQError: Operation cannot be accomplished in current state]\nhttps://blog.csdn.net/ybdesire/article/details/81435291\n\n\n##  N卡驱动Ubuntu卡死的情况\n修改启动配置，在系统启动选择界面中，按e，编辑启动项，\n然后在quiet splash后面加入nomodeset，点击F10即可。\n\n\n##  更换为国内源\n先备份当前源文件\n```\nmv /etc/apt/sources.list /etc/apt/sourses.list.backup\n```\n新增及编辑\n```\nsudo gedit /etc/apt/sources.list\n```\n替换为阿里源，写入如下内容：\n```\ndeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\n```\n\n完成之后，执行apt update\n\n参考：[Ubuntu18.04更换国内源](https://www.bbsmax.com/A/obzbMrKBdE/)\n\n##  安装搜狗输入法\n1. 先下载并安装搜狗输入法，之后，在设置->区域和语言->管理已安装的语言\n2. 键盘输入法系统选择fcitx即可(如果没有，等会弹出语言支持的时候根据提示安装缺少的语言包即可)\n3. 选择完毕之后重启系统\n\n##  安装Navida显卡驱动\n\n###  删除自带的显卡驱动并禁用\nsudo -s\napt-get purge nvidia*\nvim /etc/modprobe.d/blacklist-nouveau.conf\n```\nblacklist nouveau\noptions nouveau modeset=0\n```\nupdate-initramfs -u\n\n重启系统：reboot\n\n###  安装navida显卡驱动\nadd-apt-repository ppa:graphics-drivers/ppa\napt-get update\n列出可安装的显卡驱动：\nubuntu-drivers devices \napt-get install nvidia-driver-440\nreboot\n\n###  检测是否安装成功\n```\nsudo nvidia-smi\nwatch -n 1 -d nvidia-smi //实时更新\nsudo nvidia-settings\n```\n\n\n##  安装cuda(深度学习使用)\n\n###  1. 安装依赖项：\napt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev\n\n###  2. 下载cuda安装包：cuda_10.0.130_410.48_linux.run\n\nhttps://developer.nvidia.com/cuda-10.0-download-archive?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=1804&target_type=runfilelocal\n\n这里cuda的安装位置为：/usr/local/cuda-10.0\n###  3. 配置环境变量:\nvi /etc/profile\n添加一下内容：\n```\nexport PATH=/usr/local/cuda-10.0/bin${PATH:+:${PATH}}  \nexport LD_LIBRARY_PATH=/usr/local/cuda-10.0/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}\n```\n保存：source /etc/profile\n\n###  4. 测试cuda是否安装成功\n```\n# 第一步，进入例子文件\ncd /usr/local/cuda-10.0/samples/1_Utilities/deviceQuery\n# 第二步，执行make命令\nsudo make\n# 第三步\n./deviceQuery\n```\n如果结果有GPU的信息，说明安装成功。\n\n###  4. 安装cudnn\n直接下载cudnn的安装包安装即可\n\n##  升级CUDA版本\n\n这里是从CUDA10.0的版本升级到10.2,安装10.2之前,要先吧CUDA10.0以及nvidia driver卸载掉,否则无法安装.\n###  CUDA的卸载\n```\ncd /usr/local/cuda/bin\nsudo ./uninstall_cuda_10.0.pl\n```\n\n###  nvidia驱动卸载\n\n参考[删除自带的显卡驱动并禁用](###  删除自带的显卡驱动并禁用)\n\n###  安装CUDA\n\n**注意**:CUDA10.2中已经自带了nvidia的驱动,直接安装就可以了,环境变量的配置同之前的保持一致即可.\n\n##  其他问题\n###  应用程序启动器“XXX.desktop”还没有被标记为可信任的问题\n在terminal中，输入以下命令，以root权限打开文件管理窗口\nsudo nautilus\n然后找到*.desktop图标，选择所有者为root,勾选允许作为程序执行文件，关闭终端，重新打开.desktop信任即可。\n\n##  Reference\n[1.Ubuntu18.04深度学习GPU环境配置](https://blog.csdn.net/weixin_41863685/article/details/80303963)\n[2.封面图源](https://huadou145.lofter.com/post/205d4db3_1c8a36320)\n\n\n\n","tags":["Ubuntu","系统安装配置","深度学习"],"categories":["深度学习"]},{"title":"Nodejs前端项目搭建及更换渲染页面为html","slug":"54","url":"/2020/03/27/54/","content":"之前使用nodejs做了服务端的接口，这篇文章作为姊妹篇，主要介绍NodeJS前端项目的创建。\n<!--more-->\n##  软硬件环境\n1. OS:win10 ×64\n2. NodeJS: v10.15.3\n3. npm : 6.4.1\n\n##  前端项目创建\n1.  安装express及express-generator\n```\nnpm install express -g\nnpm install express-generator -g\n```\n2. 创建项目\n```\nexpress app_name\ncd app_name\nnpm install\nnpm start\n```\n如果中间没有什么错误，那在浏览器中输入http://localhost:3000/ 就可以访问你新创建的项目了。\n\n##  将默认的模板引擎改为ejs(html)\nexpress默认使用的是jade，页面后缀为.jad,对于我这种临时使用下nodejs写点页面的人来说完全不熟悉，因此改用使用html的ejs作为其模板引擎。\n1. 安装ejs\n```\nnpm install ejs\n```\n2. 在app.js中配置ejs\n将express-generaotr自动生成的部分\n```\napp.set('view engine', 'jade');\n```\n替换为：\n```\nvar ejs = require('ejs');\napp.engine('.html',ejs.__express);\napp.set('view engine', 'html')\n```\n到这里应该就可以了，直接在views内写自己的html即可，路由可直接在routes中的index.js进行配置。\n\n##  Referenced\n[1、NodeJS Express view engine支持渲染html文件](http://www.doocr.com/articles/58e670f1011f0331dcd8d613)\n[2、封面图源](https://lyla7784.lofter.com/post/30a15a3d_1c8923399)\n","tags":["NodeJS"],"categories":["前端"]},{"title":"Deepin新装问题记录","slug":"52","url":"/2020/03/25/52/","content":"又把我的小米本从Manjaro换回deepin了，毕竟还是要生活的。\n<!--more-->\n##  软硬件环境\n硬件：小米笔记本Air\n操作系统：deepin 15.11\n\n##  网速慢\n\nsudo deepin-editor /etc/modprobe.d/iwlwifi.conf\n\noptions iwlwifi 11n_disable=1 bt_coex_active=0 power_save=0 swcrypto=1”中的“11n_disable=1”修改为“11n_disable=0”\n\n参考：https://www.jb51.net/LINUXjishu/699476.html\n\n##  去掉启动5s的倒计时\n打开：\n/etc/default/grub\n修改\nGRUB_TIMEOUT=0\n执行\nupdate-grub\n\n参考：https://jingyan.baidu.com/article/02027811429bb41bcc9ce521.html\n\n##  intel cpu占用过高(作用不明显)\nsudo  vim  /boot/grub/grub.cfg\n\n然后在ro quiet splash的后面先小空格然后加上以下行：\n\nintel_pstate=disable\nhttp://8u.hn.cn/linuxjc/12636.html\n\n##  换源\nsudo vim /etc/apt/sources.list\nmirrors.tuna.tsinghua.edu.cn\n\n##  TSC_DEADLINE disabled due to Errata; please update microcode to version: 0x52 (or later)\n启动时显示一段这样的内容，执行如下命令：\n```\nsudo apt-get install intel-microcode\n```\n或者：\n```\nsudo apt-get install amd64-microcode\n```\n参考：https://stackoverflow.com/questions/48036877/debian-firmware-bug-tsc-deadline-disabled-due-to-errataer\n\n##  Deepin V20 搜狗输入法\n```\nsudo apt-get install sogoupinyin\n```\n然后注销再重新登录即可。\n\n##  Deepin Terminal超时\n在使用Deepin自带的Terminal连接服务器时总是出现超时导致terminal卡死的问题，这是deepin terminal自身的问题，可以在 /etc/ssh/ssh_config文件中添加如下内容：\n```\nServerAliveInterval 30\nServerAliveCountMax 60\n```\n参考：https://bbs.deepin.org/forum.php?mod=viewthread&tid=180770\n\n##  Referenced\n[1、封面图源](https://huadou145.lofter.com/post/205d4db3_1c8782df2)","tags":["Linux","Deepin"],"categories":["Linux"]},{"title":"NodeJS+Turfjs实现缓冲区分析接口","slug":"48","url":"/2020/03/25/48/","content":"为了使用turfjs中的缓冲区工具，需要在c# 中调用turfjs,考虑到涉及包的引用，可能会比较复杂，故采用nodejs中调用turfjs做服务，通过服务的方式在c# 中调用。\n<!--more-->\n##  操作环境\n**OS:**win10\n**NodeJS:**12.16.1\n**开发工具:**Visual studio 2019\n**package.json**\n\n```\n\"dependencies\": {\n    \"body-parser\": \"^1.19.0\",\n    \"express\": \"^4.17.1\",\n    \"@turf/turf\": \"^5.1.6\",\n  }\n```\n\n##   NodeJS配置全局淘宝镜像\n```\nnpm config set registry https://registry.npm.taobao.org\n```\n检测是否配置成功\n```\nnpm info express\n```\n\n##  使用Express\nExpress 是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架。\n安装\n```\nnpm install express\n```\n###  基本配置：\n```\nvar express = require('express');\nvar app = express();\nvar port = process.env.PORT || 8080;\n\nvar server = app.listen(port, function () {\n    var host = server.address().address;\n    var port = server.address().port;\n    console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n})\n```\n\n###  创建Get接口\n```\napp.get('/all',function(req,res){\n    res.send(\"nodejs express...\");\n})\n```\n\n###  创建Post接口\n这里要注意的是，Request Payload 是数据流类型的，所以需要监听 data 事件来获取数据，最后拼接出POST信息：\n```\napp.post('/postRoomInfo', (req, res) => {\n    console.log(\"请求体：\" + req.body);//此处会输出undefined\n    var str = \"\";\n    req.on(\"data\", function (chunk) {\n        str += chunk\n    })\n    req.on(\"end\", function () {\n        console.log(\"请求内容:\"+str);//此时会输出请求体的完整内容\n        res.send('ok');\n    })\n})\n```\n或者直接使用express的中间件body-parser，这样就可以直接获取请求的参数\n\n###  使用body-parser\n配置body-parser\n```\nvar bodyParser = require('body-parser');\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded({ extended: true }))\n```\npost接口：\n```\napp.post('/buffer', function (req, res) {    \n\tvar geoType = req.body.geoType;\n    var geoData = req.body.geoData;\n})\n```\n这样就可以直接获取到请求体中的参数了，Ajax请求如下：\n```\n\t\t$.ajax({\n\t\t\turl:\"xxx/buffer\",\n\t\t\tdata:{\n\t\t\t\t\"geoType\":\"polyline\",\n\t\t\t\t\"bufferWidth\":0.2\n\t\t\t},\n\t\t\ttype: \"post\",\n\t\t\tcontentType:\"application/x-www-form-urlencoded\",\n\t\t\tsuccess:function(result){\n\t\t\t\t\n\t\t\t}\n\t\t});\n```\n###  调用turfjs中的缓冲区分析工具\n1. 添加引用\n```\nvar turf = require('@turf/turf')\n```\n2. 使用缓冲区分析工具\n然后直接使用turf的buffer方法即可：如下\n```\npoint = turf.point(JSON.parse(geoData));\nvar buffered = turf.buffer(point, bufferWidth, { units: 'kilometers' });\n```\n\n\n##  nodejs express跨域问题\n响应头中添加\n```\nres.header(\"Access-Control-Allow-Origin\", \"*\");\nres.header(\"Access-Control-Allow-Headers\", \"Content-Type,Access-Token\");\nres.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\");\n```\n##  Referenced\n[1、nodejs 实现跨域](https://www.cnblogs.com/tengrl/p/10729277.html)\n[2、nodeJs设计GET、POST接口](https://blog.csdn.net/u012925833/article/details/86738913)\n[3、nodejs中常见的接口定义（get、post）](https://blog.csdn.net/boonyaxnn/article/details/91394702)\n[4、nodejs的POST两种type类型提交（原生）](https://www.cnblogs.com/xy404/p/7344805.html)\n[5、openlayers+turf.js实现缓冲区的绘制](https://blog.csdn.net/gis_zzu/article/details/102812294)\n[6、封面图源](https://huadou145.lofter.com/post/205d4db3_1c84a2eba)\n","tags":["NodeJS","缓冲区分析","TurfJS"],"categories":["前端"]},{"title":"Tornado创建websocket并实时推送数据到前台","slug":"46","url":"/2020/03/13/46/","content":"本文主要记录使用tornado创建websocket服务，并实时向前端推送数据的过程,其中推送的数据为后台耗时任务的处理结果.\n<!--more-->\n##  运行环境\nOS:Ubuntu 18.04  \n开发工具:Vs code\nTornado:6.0.3\nPython:3.7.4 \n\n##  Tornado简介\n```\nTornado是一种 Web 服务器软件的开源版本。Tornado 和主流Web 服务器框架（包括大多数 Python 的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。\n得利于其非阻塞的方式和对epoll的运用，Tornado 每秒可以处理数以千计的连接，因此 Tornado 是实时 Web 服务的一个 理想框架。【百度百科】\n```\n\n##  创建简单的Rest服务\n###  安装tornado\n```\npip install tornado -i https://mirrors.aliyun.com/pypi/simple/\n```\n###  创建服务\n这里创建了一个支持get、post、options请求的服务，请求地址：/videoservice/rest/index\n```\nclass IndexHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Hello world\")\n    def post(self):\n        req= json.loads(self.request.body)\n        print('记录编号:'+str(req['rid']))\n        self.write(str(req[\"rid\"]))\n    def options(self):\n        self.set_status(204)\n        self.finish()\n\nclass Application(tornado.web.Application):\n    def __init__(self):\n        handlers = [\n            (r'/videoservice/rest/index', IndexHandler)\n        ]\n        tornado.web.Application.__init__(self, handlers,autoreload=False, debug=False)\nif __name__ == \"__main__\":\n    app = Application()\n    app.listen(8866)  \n    tornado.ioloop.IOLoop.current().start()\n```\n\n##  创建多进程/多线程的Http服务\n有时候，我们需要接口直接返回数据，但服务端继续执行一些耗时的应用，此时可以采用线程池的方式实现，当一个现成阻塞在时，其他线程继续执行。\n\n```\nimport tornado.gen\nfrom tornado.concurrent import run_on_executor\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass VideoAnalyseStartHandler(tornado.web.RequestHandler):\n    executor = ThreadPoolExecutor(20)\n    @tornado.gen.coroutine\n    def post(self):\n        req= json.loads(self.request.body)\n        yield self.block_task(result_queue,last_image_id)\n        self.write(str(req['rid']))\n\n    @run_on_executor\n    def block_task(self,result_queue,last_image_id):\n        print('block task')\n        vAnaylyse=VAnalyseSocket(result_queue,last_image_id)\n        vAnaylyse.start({\"id\":\"3678f935-5916-4b30-8d2a-11bcc8ef0f63\"})\n```\n这里的耗时操作在block_task中完成，在post中返回数据之后，如果block_task没有返回数据，会继续执行block_task中的工作，此线程(这里到底是线程还是进程表述的可能不准确，但应该是线程)包含其启动的子线程的任务都会继续执行执行。\n\n**其他说明**:  \n\n1.修饰符@run_on_executor。这个修饰符将同步函数改造为在executor（这里是线程池）上运行的异步函数，内部实现是将被修饰的函数submit到executor，返回一个Future对象。\n\n2.修饰符@tornado.gen.coroutine。被这个修饰符修饰的函数，是一个以同步函数方式编写的异步函数。原本通过callback方式编写的异步代码，有了这个修饰符，可以通过yield一个Future的方式来写。被修饰的函数在yield了一个Future对象后将会被挂起，Future对象的结果返回后继续执行。\n\n##  Websocket实时向前端发送数据\n\n###  创建基本的websocket\n\n在handlers中添加：\n```\n(r'/videoservice/ws', ConnectHandler)\n```\n创建ConnectHandler\n```\nclass ProStatus():\n    connector = {}  # 记录当前连接的user\n\n    def user_connect(self, user):\n        if user not in self.connector:\n            self.connector[user] = set()\n\n    def user_remove(self, user):\n        # self.connector.remove(user)\n        self.connector.pop(user)\n\n    def trigger(self, message):\n        ''' 向所有被记录的客户端推送最新内容 '''\n        for user in self.connector:\n            user.write_message(message)\nclass ConnectHandler(tornado.websocket.WebSocketHandler):\n    def check_origin(self,t):\n        '''重写同源检查 解决跨域问题'''\n        return True\n\n    def open(self):\n        '''新的websocket连接后被调动'''\n        ProStatus().user_connect(self) # 用户连接后记录\n        self.write_message('Welcome')\n\n    def on_close(self):\n        '''websocket连接关闭后被调用'''\n        ProStatus().user_remove(self)  # 断开连接后remove\n\n    def on_message(self, message):\n        '''接收到客户端消息时被调用'''\n        self.write_message('new message :' + message)\n```\n这样一个基本的websocket服务就创建完成了，然后创建前端页面：\n```\n<!DOCTYPE HTML>\n<html>\n   <head>\n   <meta charset=\"utf-8\">\n   <title>websocket的简单使用</title>\n    \n      <script type=\"text/javascript\">\n         function WebSocketTest()\n         {\n            if (\"WebSocket\" in window)\n            {\n               //alert(\"您的浏览器支持 WebSocket!\");\n               \n               // 打开一个 web socket\n               var ws = new WebSocket(\"ws://127.0.0.1:8866/ws\");\n                \n               ws.onopen = function()\n               {\n                  // Web Socket 已连接上，使用 send() 方法发送数据\n                  ws.send(\"发送数据\");\n                  console.log('ws onopen')\n               };\n                \n               ws.onmessage = function (evt) \n               { \n                  var received_msg = evt.data;\n                  console.log('收到数据:'+received_msg)\n               };\n                \n               ws.onclose = function()\n               { \n                  // 关闭 websocket\n                  console.log(\"连接已关闭...\"); \n               };\n            }\n            \n            else\n            {\n               // 浏览器不支持 WebSocket\n               alert(\"您的浏览器不支持 WebSocket!\");\n            }\n         }\n      </script>\n        \n   </head>\n   <body>\n   \n      <div id=\"sse\">\n         <a href=\"javascript:WebSocketTest()\">运行 WebSocket</a>\n      </div>\n      \n   </body>\n</html>\n```\n如果后端有消息发送回来，直接在ws.onmessage中进行处理，另外如果websocket长期无数据发送，连接可能会被自动关闭，需要使用心跳检测保持一直连接。\n\n###  websocket实时向前端推送数据\n基本的websocket完成之后，我们接下来就可以考虑如何实时向前端推送数据了，推送数据这里肯定是要在主线程中进行的,由于前面我们的耗时操作在子线程中进行，那我们的数据直接通过调用ProStatus().trigger()就发送到前端的。\n\n这里参考了[Tornado Websocket + Redis ：实现“填鸭式”推送](https://www.jianshu.com/p/36d3d3b759ad),通过子线程中调用rest服务，来实现实时向websocket推送数据，也就是我们在章节：创建多进程/多线程的Http服务 中的block_task中，还需要再单独创建一个子线程，在此线程中定时调用rest服务，实现数据的推送。\n\n```\nfrom tornado import ioloop, web, websocket, httpclient\n\nclass sendMsgTools(threading.Thread):\n    def __init__(self, result_queue,last_img_id):\n        threading.Thread.__init__(self, name='sendMsgTools')\n        self.proc_result=result_queue\n        self.last_image_id=last_img_id\n         \n    def run(self) -> None:\n        while True:\n            try:\n                out_msg = self.proc_result.get()\n                img_id=out_msg['id']\n                img_data=out_msg['img']\n                # ProStatus().trigger(str(img_id))\n                url = \"http://127.0.0.1:8866/videoservice/rest/sendMsg\"\n                data = {\"id\": img_id,\"img\":img_data}\n                print('sendMsgTools:'+str(data[\"id\"]))\n                http_request = httpclient.HTTPRequest(url, method=\"POST\",\n                                                    body=json.dumps(data))\n                http_client = httpclient.HTTPClient()\n                http_client.fetch(http_request)\n\n                if img_id == self.last_image_id:\n                    break\n            except Exception as e:\n                print(traceback.format_exc())\n\n```\n\nblock_task中内容如下：\n```\n@run_on_executor\n    def block_task(self,result_queue,last_image_id):\n        smTools=sendMsgTools(result_queue,last_image_id)\n        smTools.start()\n```\n\n这里和另一个耗时操作用的是一个队列Queue,按引用传递，故耗时操作做修改了Queue，sendMsgTools这里可以实时获取到数据更新。\n然后在前端调用时，先和websocket建立连接，之后调用执行耗时任务的接口，就基本能够做到websocket实时向前端推送数据了。\n\n###  前端发起post请求\n前端页面使用了vue，故post请求这里使用axios来发送，\n```\naxios.post('http://127.0.0.1:8088/videoservice/rest/video/start', {\n                        \"rid\": \"3678f935-5916-4b30-8d2a-11bcc8ef0f63\"\n                    })\n                    .then(resp => {\n                        console.log(resp.data);\n                    }).catch(err => {\n                        console.log('请求失败：' + err.status + ',' + err.statusText);\n                    })\n```\n\n##  其他问题：\n###  tornado跨域问题\n创建一个BaseHandler，然后其他Handler继承此handler即可\n\n##  Referenced\n[1、高性能web服务器框架Tornado简单实现restful接口及开发实例](https://www.jb51.net/article/52209.htm)\n[2、Tornado实现多进程/多线程的HTTP服务详解](https://www.jb51.net/article/166225.htm)\n[3、Tornado Websocket + Redis ：实现“填鸭式”推送](https://www.jianshu.com/p/36d3d3b759ad)\n[4、vue发送ajax请求详解](https://www.jb51.net/article/148485.htm)\n[5、tornado 添加请求头进行允许跨域](https://www.cnblogs.com/tiger666/articles/7155156.html)\n[5、封面图源](https://huadou145.lofter.com/post/205d4db3_1c88691ff)","tags":["Tornado","Python","Websocket"],"categories":["Python"]},{"title":"Ubuntu18.04安装过程卡死的问题处理方案","slug":"45","url":"/2020/02/26/45/","content":"最近在安装Ubuntu的过程中总是出现卡死的情况，具体表现为鼠标能够移动但不能点击或者完全卡死的情况，本文则主要记录这种情况的处理过程。\n<!--more-->\n##  环境\nwin10+Ubuntu18.04\n显卡：GTX 960M\nEasyBCD\n\n##  背景\n在Universal USB Installer做好Ubuntu18.04的系统启动盘之后，进入Ubuntu的安装界面之后，总是出现卡死的情况。之后查到是由于Nvida显卡的问题，启动Ubuntu的安装程序时不加载显卡就可以了，也就是在启动项中加入nomodeset参数。\n\n具体操作是进入有以下选项的界面时：\n```\nTry Ubuntu\nInstall Ubuntu\n...\n```\n按e,然后在linux那行参数尾部加nomodeset,并删除前面的---,然后按F10进入安装界面，可查看文章底部的引用2。\n但我这里报错参数未对齐之类的错误，故未采用此种方法，而是使用了无U盘安装Ubuntu\n\n##  Win10下无U盘安装Ubuntu\n###  EasyBCD设置NeoGrub引导\n注意：这里启动时win10不能是UEFI这种模式启动，否则NeoGrub这里的安装按钮可能不可用。\n安装完成之后，点击配置，会打开一个文本，然后输入以下内容：\n```\ntitle Install Ubuntu \nroot (hd0,0) \nkernel (hd0,0)/vmlinuz.efi boot=casper iso-scan/filename=/ubuntu-18.04-desktop-amd64.iso ro quiet splash nomodeset locale=zh_CN.UTF-8 \ninitrd (hd0,0)/initrd.lz\n```\n这里的hd0,是硬盘的序号，可以在windows的磁盘管理那里看到，后面的0是分区的序号。  \nvmlinuz 和initrd文件在你的ubuntu.iso镜像的casper目录中，复制出来即可。由于ubuntu18.04的镜像中这两个文件是没有后缀的，这里需要自行为复制出来的两个文件添加后缀。\n\n然后重启选择NeoGrub引导加载器就可以了，后面安装过程基本不会出现卡死的情况了。具体安装过程可以参考文章底部的引用3。\n\n##  Referenced\n[1、nomodeset的作用](https://www.douban.com/note/343152353/)\n[2、安装ubuntu时黑屏三种解决办法](https://blog.csdn.net/cheneykl/article/details/79111618)\n[3、在已安装win10环境中利用EasyBCD引导安装Ubuntu18.04](https://blog.csdn.net/reasonss/article/details/80537475)\n[4、封面图源](https://huadou145.lofter.com/post/205d4db3_1c81c6e8f)\n\n","tags":["Ubuntu"],"categories":["Linux"]},{"title":"Activiti工作流引擎","slug":"43","url":"/2020/02/20/43/","content":"关于工作流引擎之前也陆陆续续看了点东西，但总感觉还差点东西，对于相关概念理解的不够透彻。这篇文章中就好好的Activiti中的相关概念、数据的传递方式等做个总结。\n<!--more-->\n##  软件及开发环境\nActiviti 6.x  \nSpring Boot 2.x  \n##  工作流的应用范围\n简单来说，当涉及到表单的逐级流转，多个角色的审批的时候，就需要用到工作流了，最常见的也就是OA系统。\n##  Activiti中的几个概念\n\n###  互斥网关(ExclusiveGateWay)\n也叫排他网关，由排他网关流出的连线(SequenceFlow),都有个conditionExpression元素，在内部维护返回boolean类型的决策结果；\nconditionExpression的写法如下:\n```\n${hrVerify}\n${!hrVerify}\n${money>=500}、\n${money>=500 && money <=1000}\n```\n\n当流程执行到排他网关时，流程引擎会自动检索网关出口，从上到下检索如果发现第一条决策结果为true或者没有设置条件的(默认为成立)，则流出；\n对于互斥网关而言，其流出的SequenceFlow至少有两条；\n如果没有任何一个出口符合条件，则抛出异常。\n\n\n###  用户任务(userTask)\n用户任务的处理人有三种：\n1、某个人 ——>设置Assiginee属性\n2、某群人(多个具体的人) ——>设置Candidate users属性\n3、某类人(角色)——>设置Candidate groups属性\n\n一般我们不直接指定具体的人，使用流程变量，即设置Assiginee的属性值为${applyUserId}，在代码中：\n```\nMap<String, Object> variables = new HashMap<String, Object>();\nvariables.put(\"applyUserId\", \"张三\");\nProcessInstance pi = processEngine.getRuntimeService().startProcessInstanceByKey(\"taskProcess\",variables);\n```\n即代表张三启动了一个流程实例。\n另外也可以使用类来设置流程的发起人，如下：\n```\npublic class TaskListenerImpl implements TaskListener {\n\n\t/**指定个人任务和组任务的办理人*/\n\t@Override\n\tpublic void notify(DelegateTask delegateTask) {\n\t\tString userId1 = \"孙悟空\";\n\t\tString userId2 = \"猪八戒\";\n\t\t//指定组任务\n\t\tdelegateTask.addCandidateUser(userId1);\n\t\tdelegateTask.addCandidateUser(userId2);\n\t}\n}\n```\n此时需要为流程的启动节点添加一个taskListener,事件(event)类型为create即可。\n\n###  Activiti中的用户和角色\n\nactiviti中的用户和角色信息保存在 act_id开头的几张表里面，可以通过IdentityService来对用户和角色信息进行增删，如下：\n```\n/**在部署流程定义和启动流程实例的中间，设置组任务的办理人，向Activity表中存放组和用户的信息*/\nIdentityService identityService = processEngine.getIdentityService();//认证：保存组和用户信息\nidentityService.saveGroup(new GroupEntity(\"部门经理\"));//建立组\nidentityService.saveGroup(new GroupEntity(\"总经理\"));//建立组\nidentityService.saveUser(new UserEntity(\"小张\"));\nidentityService.saveUser(new UserEntity(\"小李\"));\nidentityService.saveUser(new UserEntity(\"小王\"));\nidentityService.createMembership(\"小张\", \"部门经理\");//建立组和用户关系\nidentityService.createMembership(\"小李\", \"部门经理\");//建立组和用户关系\nidentityService.createMembership(\"小王\", \"总经理\");//建立组和用户关系\n```\n用户任务处理人的变更：\n```\n组任务分配给个人任务（认领任务）：\nprocessEngine.getTaskService().claim(taskId, userId);\n个人任务分配给组任务：\nprocessEngine.getTaskService(). setAssignee(taskId, null);\n向组任务添加人员：\nprocessEngine.getTaskService().addCandidateUser(taskId, userId);\n向组任务删除人员：\nprocessEngine.getTaskService().deleteCandidateUser(taskId, userId);\n```\n\n##  流程图的绘制\n了解了上面的内容，其实我们就可以绘制一个基本的带有决策功能的流程图了，以下是绘制流程图的基本思路(以请假流程为例)\n1. 考虑参与的用户是谁，有哪些？对应的角色有什么\n员工、部门经理、人事\n2. 流转的表单内容\n请假开始时间、结束时间、事假还是病假、申请人\n3. 绘制流程图\n这里主要是考虑每个用户任务(userTask)的参与人，即设置Assigine属性或Candinate groups属性；\n除了申请人填写的表单外，涉及到了决策(即审批)是不是也要添加当前任务的流程变量，是否提交到下一节点，还是回退；\n如果有这样子的决策，那就需要用到互斥网关了，然后在互斥网关的流出的线上(SequenceFlow)添加ConditionExpression属性；\n最后如果到End节点前面的一个userTask的时候，如果此userTask执行完毕之后，需要再额外更新我们自己的数据表，同样可以添加一个taskListener,event类型设置为complete即可．\n\n##  Referenced\n[1、Activiti中的表达式](http://www.mossle.com/docs/activiti/index.html# apiExpressions)\n[2、封面图](https://alisonmarket.lofter.com/post/2b1789_1c808c676)\n\n","tags":["工作流"],"categories":["工作流引擎"]},{"title":"Manjaro启用交换空间","slug":"41","url":"/2020/02/15/41/","content":"目前我在用的小米笔记本的内存只有4G，系统经常出现卡死的情况，交换空间是未启用的状态，看如果启用了交换空间会不会好一点。\n<!--more-->\n##  环境\nOS: manjaro-xfce 18.1.5\n内存：4G，小米笔记本\n\n##  交换空间(Swap space)\n交换空间是磁盘上的一块区域，可以是一个分区，也可以是一个文件，或者他们的组成，当系统物理内存不足时，Linux会把内存中的不常用的数据保存到交换空间中，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问swap上存储的内容时，再将swap上的数据加载到内存中，这就是我们常说的swap out和swap in。\n\n##  交换空间的启用\n\n###  交换空间大小的选择\n一般当前内存+2即可，最大不超过当前内存×2。\n\n###  创建分区\n我这里是manjaro已经安装完成了，且只有一个分区，直接通过gpated是无法成功创建分区的。通过系统启动盘中的gaprted工具创建一个新的分区。\n\n###  创建及启用交换空间\n```\n# 找到创建的新分区\nsudo fdisk -l\n# 创建swap分区,这里的sda2为新创建的分区的名称\nsudo mkswap /dev/sda2\n# 查看正在使用的分区,应该是没有的\nswapon -s\n# 激活交换空间\nsudo swapon /dev/sda2\n此时再执行swapon -s就会有了\n# 将交换空间信息写入到/etc/fstab文件中以便重启时仍能自动加载交换空间分区\nsudo sh -c 'echo \"/dev/sdb1 none  swap    sw   0    0\" >> /etc/fstab'\n```\n\n\n##  Referenced\n[1、Linux交换空间（swap space）](https://segmentfault.com/a/1190000008125116)\n[2、/etc/fstab文件的详解](https://blog.csdn.net/youmatterhsp/article/details/83933158)\n[3、Linux swapon命令](https://www.runoob.com/linux/linux-comm-swapon.html)\n[4、封面图](https://tiezhuzhuzhu923.lofter.com/post/310ff6d7_1c804cbfb)","tags":["Linux","交换空间"],"categories":["Linux"]},{"title":"windows下安装mysql免安装版","slug":"39","url":"/2020/01/17/39/","content":"本文主要介绍在windows下安装mysql免安装版本的具体过程。\n<!--more-->\n\n##  安装环境\nOS:  win10 ×64\nDB: Mysql 8.0\n\n##  mysql配置\n解压缩下载之后安装包，然后创建data目录和my.ini配置文件，my.ini的编码格式改为**ANSI**\nmy.ini配置文件内容如下，注意修改mysql的目录：\n```\n[mysqld]\n# 设置3306端口\nport=3306\n# 设置mysql的安装目录\nbasedir=C:\\Program Files\\mysql-8.0.18-winx64\n# 设置mysql数据库的数据的存放目录\ndatadir=C:\\Program Files\\mysql-8.0.18-winx64\\data\n# 允许最大连接数\nmax_connections=200\n# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统\nmax_connect_errors=10\n# 服务端使用的字符集默认为UTF8\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n# 默认使用“mysql_native_password”插件认证\ndefault_authentication_plugin=mysql_native_password\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8\n[client]\n# 设置mysql客户端连接服务端时默认使用的端口\nport=3306\ndefault-character-set=utf8\n```\n\n##  初始化并启动mysql服务\n以管理员身份进入mysql的bin路径下，依次执行以下命令：\n```\n--初始化，会打印数据库密码，记住该密码，后面会用到\nmysqld --initialize --console\n\n如果这里的密码忘记了或想要重新执行，需要先删掉data目录\n \n--这里MySql8是服务的名字，你可以不写或者自己命名一个服务\nmysqld --install mysql8\n  \n--这里是启动服务名字，就是刚刚命名的名字\nnet start mysql8\n  \n--登陆数据库，这时会让你输入密码\nmysql -u root -p\n\n--如果是其他端口，那么需要手动设置，如下：\nmysql -u root -P3307 -p\n其中3307为你自定义的端口号。\n  \n--修改密码\nset password for root@localhost='123456' \\g\n\n```\n\n##  Referenced\n[1、windows下安装mysql-8.0.18-winx64](https://www.cnblogs.com/quchunhui/p/11842532.html)\n[2、MySQL 5.7.22 二进制包安装及免安装版Windows配置方法](https://www.jb51.net/article/146323.htm)\n[3、封面图](https://shiyuhei10456.lofter.com/post/3126465a_1c76bf4d6)","tags":["Mysql"],"categories":["数据库"]},{"title":"Intellij idea创建Java小工具","slug":"37","url":"/2019/12/27/37/","content":"本文主要将如何使用Intellij Idea如何创建简单的小黑窗项目。\n\n<!--more-->\n##  一、背景\n\n###  打的jar包执行时报错\n因为之前做的是.NET开发，可以使用Visual Studio创建控制台项目，到了JAVA这里，直接就是MyEclipse以及Intellij Idea做的Web项目，对Java中类似的“控制台项目”缺少了解，于是就出现了问题： Invalid or corrupt jarfile xxx.jar。\n\n###  项目创建过程\nNew Project —>Maven...\n\n##  二、Intellij Idea创建小黑窗项目\n\n###  创建项目\n**New Project —>Java—>Command Line App**\n\n###  配置artifacts\n**File—>Project Settings->Artifacts**\n添加jar即可，记得设置下Main Class\n\n###  运行jar包\njava -jar xxx.jar\n\n##  Referenced\n[1、封面图](https://huadou145.lofter.com/post/205d4db3_1c7474e60)","tags":["Java"],"categories":["语言"]},{"title":"jar文件没有主清单文件","slug":"35","url":"/2019/12/23/35/","content":"jar文件没有主清单文件时，通过手动编辑MANIFEST.MF文件的方式使得jar文件正常运行。\n<!--more-->\n##  jar文件的执行\n```\njava -jar xxx.jar params1 params2...\n```\n其中params1和params2为main方法的参数\n\n##  执行jar文件时提示xx.jar中没有主清单属性\n在META-INF\\MANIFEST.MF中添加入口类即可。\n可以使用7z打开xxx.jar，修改其中的MANIFEST.MF文件，在底部添加入口类即可\n```\n...\nMain-Class: cn.xxx.demo.Main\n```\n\n##  关于MANIFEST.MF文件\n为应用程序清单文件，在andorid porject中为AppManifest.xml,在.net项目中也有它的身影，主要描述了应用程序的一些基本信息，一般都会包含程序的入口信息，这里不在具体赘述，可建立对应的项目进行了解。\n\n##  Preferenced\n[1、java命令 ： java -jar 和 java -cp](https://blog.csdn.net/fly910905/article/details/81668199)\n[2、MANIFEST.MF文件详解](https://www.cnblogs.com/Gandy/p/7290069.html)\n[3、java运行jar命令提示没有主清单属性](https://www.cnblogs.com/shaosks/p/9984350.html)\n[4、封面图](https://riyanyaohuahua.lofter.com/post/30bdc03d_1c740e7c5)","tags":["Java"],"categories":["语言"]},{"title":"视频码率与网络带宽","slug":"33","url":"/2019/12/16/33/","content":"根据视频的文件大小和视频来计算视频码率，之后计算保证在线视频流畅播放所需要的带宽\n\n<!--more-->\n\n##  基本算法\n\n**视频码率**=【文件大小】(KB) * 8 / 【时间】(秒)\n**单位**：kbps\n\n举例，D5的碟，容量4.3G，其中考虑到音频的不同格式，姑且算为600M，（故剩余容量为4.3*1024-600=3803.2M)，所以视频文件应不大于3.7G，本例中取视频文件的容量为3.446G，视频长度100分钟（6000秒），计算结果：码率约等于4818kbps(3.446 * 1024 * 1024 * 8 / 6000 = 4817.857)。\n\n##  码率的几点原则\n\n1、码率和质量成正比，但是文件体积也和码率成正比。这是要牢记的。\n2、码率超过一定数值，对图像的质量没有多大影响。\n3、DVD的容量有限，无论是标准的4.3G，还是超刻，或是D9，都有极限。\n\n**视频码率**　计算机中的信息都是二进制的0和1来表示，其中每一个0或1被称作一个位，用小写b表示，即bit（位）；大写B表示byte,即字节，一个字节=八个位，即1B=8b；前面的大写K表示1024的意思，即1024个位（Kb)或1024个字节(KB)。表示文件的大小单位，一般都使用字节（KB）来表示文件的大小。\n**Kbps**：首先要了解的是，ps指的是/s，即每秒。Kbps指的是网络速度，也就是每秒钟传送多少个千位的信息（K表示千位，Kb表示的是多少千个位），为了在直观上显得网络的传输速度较快，一般公司都使用kb（千位）来表示。1KB/S=8Kbps。ADSL上网时的网速是512Kbps,如果转换成字节，就是512/8=64KB/S(即64千字节每秒）。\n4、一般来说，如果是1M的宽带，在网上只能看不超过1024kbps的视频，超过1024kbps的视频只能等视频缓冲才能流畅的观看。\n\n###  Preference\n\n[1、视频码率](https://baike.baidu.com/item/%E8%A7%86%E9%A2%91%E7%A0%81%E7%8E%87/10008023?fr=kg_qa)\n[2、封面图](https://alisonmarket.lofter.com/post/2b1789_1c7361bf1# )","categories":["图形图像"]},{"title":"ArcGIS JS API加载倾斜三维模型","slug":"31","url":"/2019/12/14/31/","content":"通过ContextCapture将倾斜摄影模型导出为SLPK格式，可供ArcGIS平台使用。\n<!--more-->\n##  软件版本\nArcgis api for js: 4.13\n\n##  SLPK格式\n全程Arcgis Desktop Scene Layer Package,是一种基于I3S的三维数据格式规范，为OGC新的国际三维标准，是由ESRI公司发起。\n\n具备生命行和可扩展性，并已经用于不同类型的三维数据：\na.离散三维模型（3D Objects）：主要指独立建模物、建筑构造物；\nb.密集格网（Integrated Meshes）：主要指倾斜摄影测量建模成果；\nc.点（Points）：主要指城市小品如行道树、城市道路设施等；\nd.点云（Point Clouds）：主要指Las数据集，暂不支持在10.5中发布成Scene Service；\n\n##  SLPK数据的获取\n目前支持SLPK数据导出的软件有Esri的ArcGIS、Bentley的ContextCapture、Skyline的PhotoMesh，这里我们使用ContextCapture，资源压缩类型（store/deflate）,其中一种为压缩的，生成的文件后缀为.slpk,另一种无压缩，为散列的文件，前者我们可以使用ArcGIS Pro进行发布供ArcGIS平台使用；后者我们接下来使用ArcGIS Js Api进行直接加载。\n\n##  ArcGIS JS API加载SLPK数据\n###  IntegratedMeshLayer的使用\n这里使用的SLPK数据类型为倾斜摄影测量的成果，机密集格网，对应的图层类型IntegratedMeshLayer。\n代码如下：\n```\n require([\"esri/Map\", \n      \"esri/views/SceneView\",\n      \"esri/layers/IntegratedMeshLayer\",\n      \"esri/geometry/Extent\"\n    ], function(Map, SceneView,IntegratedMeshLayer,Extent) {\n        var layer = new IntegratedMeshLayer({\n          url:\"\"\n        });\n        var map = new Map({\n          basemap: \"streets\",\n          layers: [layer],\n          ground: \"world-elevation\"\n        });\n        var view = new SceneView({\n          container: \"viewDiv\", // Reference to the scene div created in step 5\n          map: map, // Reference to the map object created before the scene\n      });\n```\n官方实例：https://developers.arcgis.com/javascript/latest/sample-code/sandbox/index.html?sample=layers-integratedmeshlayer\n其中IntegratedMeshLayer的url即为slpk所在目录，可以使用Nginx做反向代理\n\n###  Nginx跨域配置\nlocation节点内添加如下内容\n```\nlocation /{\n\t\t\n\t\t\tadd_header Access-Control-Allow-Origin *;\n\t\t\tadd_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';\n\t\t\tadd_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';\n\t\t}\n```\n\n###  slpk数据中.json文件访问不到的问题\n可在nginx中设置默认文件，添加如下部分：\n```\nindex 3dNodeIndexDocument.json 3dSceneLayer.json sharedResource.json 1_0.bin 0.bin 0.json;\n```\n###  featurs、geometry、textures中的bin文件访问不到\n这里以features为例，在每个features内根据文件名创建同名目录，然后把文件复制进入即可，如旧目录结构如下：\n```\nfeatures\n  0.json\n```\n修改后的目录结构为：\n```\nfeatures\n  0\n    0.json\n```\n这里可自行写文件批量处理工具。\n\n##  Referenced\n[1、重磅：Esri-I3S标准规范将作为OGC新的国际三维标准 ](https://www.sohu.com/a/192789888_609577)\n[2、Java实现复制文件或者文件夹](https://www.cnblogs.com/oukele/p/11003307.html)\n[3、Windows下Nginx的启动、停止、重启等命令](https://www.cnblogs.com/jianmingyuan/p/10899917.html)\n[3、封面图](https://huadou145.lofter.com/post/205d4db3_1c72a6dad)","tags":["GIS"],"categories":["GIS"]},{"title":"PHP现学现卖系列之——我的博客归档页面12月怎么没数据啦","slug":"29","url":"/2019/12/05/29/","content":"进入12月份，发现博客归档页面的数据没有继续更新了，原来是日期的少了判断，接下来且看我在线表演PHP现学现卖[啊，不是—.—]\n<!--more-->\n##  归档页面\n原来的处理如下\n```\n$year = $archives->year;\n$month = $archives->month;\n$nextMonth = $archives->month+1;\n$contents = $this->db->fetchAll($this->select()\n->where('table.contents.status = ?', 'publish')\n->where('table.contents.created >= ?', strtotime(\"$year-$month\"))\n->where('table.contents.created < ?', strtotime(\"$year-$nextMonth\"))\n->where('table.contents.type = ?', 'post')\n->order('table.contents.created', Typecho_Db::SORT_DESC), array($this, 'push'));\n```\n到12月时，这里忽略了年份的增加以及月份变为1月，故导致归档页面中的12月出现异常,接下来在这里添加判断就可以了。\n\n##  PHP基本语法及typecho post字段信息\n###  if else的写法\n```\nif(){\n}\nelseif(){\n}\nelse{\n}\n```\n###  等和不等\n==和!=即可\n\n###   Widget_Contents_Post_Date字段解析\nyear：年份的字符串形式，譬如2015\nmonth：月份的字符串形式，譬如01\nday：字符串形式 \n示例如下：\n```\n'year' => string '2015' (length=4)\n'month' => string '01' (length=2)\n'day' => string '25' (length=2)\n'date' => string '2015-01' (length=7)\n```\n##  归档页面调整\n根据上面的信息，调整后的归档页面如下：\n```\n$year = $archives->year;\n$month = $archives->month;\n$nextMonth = $archives->month+1;\n$nextYear=$archives->year;\n\nif($archives->month == '12'){\n$nextYear=$archives->year+1;\n$nextMonth = '01';\n}\n$contents = $this->db->fetchAll($this->select()\n->where('table.contents.status = ?', 'publish')\n->where('table.contents.created >= ?', strtotime(\"$year-$month\"))\n->where('table.contents.created < ?', strtotime(\"$nextYear-$nextMonth\"))\n->where('table.contents.type = ?', 'post')\n->order('table.contents.created', Typecho_Db::SORT_DESC), array($this, 'push'));\n```\n##  Referenced\n[1、PHP If...Else 语句](https://www.runoob.com/php/php-if-else.html)\n[2、Typecho按时间归档](https://www.typechodev.com/theme/55.html)\n[3、封面图](https://huadou145.lofter.com/post/205d4db3_1c7247e32)","tags":["typecho","PHP"],"categories":["Typecho"]},{"title":"Nginx在Windows和Ubuntu下的基本命令","slug":"27","url":"/2019/12/05/27/","content":"本文主要记录Nginx在日常使用时用到的基本命令\n<!--more-->\n##  Windows中运行Nginx\n1. 启动\nstart nginx\n2. 停止\nnginx.exe -s stop\nnginx.exe -s quit\n注：stop是快速停止nginx，可能并不保存相关信息；quit是完整有序的停止nginx，并保存相关信息。\n3. 重新载入\nnginx.exe -s reload\n当配置信息修改，需要重新载入这些配置时使用此命令。\n\n##  Ubuntu 16.04中运行Nginx\n###  启动及退出\n1. 安装\nsudo apt-get install nginx\n2. 启动\nnginx\n3. 重新加载配置\nnginx -s reload\n4. 退出\nnginx -s stop\n5. 检查nginx配置文件\nnginx -t\n\n###  反向代理\nUbuntu中nginx的配置文件在/etc/nginx目录下\n通过nginx服务器中的80端口访问其他服务器中的非80端口的服务\n\n修改nginx配置文件：\n\n```\nserver\n{\n    listen 80;\n    server_name *****;\n    location / {\n   \t\tproxy_redirect off;\n \t\tproxy_intercept_errors on;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header REMOTE-HOST $remote_addr;\n        proxy_set_header X-Forwarded-For \"$http_x_forwarded,$remote_addr\";\n        proxy_pass http://ip:port; \n    }\n}\n```\n\n###  启用gzip压缩\n修改配置文件http部分的gzip部分为以下：\n```\nhttp{\n\t...\n    gzip on;\n    gzip_types text/plain text/css text/javascript application/javascript\n    ...\n}\n```\n其他配置：\n1. gzip_com_level 4；# 默认1，可取[1~9],值越大，压缩率越大，对服务器cpu的消耗就越高\n2. gzip_min_length 2k; # 默认值: 0 ，不管页面多大都压缩,建议设置成大于1k的字节数，小于1k可能会越压越大。 \n3. gzip_buffers 4 16k;\n4. gzip_vary on # 加个vary头，给代理服务器用的，有的浏览器支持压缩，有的不支持，所以避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩\n\n###  Nginx负载均衡\n```\nhttp{\n    ...\n    \tupstream localhost{\n            server localhost:8088 weight=1;\n\t\t\tserver localhost:8089 weight=1;\n    \t}\n    ...\n    server{\n        listen 80;\n        location /{\n             proxy_pass   http://localhost/;\t\n             # 其他参数\n\t\t\t# proxy_redirect default;\t\t\t \n            # proxy_set_header Host $host;\n            # proxy_set_header X-Forwarded-For $remote_addr;\n            # proxy_redirect default;\n            # proxy_buffer_size 512k;\n            # proxy_buffers 6 512k;\n            # proxy_busy_buffers_size 512k;\n            # proxy_temp_file_write_size 512k;\n            # client_max_body_size 100m;\n        }\n    }\n    \n}\n```\n###  Nginx动静分离\n把静态资源如js、css、png等交由Nginx处理，不再向tomcat发送请求,Location可根据需要进行配置：\n\n1. 所有提交给Nginx的请求的静态文件均由Nginx自身处理\n2. 只有匹配到固定路径的请求，Nginx才会自行处理\n\n```\n# 默认当前server下的所有对js、css文件的请求都会匹配到\nlocation ~ .*\\.(js|css)?$\n{\n    root /usr/local/webapps;\n    expires 1h;\n}\n# 匹配static下的credit和images下的js及css文件\nlocation ~* \\/static\\/(credit|images).*\\.(js|css|ttf|woff|woff2)?$ {\nroot   D:/nginx/reg/;\nindex  test.png;\n}\n```\n###  Nginx 配置404或500页面\n```\nserver{\n    ...\n    error_page  404 403 500 502 503 504  /404.html;\n    location = /404.html {\n        root   /usr/share/nginx/html; # 错误页面的存放路径\n    }\n    ...\n    \n}\n```\n注意，此时只有Nginx抛出的404才能显示这个页面，其反向代理的错误页面则不会显示这个，如果想要其反向代理的页面抛出404，还需要添加：\n```\n location / CMS{\n            proxy_intercept_errors on;\n\n            proxy_pass      http://www;\n\n            proxy_set_header HOST   $host;\n\n            proxy_set_header X-Real-IP      $remote_addr;\n\n            proxy_set_header X-Forwarded-FOR $proxy_add_x_forwarded_for;\n        }\n```\n\n###  Nginx配置别名(超好用的咧)\n```\nlocation ~^/nginx {\nalias E:/DApps/;\n}\n```\nalias指定的目录是准确的，即location匹配访问的path目录下的文件直接是在alias目录下查找的；\n即：http://xxx/nginx/a.html ：访问的就是E:/DApps/a.html,至于location这里的结尾要不要加/,应该是没区别的，但alias结尾是一定要加的。\n\n##  Nginx+Tomcat配置https\n有两种方式：1.同时配置https,2.Nginx配https,Tomcat不配\n\n###  Tomcat和Nginx同时配置https\n\n修改nginx.conf文件\n\n```\nserver {\n    listen 443;\n    server_name localhost;\n    ssl on;\n    root html;\n    index index.html index.htm;\n    ssl_certificate   cert/214293719880562.pem;\n    ssl_certificate_key  cert/214293719880562.key;\n    ssl_session_timeout 5m;\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_prefer_server_ciphers on;\n    location / {\n        root html;\n        index index.html index.htm;\n    }\n}\n```\n\n###  Nginx跨域配置\n\n```\n  add_header Access-Control-Allow-Origin *;\n  add_header Access-Control-Allow-Headers X-Requested-With;\n  add_header Access-Control-Allow-Methods GET,POST,OPTIONS;\n```\n放在server-》location里面即可，此时只作用于当前location，当然放在http里面也是可以的。\n\n###  Nginx使用Https,Nginx和Tomcat之间使用Http\n可参考：\nhttps://www.cnblogs.com/swbzmx/p/8845810.html\n\n##  Nginx性能监控\nhttp://www.ttlsa.com/nginx/nginx-status-detail/\nNginx安装目录：/etc/nginx \n日志：/var/logs/nginx\n\n##  Referenced\n[1、Nginx负载均衡简单配置](http://blog.51cto.com/13178102/2063271)\n[2、Location匹配]( https://segmentfault.com/a/1190000009237425)\n[3、Fontawosome字体匹配](https://www.cnblogs.com/yc-755909659/p/5928243.html)\n[4、封面来源](https://huadou145.lofter.com/post/205d4db3_1c7247e32)\n\n","tags":["Nginx"],"categories":["Linux"]},{"title":"Linux中的硬链接和软链接","slug":"25","url":"/2019/12/01/25/","content":"本文主要介绍linux系统的软链接和硬链接的使用和差异。\n<!--more-->\n##  linux文件的权限标识符\n```\ndrwxr-xr-x\n```\n第一位是文件类型，-为一般文件，d为目录，l为链接文件\n剩余9位则是代表【owner权限】【group权限】【others权限】\nr:读，w:写，x：可执行\n\n\n##  软链接和硬链接\n为了解决文件的共享使用\nll、ls -l：罗列出当前文件或目录的详细信息，含有时间、读写权限、大小、时间等信息，如下：\n```\ndrwxr-xr-x 2 root root 4096 11月  7  2018 conf.d\n-rw-r--r-- 1 root root 1077 11月  7  2018 fastcgi.conf\n-rw-r--r-- 1 root root 1007 11月  7  2018 fastcgi_params\n-rw-r--r-- 1 root root 2837 11月  7  2018 koi-utf\n```\n\n**软链接**：同windows的快捷方式很像，删除不影响源文件，但若被指向的原文件被删除，则相关软连接就变成了死链接；\n\n**硬链接**：允许一个文件有多个有效路径名，作用对象为文件，只能在同一文件系统中的文件之间进行链接，之所以文件建立了硬链接就会防止数据误删，是因为文件系统的原理是，只要文件的索引节点(inode)还有一个以上的链接（仅删除了该文件的指向），只删除其中一个链接并不影响索引节点本身和其他的链接（数据的实体并未删除），只有当最后一个链接被删除后，此时如果有新数据要存储到磁盘上，被删除的文件的数据块及目录的链接才会被释放，空间被新数据暂用覆盖。\n\n##  软硬链接的相关命令\n###  创建软链接\n```\nln -s source target\n如：\nln -s /xxx/lntest/soft/default.txt test2\n在当前目录创建一个test2执行default.txt\n```\n然后可以查看test2的文件类型为l\n**注意**：软链接支持目录及文件；\n###  删除软链接\n同删除文件是一样的，使用rm命令即可\n\n###  修改软链接\n```\nln -snf [source ] [target]\n```\n\n##  创建硬链接\n```\nln source target\n```\n注意：\n1、硬链接不需要使用绝对路径；\n2、只能对文件创建硬链接；\n3、同一个源文件的所有硬链接文件必须在同一个硬盘、同一个分区里面\n4、使用场景很少，不建议使用；\n\n##  软链接同硬链接的差异\n软链接是快捷方式，可以用在硬盘合理分配上；\n硬链接是文件名字，一个文件的许多名字互为硬链接；\n\n##  Referenced\n\n[1、Linux命令 ls 和 ll 的使用方法与基本区别](https://www.linuxidc.com/Linux/2018-07/153131.htm)\n[2、Linux系统硬链接和软链接](https://www.cnblogs.com/songgj/p/9115954.html)\n[3、linux软链接的创建、删除和更新](https://blog.csdn.net/m290345792/article/details/78518360)\n[4、Linux软链接与硬链接实战解析](https://blog.csdn.net/guangcheng0312q/article/details/100117582)\n[5、封面图](https://huadou145.lofter.com/post/205d4db3_1c71e6ba8)","tags":["Linux"],"categories":["Linux"]},{"title":"Nginx结合geoip2实现按地区过滤用户","slug":"23","url":"/2019/11/27/23/","content":"本文主要讲述Nginx结合GeoIP2实现对不同地区用户提供不同的服务。通过为在编译Nginx时加入ngx_http_geoip2模块，结合免费的geolite2数据库，实现用户来源的筛选。\n<!--more-->\n##  系统环境\nOS:Ubuntu 18.04\nNginx: 1.8.0\n##  Nginx的编译\n###  geoip2-nginx模块\ngeoip2-nginx模块\n```\ngit clone https://github.com/TravelEngineers/ngx_http_geoip2_modulenginx-1.8.0\n```\n###  geoip2  依赖配置\n核心识别库 libmaxminddb，可在https://github.com/maxmind/libmaxminddb/releases 找到最新版本。\n```\nwget  https://github.com/maxmind/libmaxminddb/releases/download/1.4.2/libmaxminddb-1.4.2.tar.gz\n```\n安装\n```\ncd libmaxminddb-1.3.2\n./configure\nmake\nmake check\nsudo make install\nsudo ldconfig\n```\n###  nginx配置及安装\n下载Nginx并解压\n进入：cd nginx-1.8.0，配置：\n```\n./configure --with-http_ssl_module --add-module=../ngx_http_geoip2_module --prefix=/usr/local/nginx\n```\n可能会提示提示缺少部分包，安装即可\n```\n解决依赖包openssl安装，命令：\nsudo apt-get install openssl libssl-dev\n解决依赖包pcre安装，命令：\nsudo apt-get install libpcre3 libpcre3-dev\n解决依赖包zlib安装，命令：\nsudo apt-get install zlib1g-dev\n```\n重新配置并安装\n```\n配置：./configure --with-http_ssl_module --add-module=../ngx_http_geoip2_module --prefix=/usr/local/nginx\n编译：make\n安装：make install\n启动：/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n重启：/usr/local/nginx/sbin/nginx -s  reload\n```\n至此，nginx应该已经安装完成，并且启动\n##  Nginx配置\n下载geoip数据库然后在访问nginx时，会发现在响应头中已经带了\nhttps://dev.maxmind.com/geoip/geoip2/geolite2/\n需要下载国家和城市的数据\n修改nginx.conf\nhttp节点添加\n```\ngeoip2 ../GeoLite2-Country.mmdb {\n        $geoip2_data_country_code country iso_code;\n        $geoip2_country_code default=US country iso_code;\n        $geoip2_country_name country names zh-CN;\n}\n\ngeoip2 ../GeoLite2-City.mmdb {\n         $geoip2_city_name default=ShangHai city names en;\n# zh-CN;\n         $geoip2_continent_code continent code;\n    }\n\n```\n如果需要在响应头中输出城市、国家的名字，可在server节点添加如下信息：\n```\nadd_header \"country\" $geoip2_data_country_code;\nadd_header \"city\" $geoip2_city_name;\nadd_header \"c_name\" $geoip2_country_name;\n```\n在location节点中，根据国家所在地，判断是否向用户提供服务，可添加如下信息\n```\nif ($geoip2_data_country_code = CN) {\n\n}\nif ($geoip2_data_country_code != CN) {\n   return 403;\n}\n```\n\n##  Referenced\n[1、ubuntu下安装nginx时依赖库zlib，pcre，openssl安装方法](https://blog.csdn.net/z920954494/article/details/52132125)\n[2、nginx通过geoip2模块实现判断用户来源国家跳转中英站](https://www.rootop.org/pages/4366.html)\n[3、封面图](https://xiaobai697197.lofter.com/post/1dd20747_1c719d74e)","tags":["Nginx"]},{"title":"升级docker中的jenkins","slug":"21","url":"/2019/11/21/21/","content":"本文主要介绍如何升级docker中的jenkins\n<!--more-->\n##   环境及现状\nOS:Ubuntu 18.04\n现状：使用docker部署了jenkins，并把jenkins_home挂载到了本地磁盘中，现需升级jenkins版本\n\n##  下载jenkins的安装包\n\n在[清华大学开源镜像站]( https://mirrors.tuna.tsinghua.edu.cn/jenkins/war/latest/)下载最新版本的jenkins，可以使用wget下载，并将其放在jenkins_home目录下\n\nps.清华大学开源镜像站真是个宝藏~\n\n##  将下载的jenkins.war复制到jenkins容器中\n进入容器\n```\ndocker exec -ti -u root ContainerId /bin/bash\n```\n复制\n```\ncp /var/jenkins_home/jenkins.war /usr/share/jenkins/\n```\n##  重启容器即可\n```\ndocker restart +ContainerId\n```\n其它关于docker的命令可参考之前关于docker的文章~\n##  Referenced\n[1、Jenkins：CentOS7 使用 Docker 安装 Jenkins 后，升级 Jenkins 版本](https://blog.csdn.net/KissedBySnow/article/details/90229015)\n[2、封面图](https://melare.lofter.com/post/1f010e23_1c71032c6)\n","tags":["Jenkins","Docker"]},{"title":"Typecho使用pjax实现页面局部刷新","slug":"19","url":"/2019/11/19/19/","content":"在为博客加完音乐播放器之后，发现只要切换页面页面，整个页面都会重新加载，那有没有一种方法能够局部刷新页面呢？之前时ajax实现页面局部刷新，但代码比较繁琐，还要去考虑浏览器的兼容性等问题，于是就找到了一种新的方法，使用pjax。\n\n<!--more-->\n\n##  pjax介绍\n其利用ajax技术和Html5的pushstate,实现对页面的局部刷新,进而减少页面的请求数量，增强用户的体验效果。\n\n##  pjax的引入及使用\n\n###  引入\n需要引入jquery和jquery.pjax.js两个文件，如下：\n```\n<script src=\"//cdn.bootcss.com/jquery/3.1.1/jquery.min.js\"></script>\n<script src=\"//cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min.js\"></script>\n```\n这里注意下版本，如果使用jquery3.1,pjax1.x的版本是不可以的。\n###  使用\n参数如下，具体可去[query-ajax](https://github.com/defunkt/jquery-pjax)查看：\n```\n$(document).pjax(selector, [container], options)\n```\n**selector** is a string to be used for click event delegation,如果有多个selector，可使用逗号隔开，如:\n\n```\n'.title-article a,.layui-nav-item a'\n```\n\n**container** is a string selector that uniquely identifies the pjax container,要刷新的区域；\n**options** is an object with keys。\n\n完整的实例如下：\n```\n$(document).pjax('.layui-laypage-molv a', {\n        container: '# pjax-container',\n        fragment: '# pjax-container',\n        timeout: 8000\n    });\n```\n此时刷新页面，检查pjax是否起到了作用\n##  使用Nprogress添加页面加载的进度条\n引入Nprogress\n```\n<link href=\"https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css\" rel=\"stylesheet\">\n<script src=\"https://cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js\"></script>\n```\n配置Pjax使用，如下：\n```\n$(document).on('pjax:start', NProgress.start).on('pjax:end', NProgress.done)\n```\n\n##  其他的问题\n\n###  目录读取不到内容\n本站的目录是根据文章的内容来加载的，因此只有在内容加载完成之后才能获取到文章的内容，所以需要在pjax：end中重新加载，如下\n```\n$(document).on('ready pjax:end',function(){\n        GenerateContentList();\n})\n```\n关于目录的生成请查看[js为博客文章自动生成目录](https://qqdie.com/archives/js-index.html)\n\n##  Reference\n[1、typecho博客实现pjax](https://www.ihewro.com/archives/354/)\n[2、封面图](http://xiaoxiyuashu.lofter.com/post/1d088eab_1c70b8c32)","tags":["typecho"],"categories":["Typecho"]},{"title":"layui图片懒加载","slug":"16","url":"/2019/11/17/16/","content":"目前博客的列表全都使用了图片，导致网站响应比较慢，通过使用Layui实现图片的懒加载，来临时加快网站响应速度。\n\n<!--more--> \n\n##  layui图片懒加载\n\nlayui初始化处，添加如下内容\n\n```\nlayui.use(['layer', 'element','flow'], function(){\n    ...\n    flow=layui.flow;\n    flow.lazyimg();\n    ...\n});\n```\n之后在原来的img标签中添加lay-src属性，值为原来图片的路径，即\n```\n<img lay-src=\"aaa.jpg\" alt=\"aaa\"> \n```\n当然也可以添加占位图，需要修改flow.js.\n\n##  Referenced\n[1、layui图片懒加载-loading占位图](https://www.cnblogs.com/wanpishe/p/10119835.html)\n[2、封面图](http://linpupu831.lofter.com/post/30d3e071_1c709d79d)","tags":["typecho","layui"],"categories":["Typecho"]},{"title":"Typecho附件上传失败","slug":"14","url":"/2019/11/16/14/","content":"本文主要解决typecho附件上传失败的问题\n\n<!--more-->\n\n##  取消Typecho对服务器的检验\n修改var/Typecho/Common.php\n```\npublic static function isAppEngine()\n{\n   return !empty($_SERVER['HTTP_APPNAME'])                     // SAE\n       || !!getenv('HTTP_BAE_ENV_APPID')                       // BAE\n       || !!getenv('SERVER_SOFTWARE')                          // BAE 3.0\n       || (ini_get('acl.app_id') && class_exists('Alibaba'))   // ACE\n       || (isset($_SERVER['SERVER_SOFTWARE']) && strpos($_SERVER['SERVER_SOFTWARE'],'Google App Engine') !== false) // GAE;\n}\n```\n修改为\n```\npublic static function isAppEngine()\n{\n    return false;\n}\n```\n\n##  修改上传文件夹的权限\n默认情况下，文件会上传至 /usr/uploads目录\n```\nchmod -R 777 usr/uplods\n```\n**此目录为typecho下的目录**\n\n##  Git设置忽略Uploads目录\n在typecho的根目录添加.gitignore文件，加入：\n```\nusr/uploads\n```\n如果是文件已经被纳入了版本管理，即便.gitignore中已经忽略了该文件，依旧是不起作用的，可删除本地缓存，再push\n##  Referenced\n[1. Typecho - 上传图片失败解决办法并修改图片大小限制](https://www.aiuai.cn/aifarm598.html)\n[2. gitignore不起作用](https://www.cnblogs.com/thinkingthigh/p/8007061.html)\n[3. 封面图来源](http://duyangsheng.lofter.com/post/1f344c92_1c70844d8)\n","tags":["typecho"]},{"title":"Typecho安装及部署问题相关","slug":"11","url":"/2019/11/16/11/","content":"本文主要记录Typecho的安装过程，以及安装完成之后对页面链接、头像的处理等。\n<!--more-->\n##  1. 安装及部署typecho\n操作系统：ubuntu\n软件：mysql+nginx+php-fpm\n###  安装php\napt-get install php\n###  安装数据库\nmysql的在ubuntu的安装稍微复杂，不在此文描述，如果要求不高，使用sqlite即可\n###  安装php相关扩展\n这里可以不使用apache2，可以卸载：\n```\napt-get autoremove apache2 \n```\n安装php相关扩展\n```\napt-get install php-curl\napt-get install php-mbstring\napt-get install php-fpm\n```\n###  配置php-fpm\n找到配置文件：\n```\nvi /etc/php/7.2/fpm/pool.d/www.conf\n```\n配置一下监听的端口和ip白名单\n```\nlisten = 127.0.0.1:9000\nlisten.allowed_clients = 127.0.0.1\n```\n重启php-fpm\n```\nservice php7.2-fpm restart\n```\n###  下载typecho并解压\n###  Nginx配置\nNginx需要手动安装，/etc/nginx/sites-enabled/default配置如下：\n```\nroot /~ # 配置为typecho所在路径\nlocation ~ \\.php(\\/.*)*$ {\n        include snippets/fastcgi-php.conf;\n        fastcgi_split_path_info ^((?U).+.php)(/?.+)$;\n        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n        fastcgi_param PATH_INFO $fastcgi_path_info;\n        fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info;\n        fastcgi_intercept_errors on;\n        fastcgi_pass 127.0.0.1:9000;\n        }\n```\n这里配置了伪静态，用于解决typecho链接中包含.php的问题，然后就可以启动nginx了，重启之后打开typecho安装页面即可进行安装。\n\n##  2、typecho配置伪静态\n作用：去掉博客链接中的.php。\n修改nginx的配置,加入\n```\n# 用于伪静态\nif (-f $request_filename/index.html) {\n    rewrite (.*) $1/index.html break;\n}\nif (-f $request_filename/index.php) {\n    rewrite (.*) $1/index.php;\n}\nif (!-f $request_filename) {\n    rewrite (.*) /index.php;\n}\n```\n然后在typecho的后台——>设置——>永久链接，启用地址重写功能即可，可能会报错，强制重启即可。\n##  3. 替换Gravatar为国内源\n\n在var/Typecho/Common.php中，修改\n\n```\n$url = $isSecure ? 'https://secure.gravatar.com' : 'http://www.gravatar.com';\n```\n替换为\n```\n$url = $isSecure ? 'https://secure.gravatar.com' : 'https://cn.gravatar.com';\n```\n**注：使用Gravatar头像需要注册wordpress账号**\n\n##  Referenced\n[1. Typecho修改gravatar头像源为国内服务器源](https://www.aisheji.org/post/15.html)","tags":["typecho"]},{"title":"Mysql数据库备份与恢复","slug":"7","url":"/2019/11/14/7/","content":"本文主要记录mysql使用binlog对数据库进行增量及全量备份。\n\n<!--more-->\n##  全量备份[4]\n\n数据库的全量备份有mysqldump工具，也可以[使用navicat for mysql提供的备份工具](https://jingyan.baidu.com/article/8275fc8667151446a03cf6e3.html)，这里只介绍mysqldump工具，使用步骤如下：\n\n1. 数据库备份\n全量备份可以使用mysql自带的mysqldump工具，参数有：\ndatabases,指定数据库\nflush-logs，产生新的日志文件，binlog文件，这个在后面的增量备份有讲到过\ndelete-master-logs，删掉原来的日志文件，binlog文件\nDumpFile是要备份的目标文件，输出文件\n具体命令如下：\n```\nmysqldump -uroot -p123456 --databases wordpressdb --flush-logs --delete-master-logs --single-transaction > $DumpFile\n```\n2. 数据库恢复\n恢复的命令是在MySQL命令行中执行的，要先手动创建一个数据库，然后再use这个数据库：\nmysql>source  $DumpFile\n\nps: 如果没什么特殊要求的话，其实使用Navicat for mysql做全量备份就可以了\n\n##  增量备份\n\n增量备份是通过binlog实现的，只需要开启mysql的binlog，用户所有的DDL、DML语句都会记录在这个文件中，mysql binlog的开启这里不再介绍。\n\n1. Mysql查看binlog的开启状态\nshow variables like '%log_bin%'\n其他binlog相关的命令(需要在mysql-client中执行)\n```\nshow master status;\n-- 查看binlog的内容\nshow binlog events in 'mysql-bin.000003';\n-- 使用新的文件记录日志\nflush logs\n```\n2. 使用mysqlbinlog查看binlog的内容\nmysqlbinlog --no-defaults   mysql-bin.000004 \nmysqlbinlog  --no-defaults  --base64-output=decode-rows --verbose mysql-bin.000015\n\n##  通过binlog对数据进行恢复\n\n使用mysqlbinlog工具mysql的数据进行恢复\n\nmysqlbinlog --no-defaults --start-position='651'  --stop-position='556' mysql-bin.000004 mysql-bin.000005 | mysql -uroot -pabc123\n\n除了使用positon,也可以使用time，如下：\n```\nmysqlbinlog --no-defaults --stop-datetime='2018-09-03 22:18:03' /usr/local/mysql/data/mysql-bin.000004 | mysql -uroot -p\n\nmysqlbinlog --no-defaults --start-datetime='2018-09-03 22:18:09' /usr/local/mysql/data/mysql-bin.000004 | mysql -uroot -p\n```\n如果有多个binlog,并排写,中间用空格隔开，其中第一个start-position是第一个binlog文件的pos点，stop-position是最后一个binlog的pos点\n\n关于binlog需要注意一下几点：\n1. 不要查看当前正在写入的binlog文件\n2. 不要加--force参数强制访问\n3. 如果binlog格式是行模式的,请加 -vv参数\n\n##  使用XtraBackup对数据库进行备份与恢复\n\nMysql几种不同的备份方式：\n设计合适的备份策略：\n\n    针对不同的场景下, 我们应该制定不同的备份策略对数据库进行备份, 一般情况下, 备份策略一般为以下三种\n    \n        直接cp,tar复制数据库文件\n    \n        mysqldump+复制BIN LOGS\n    \n        lvm2快照+复制BIN LOGS\n    \n        xtrabackup\n    \n    以上的几种解决方案分别针对于不同的场景\n    \n        如果数据量较小, 可以使用第一种方式, 直接复制数据库文件\n    \n        如果数据量还行, 可以使用第二种方式, 先使用mysqldump对数据库进行完全备份, 然后定期备份BINARY LOG达到增量备份的效果\n    \n        如果数据量一般, 而又不过分影响业务运行, 可以使用第三种方式, 使用lvm2的快照对数据文件进行备份, 而后定期备份BINARY LOG达到增量备份的效果\n    \n        如果数据量很大, 而又不过分影响业务运行, 可以使用第四种方式, 使用xtrabackup进行完全备份后, 定期使用xtrabackup进行增量备份或差异备份\nhttps://www.cnblogs.com/SQL888/p/5751631.html\n\n##  小结\n\n通常情况下，如果数据库出现了问题，是需要全量备份和增量备份结合的，先通过全量备份恢复数据库，之后查看binlog找到导致问题的位置，恢复到问题之前的位置就可以了\n\n##  Referenced\n[1、mysqlbinlog 查看binlog时报错unknown variable 'default-character-set=utf8'](https://www.cnblogs.com/cobbliu/p/4311926.html)\n[2、MySQL的binlog数据如何查看](https://www.cnblogs.com/snifferhu/p/5280489.html)\n[3、MYSQL简单的binlog恢复测试](https://blog.csdn.net/anzhen0429/article/details/78007127)\n[4、安全的web服务器——使用mysqldump和mysqlbinlog实现MySQL全量与增量备份](https://www.tuicool.com/articles/UzMNneb)\n[5、封面源](http://xiaoxiyuashu.lofter.com/post/1d088eab_1c70d0b69)\n","tags":["Mysql","数据库备份"]},{"title":"Mysql主从复制","slug":"8","url":"/2019/11/14/8/","content":"Mysql主从复制又叫Mysql主从同步，是构建数据库高可用集群架构的基础，它通过将一台主机的数据复制到其他一台或多台主机上，并重新应用日志(Relay log)中的SQL语句来实现复制功能。\n\n<!--more-->\n\n##  运行环境\n\nUbuntu 16.04(3个虚拟机，其中一主两从)\n\nMysql版本：5.7.23\n\n##  Master配置\n\n###  开启二进制日志\n\n   vi /etc/mysql/mysql.conf.d/mysqld.cnf\n\n```\n添加以下部分\n[mysqld]\nlog_bin=mysql-bin   //[必须]启用二进制日志\nserver-id=140       //[必须]服务器唯一ID，默认是1，一般取IP最后一段\n```\n\tMysql默认同步所有的数据库，也可以指定同步或不同步哪些数据库，添加配置：\n\n```\n# 不同步哪些数据库\nbinlog-ignore-db = mysql\nbinlog-ignore-db = test\nbinlog-ignore-db = information_schema\n\n# 只同步哪些数据库，除此之外，其他不同步\nbinlog-do-db = game\n```\n**注意：**这里无论是binlog—do-db还是binlog_ingore_db，如果需要设置多个数据库的时候，不要用逗号隔开，另起一行重新写即可，参考上面的binlog-ignore-db的写0法。\n\n重启Mysql数据库\n\n###  创建用于同步的账户并授权\n\n```\nmysql -u root -p \n\nmysql>CREATE USER 'username@%' [IDENTIFIED BY 'PASSWORD'] \\g\n\nmysql> grant all privileges on *.* to yyzc@\"%\" identified by \".\" \\g\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> flush privileges; \\g\nQuery OK, 0 rows affected (0.00 sec)\n\n```\n###  查看状态\n\n获取File及Position的信息\n\n\n```\nmysql>show master status \\g\n+------------------+----------+--------------+------------------+\n| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |\n+------------------+----------+--------------+------------------+\n| mysql-bin.000004 |      308 |              |                  |\n+------------------+----------+--------------+------------------+\n```\n\n##  Slave配置\n\n###  开启二进制日志并重启Mysql\n\n###  配置从服务器Slave及启动复制\n\n   其中master_log_file及master_log_pos从Master中获取\n\n```\nmysql>change master to master_host='192.168.245.140',master_user='mysync',master_password='123456',master_log_file='mysql-bin.000004',master_log_pos=308;  \nmysql>start slave;    //启动从服务器复制功能\n```\n###  查看Slave的状态\n\n   其中：Slave_IO及Slave_SQL进程必须正常运行，即YES状态，否则都是错误的状态。\n\n```\nmysql> show slave status \\g\n```\n\n##  同步遇到的问题\n\n1. 因为是虚拟机复制的，所以Mysql的uuid是相同的导致复制失败\n\n   修改:/var/lib/mysql中的auto.cnf中的server-uuid即可\n\n##  Referenced\n\n1.Mysql Replication浅析 ：https://www.cnblogs.com/zhenyuyaodidiao/p/4635458.html\n\n2.Mysql创建用户：https://www.cnblogs.com/z-books/p/6681777.html\n\n3.Mysql主从复制(Master-Slave)实践：https://www.cnblogs.com/gl-developer/p/6170423.html\n\n4.Mysql uuid相同导致主从复制失败：https://segmentfault.com/q/1010000010173393\n\n5.[mysql binlog_do_db参数设置的坑](https://blog.csdn.net/mengtianyalll/article/details/52683021)\n[6. 封面来源](http://mubai745.lofter.com/post/1effea90_1c6f4464a)","tags":["Mysql","数据库集群"]},{"title":"Ubuntu下Docker的安装及常用命令","slug":"6","url":"/2019/11/14/6/","content":"本文主要记录ubuntu下，docker的安装及常用命令。\n\n<!--more-->\n##  环境\n1. Ubuntu: 16.04\n\n##  Docker的安装\n```\n$ sudo apt-get update\n\n$ sudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    software-properties-common\n鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。\n\n为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。\n\n$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\n\n\n# 官方源\n# $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n\n然后，我们需要向 source.list 中添加 Docker 软件源\n\n$ sudo add-apt-repository \\\n    \"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\\n    $(lsb_release -cs) \\\n    stable\"\n\n\n# 官方源\n# $ sudo add-apt-repository \\\n#    \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n#    $(lsb_release -cs) \\\n#    stable\"\n\n    以上命令会添加稳定版本的 Docker CE APT 镜像源，如果需要最新或者测试版本的 Docker CE 请将 stable 改为 edge 或者 test。从 Docker 17.06 开始，edge test 版本的 APT 镜像源也会包含稳定版本的 Docker。\n    \n安装 Docker CE\n\n更新 apt 软件包缓存，并安装 docker-ce：\n\n$ sudo apt-get update\n\n$ sudo apt-get install docker-ce\n\n验证是否安装正确\n\ndocker run hello-world\n\n```\n\n##  镜像\n镜像简单理解就是一个操作系统的安装包，而容器就是一个具体运行的一个操作系统，及镜像安装完成之后的存在。\n###  获取镜像\n从 https://hub.docker.com/explore/ 获取，可以直接pull,也可以通过Dockerfile自行build.\n1. 直接pull下来的镜像，直接可以拿来运行就可以了，具体如下：\n```\n# pull一个ubuntu系统镜像本16.04\ndocker pull ubuntu:16.04\n# 运行此镜像，运行起来的镜像就被称作容器\ndocker run -it ubuntu:16.04\n```\n2. 通过Dockerfile自行build镜像\n首先要有一个Dockerfile,文件名就是Dockerfile,然后进入此目录，执行以下命令：\n```\ndocker build -t=\"saymagic/ubuntu-nginx:v2\" .\n然后build成功之后，run即可\n```\n其中：-t是容器的名字或标签， **.** 不要省略\n\n###  镜像的上传\n对于我们自己的镜像，如果想要给其他人，可以将其上传到docker hub,需要在docker hub中注册用户才可以。\n1. docker login\n登录，使用在docker hub中注册用户\n2. docker push saymagic/ubuntu-nginx:v1\n将本地的镜像推送到docker hub中去，这样所有人都可以访问到了，不过可以在docker hub中将其设置为Private的就只能自己访问了\n\n###  镜像相关命令\n\n#####  docker images\n查看所有镜像\n\n#####  docker rmi xxx\n删除指定镜像：xxx为镜像id\n```\n# 强制删除全部镜像\ndocker rmi -f $(docker images -q)\n```\n\n##  关于容器\n\n###  容器相关命令\n\n####  ps\n```\n# 查看正在运行的容器\ndocker ps\n# 查看所有容器\ndocker ps -a\n# 停止正在运行的容器\ndocker stop $(docker ps -q)\n# 删除全部容器\ndocker rm $(docker ps -aq)\n```\n\n####  run\n```\ndocker run -d  -v /opt/jenkins_home:/var/jenkins_home  -p 8089:8080 -p 50000:50000  jenkins/jenkins:lts\n```\n**参数说明:**\n1. -d:后台运行\n2. -v:磁盘挂载或映射，此条命令就是本地的/opt/jenkins_home映射到容器的/var/jenkins_home目录下，即容器中存储到/var/jenkins_home目录下的数据实际上是存储到了本地的/opt/jenkins_home目录中\n3. -p:端口映射,外部可通过8089端口访问到容器中的8080端口,即：hostIp:containerIp\n4. -e:环境变量，如-e MYSQL_PASSWORD=yearning123\n\n####  start\n```\ndocker start xxx\n```\n其中xxx为已经停止的容器的ID\n\n####  exec\n```\ndocker exec -ti 1a5da130bf74 /bin/bash\n```\n连接到容器\n\n####  cp\n```\ndocker cp  /opt/jeisp-admin.war f22e7a0b2562:/opt/jeisp-admin.war\ndocker cp f22e7a0b2562:/opt/jeisp-admin.war  /opt/jeisp-admin.war\n```\n将host中的文件copy到容器中和将容器中的文件copy到host中\n\n####  commit\n```\ndocker commit -m \"Added nginx from ubuntu14.04\" -a \"saymagic\" 79c761f627f3 saymagic/ubuntu-nginx:v1\n```\n将正在运行的容器转为镜像\n\n##  Referenced\n1: [docker——入门到实践](https://yeasy.gitbooks.io/docker_practice/content/install/ubuntu.html)","tags":["Docker","Ubuntu"]},{"title":"Jenkins打包Springboot项目并部署至Docker中","slug":"5","url":"/2019/11/13/5/","content":"本文记录Jenkins根据每次git的合并自动打包springboot项目，并将项目自动部署到容器中。\n<!--more-->\n##  运行环境\n1. Jenkins\n2. 源代码管理工具：gitblit\n\n##  Jenkins的插件安装\nJenkins需要安装的插件：\n1. Git plugin\n2. Maven Integration plugin\n3. Publish Over SSH\n\n##  Publish Over SSH 插件配置\n\n###  在jenkins服务器上生成秘钥对,使用如下命令\n```\nssh-keygen -t rsa\n```\n生成完毕之后会在~/.ssh目录下有私钥id_rsa和公钥id_rsa.pub两个文件\n**注意：**一定要写passphrase，否则会连不上的\n\n###  复制公钥内容 \n将公钥id_rsa.pub文件中的内容copy到应用服务器中的~/.ssh/authorized_keys文件中，如果此文件中已经有内容，换行追加即可，没有的话自行创建\n\n###  Jenkins配置\n在系统管理->系统设置->Publish Over SSH中配置参数\n![](http://193.112.158.158:8081/post/20181208/2018-12-08_202735.jpg)\n**注意：**其中Remote Directory是一个通过ssh工具传输文件时，应用服务器接收文件时的存储路径\n配置完成之后点击下面的Test Configuration测试是否配置成功。\n\n##  Jenkins编译SpringBoot类型的项目\n\n###  基本配置\n在创建项目时选择**构建一个maven项目**，需要安装前面提到的Maven Integration plugin。\n接着就可以配置项目了，重点配置Source Code Management及Build,Build的配置如下：\n![](http://193.112.158.158:8081/post/20181208/2018-12-08_203651.jpg)\n\n###  配置Post Steps\n界面如图：\n![](http://193.112.158.158:8081/post/20181208/2018-12-08_203835.jpg)\n**相关参数说明：**\n1. Source files: 需要上传到应用服务器的文件，一般为jar、war等编译后的文件\n2. Remove prefix：First part of the file path that should not be created on the remote server.\n3. Remote directory\n4. Exec command：这个是文件传输完毕之后，在应用服务器中需要执行的命令，一般为脚本，后面提供一个将程序部署在docker的脚本可供参考\n\n##  [附:]将本地的项目部署到docker中去的脚本\n\n此脚本的主要执行过程：根据容器的镜像名称获取容器编号，然后停止并删除容器。接着根据镜像重启启动一个容器，并将应用的编译后的文件拷贝到容器的tomcat中，然后启动tomcat\n\n```\n# !/bin/bash\nCONTAINER_ID=`docker ps| grep \"neil/openjdk:v0.4\"|awk '{print $1}'`\necho CONTAINER_ID\nif [ -n \"$CONTAINER_ID\" ]; then\n    docker stop $CONTAINER_ID\n    docker rm $CONTAINER_ID\nelse # 如果容器启动时失败了，就需要docker ps -a才能找到那个容器\n    CONTAINER_ID=`docker ps -a | grep \"neil/openjdk:v0.4\" | awk '{print $1}'`\n    if [ -n \"$CONTAINER_ID\" ]; then  # 如果是第一次在这台机器上拉取运行容器，那么docker ps -a也是找不到这个容器的\n        docker rm $CONTAINER_ID\n    fi\nfi\n# 重新启动一个容器\ndocker run -d -ti -p 9000:8080 neil/openjdk:v0.4\nNEW_CONTAINER_ID=`docker ps| grep \"neil/openjdk:v0.4\"|awk '{print $1}'`\n# 向tomcat目录拷贝文件\ndocker cp  /opt/jeisp-admin.war $NEW_CONTAINER_ID:/opt/tomcat/apache-tomcat-8.5.30/webapps/jeisp-admin.war\n# 启动tomcat\ndocker exec $NEW_CONTAINER_ID bash -c  \"/opt/tomcat/apache-tomcat-8.5.30/bin/startup.sh\"\necho complete\n\n```\n##  Referenced\n1. [使用Publish Over SSH插件实现远程自动部署](http://blog.51cto.com/faded/1761770)\n","tags":["Jenkins"]},{"title":"Jenkins集成SonarQube对代码进行质量检测","slug":"4","url":"/2019/11/13/4/","content":"本文主要记录jenkins集成sonarqube，以进行代码审查。\n\n<!--more-->\n##  环境\n1. SonarQube: V5.6.7\n2. Jenkins: 2.138.2\n3. Mysql: 5.7\n\n##  SonarQube在windows下的安装及配置\n\n###  配置数据库\n在conf/sonar.properties文件中，修改以下内容即可：\n```\nsonar.jdbc.url\nsonar.jdbc.password\nsonar.jdbc.username\n```\n**注意：**MariaDB貌似是不支持的，这里数据库版本使用的是Mysql5.7\n\n###  汉化插件下载及安装\n下载地址：\nhttps://github.com/SonarQubeCommunity/sonar-l10n-zh/releases\n将jar放在/extensions/plugins/ 重启SonarQube即可\n\n###  配置邮件通知\n启动成功之后打开http://ip:9000, 默认是这个ip地址，这里配置的qq邮箱\n![](http://193.112.158.158:8081/post/20181206/2018-12-06_204045.jpg)\n除此之外，还需要在通用->Server base URL，配置一下服务器的地址，否则发送的邮件中涉及到SonarQube的地址是Localhost。\n\n##  Jenkins集成SonarQube\n\n###  插件安装及配置\n安装插件： SonarQube Scanner for Jenkins\n\n然后在Jenkins的系统管理->系统设置进行参数配置,界面如图：\n![](http://193.112.158.158:8081/post/20181206/2018-12-06_204827.jpg)\n\n其中\tServer authentication token在SonarQube：我的账户->安全->Tokens处生成\n\n##  在具体的job中配置SonarQube\n![](http://193.112.158.158:8081/post/20181206/2018-12-06_205642.jpg)\n\nAnalysis properties:\n```\n# key和name保持一致且在sonar下唯一\nsonar.projectKey=\nsonar.projectName=\n# 工程版本\nsonar.projectVersion=1.0  \n# 源代码目录\nsonar.sources=\n# 分析的语言 \nsonar.language=java\n# 编码\nsonar.sourceEncoding=UTF-8\n# sonar.java.binaries=\n```","tags":["Jenkins"]},{"title":"欢迎使用 Typecho","slug":"1","url":"/2019/11/13/1/","content":"如果您看到这篇文章,表示您的 blog 已经安装成功."}]