{"title":"Tornado创建websocket并实时推送数据到前台","slug":"46","date":"2020-03-13T09:58:00.000Z","updated":"2020-03-25T13:09:04.000Z","comments":true,"path":"api/articles/46.json","excerpt":"本文主要记录使用tornado创建websocket服务，并实时向前端推送数据的过程,其中推送的数据为后台耗时任务的处理结果.","covers":null,"content":"<p>本文主要记录使用tornado创建websocket服务，并实时向前端推送数据的过程,其中推送的数据为后台耗时任务的处理结果.</p>\n<span id=\"more\"></span>\n<h2 id=\"运行环境\"><a href=\"#运行环境\" class=\"headerlink\" title=\"运行环境\"></a>运行环境</h2><p>OS:Ubuntu 18.04<br>开发工具:Vs code<br>Tornado:6.0.3<br>Python:3.7.4 </p>\n<h2 id=\"Tornado简介\"><a href=\"#Tornado简介\" class=\"headerlink\" title=\"Tornado简介\"></a>Tornado简介</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">Tornado是一种 Web 服务器软件的开源版本。Tornado 和主流Web 服务器框架（包括大多数 Python 的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。\n得利于其非阻塞的方式和对epoll的运用，Tornado 每秒可以处理数以千计的连接，因此 Tornado 是实时 Web 服务的一个 理想框架。【百度百科】<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"创建简单的Rest服务\"><a href=\"#创建简单的Rest服务\" class=\"headerlink\" title=\"创建简单的Rest服务\"></a>创建简单的Rest服务</h2><h3 id=\"安装tornado\"><a href=\"#安装tornado\" class=\"headerlink\" title=\"安装tornado\"></a>安装tornado</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">pip install tornado -i https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"创建服务\"><a href=\"#创建服务\" class=\"headerlink\" title=\"创建服务\"></a>创建服务</h3><p>这里创建了一个支持get、post、options请求的服务，请求地址：&#x2F;videoservice&#x2F;rest&#x2F;index</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class IndexHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(&quot;Hello world&quot;)\n    def post(self):\n        req&#x3D; json.loads(self.request.body)\n        print(&#39;记录编号:&#39;+str(req[&#39;rid&#39;]))\n        self.write(str(req[&quot;rid&quot;]))\n    def options(self):\n        self.set_status(204)\n        self.finish()\n\nclass Application(tornado.web.Application):\n    def __init__(self):\n        handlers &#x3D; [\n            (r&#39;&#x2F;videoservice&#x2F;rest&#x2F;index&#39;, IndexHandler)\n        ]\n        tornado.web.Application.__init__(self, handlers,autoreload&#x3D;False, debug&#x3D;False)\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    app &#x3D; Application()\n    app.listen(8866)  \n    tornado.ioloop.IOLoop.current().start()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"创建多进程-x2F-多线程的Http服务\"><a href=\"#创建多进程-x2F-多线程的Http服务\" class=\"headerlink\" title=\"创建多进程&#x2F;多线程的Http服务\"></a>创建多进程&#x2F;多线程的Http服务</h2><p>有时候，我们需要接口直接返回数据，但服务端继续执行一些耗时的应用，此时可以采用线程池的方式实现，当一个现成阻塞在时，其他线程继续执行。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import tornado.gen\nfrom tornado.concurrent import run_on_executor\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass VideoAnalyseStartHandler(tornado.web.RequestHandler):\n    executor &#x3D; ThreadPoolExecutor(20)\n    @tornado.gen.coroutine\n    def post(self):\n        req&#x3D; json.loads(self.request.body)\n        yield self.block_task(result_queue,last_image_id)\n        self.write(str(req[&#39;rid&#39;]))\n\n    @run_on_executor\n    def block_task(self,result_queue,last_image_id):\n        print(&#39;block task&#39;)\n        vAnaylyse&#x3D;VAnalyseSocket(result_queue,last_image_id)\n        vAnaylyse.start(&#123;&quot;id&quot;:&quot;3678f935-5916-4b30-8d2a-11bcc8ef0f63&quot;&#125;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里的耗时操作在block_task中完成，在post中返回数据之后，如果block_task没有返回数据，会继续执行block_task中的工作，此线程(这里到底是线程还是进程表述的可能不准确，但应该是线程)包含其启动的子线程的任务都会继续执行执行。</p>\n<p><strong>其他说明</strong>:  </p>\n<p>1.修饰符@run_on_executor。这个修饰符将同步函数改造为在executor（这里是线程池）上运行的异步函数，内部实现是将被修饰的函数submit到executor，返回一个Future对象。</p>\n<p>2.修饰符@tornado.gen.coroutine。被这个修饰符修饰的函数，是一个以同步函数方式编写的异步函数。原本通过callback方式编写的异步代码，有了这个修饰符，可以通过yield一个Future的方式来写。被修饰的函数在yield了一个Future对象后将会被挂起，Future对象的结果返回后继续执行。</p>\n<h2 id=\"Websocket实时向前端发送数据\"><a href=\"#Websocket实时向前端发送数据\" class=\"headerlink\" title=\"Websocket实时向前端发送数据\"></a>Websocket实时向前端发送数据</h2><h3 id=\"创建基本的websocket\"><a href=\"#创建基本的websocket\" class=\"headerlink\" title=\"创建基本的websocket\"></a>创建基本的websocket</h3><p>在handlers中添加：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">(r&#39;&#x2F;videoservice&#x2F;ws&#39;, ConnectHandler)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>创建ConnectHandler</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class ProStatus():\n    connector &#x3D; &#123;&#125;  # 记录当前连接的user\n\n    def user_connect(self, user):\n        if user not in self.connector:\n            self.connector[user] &#x3D; set()\n\n    def user_remove(self, user):\n        # self.connector.remove(user)\n        self.connector.pop(user)\n\n    def trigger(self, message):\n        &#39;&#39;&#39; 向所有被记录的客户端推送最新内容 &#39;&#39;&#39;\n        for user in self.connector:\n            user.write_message(message)\nclass ConnectHandler(tornado.websocket.WebSocketHandler):\n    def check_origin(self,t):\n        &#39;&#39;&#39;重写同源检查 解决跨域问题&#39;&#39;&#39;\n        return True\n\n    def open(self):\n        &#39;&#39;&#39;新的websocket连接后被调动&#39;&#39;&#39;\n        ProStatus().user_connect(self) # 用户连接后记录\n        self.write_message(&#39;Welcome&#39;)\n\n    def on_close(self):\n        &#39;&#39;&#39;websocket连接关闭后被调用&#39;&#39;&#39;\n        ProStatus().user_remove(self)  # 断开连接后remove\n\n    def on_message(self, message):\n        &#39;&#39;&#39;接收到客户端消息时被调用&#39;&#39;&#39;\n        self.write_message(&#39;new message :&#39; + message)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这样一个基本的websocket服务就创建完成了，然后创建前端页面：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n   &lt;head&gt;\n   &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n   &lt;title&gt;websocket的简单使用&lt;&#x2F;title&gt;\n    \n      &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n         function WebSocketTest()\n         &#123;\n            if (&quot;WebSocket&quot; in window)\n            &#123;\n               &#x2F;&#x2F;alert(&quot;您的浏览器支持 WebSocket!&quot;);\n               \n               &#x2F;&#x2F; 打开一个 web socket\n               var ws &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;127.0.0.1:8866&#x2F;ws&quot;);\n                \n               ws.onopen &#x3D; function()\n               &#123;\n                  &#x2F;&#x2F; Web Socket 已连接上，使用 send() 方法发送数据\n                  ws.send(&quot;发送数据&quot;);\n                  console.log(&#39;ws onopen&#39;)\n               &#125;;\n                \n               ws.onmessage &#x3D; function (evt) \n               &#123; \n                  var received_msg &#x3D; evt.data;\n                  console.log(&#39;收到数据:&#39;+received_msg)\n               &#125;;\n                \n               ws.onclose &#x3D; function()\n               &#123; \n                  &#x2F;&#x2F; 关闭 websocket\n                  console.log(&quot;连接已关闭...&quot;); \n               &#125;;\n            &#125;\n            \n            else\n            &#123;\n               &#x2F;&#x2F; 浏览器不支持 WebSocket\n               alert(&quot;您的浏览器不支持 WebSocket!&quot;);\n            &#125;\n         &#125;\n      &lt;&#x2F;script&gt;\n        \n   &lt;&#x2F;head&gt;\n   &lt;body&gt;\n   \n      &lt;div id&#x3D;&quot;sse&quot;&gt;\n         &lt;a href&#x3D;&quot;javascript:WebSocketTest()&quot;&gt;运行 WebSocket&lt;&#x2F;a&gt;\n      &lt;&#x2F;div&gt;\n      \n   &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>如果后端有消息发送回来，直接在ws.onmessage中进行处理，另外如果websocket长期无数据发送，连接可能会被自动关闭，需要使用心跳检测保持一直连接。</p>\n<h3 id=\"websocket实时向前端推送数据\"><a href=\"#websocket实时向前端推送数据\" class=\"headerlink\" title=\"websocket实时向前端推送数据\"></a>websocket实时向前端推送数据</h3><p>基本的websocket完成之后，我们接下来就可以考虑如何实时向前端推送数据了，推送数据这里肯定是要在主线程中进行的,由于前面我们的耗时操作在子线程中进行，那我们的数据直接通过调用ProStatus().trigger()就发送到前端的。</p>\n<p>这里参考了<a href=\"https://www.jianshu.com/p/36d3d3b759ad\">Tornado Websocket + Redis ：实现“填鸭式”推送</a>,通过子线程中调用rest服务，来实现实时向websocket推送数据，也就是我们在章节：创建多进程&#x2F;多线程的Http服务 中的block_task中，还需要再单独创建一个子线程，在此线程中定时调用rest服务，实现数据的推送。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from tornado import ioloop, web, websocket, httpclient\n\nclass sendMsgTools(threading.Thread):\n    def __init__(self, result_queue,last_img_id):\n        threading.Thread.__init__(self, name&#x3D;&#39;sendMsgTools&#39;)\n        self.proc_result&#x3D;result_queue\n        self.last_image_id&#x3D;last_img_id\n         \n    def run(self) -&gt; None:\n        while True:\n            try:\n                out_msg &#x3D; self.proc_result.get()\n                img_id&#x3D;out_msg[&#39;id&#39;]\n                img_data&#x3D;out_msg[&#39;img&#39;]\n                # ProStatus().trigger(str(img_id))\n                url &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:8866&#x2F;videoservice&#x2F;rest&#x2F;sendMsg&quot;\n                data &#x3D; &#123;&quot;id&quot;: img_id,&quot;img&quot;:img_data&#125;\n                print(&#39;sendMsgTools:&#39;+str(data[&quot;id&quot;]))\n                http_request &#x3D; httpclient.HTTPRequest(url, method&#x3D;&quot;POST&quot;,\n                                                    body&#x3D;json.dumps(data))\n                http_client &#x3D; httpclient.HTTPClient()\n                http_client.fetch(http_request)\n\n                if img_id &#x3D;&#x3D; self.last_image_id:\n                    break\n            except Exception as e:\n                print(traceback.format_exc())\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>block_task中内容如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@run_on_executor\n    def block_task(self,result_queue,last_image_id):\n        smTools&#x3D;sendMsgTools(result_queue,last_image_id)\n        smTools.start()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里和另一个耗时操作用的是一个队列Queue,按引用传递，故耗时操作做修改了Queue，sendMsgTools这里可以实时获取到数据更新。<br>然后在前端调用时，先和websocket建立连接，之后调用执行耗时任务的接口，就基本能够做到websocket实时向前端推送数据了。</p>\n<h3 id=\"前端发起post请求\"><a href=\"#前端发起post请求\" class=\"headerlink\" title=\"前端发起post请求\"></a>前端发起post请求</h3><p>前端页面使用了vue，故post请求这里使用axios来发送，</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">axios.post(&#39;http:&#x2F;&#x2F;127.0.0.1:8088&#x2F;videoservice&#x2F;rest&#x2F;video&#x2F;start&#39;, &#123;\n                        &quot;rid&quot;: &quot;3678f935-5916-4b30-8d2a-11bcc8ef0f63&quot;\n                    &#125;)\n                    .then(resp &#x3D;&gt; &#123;\n                        console.log(resp.data);\n                    &#125;).catch(err &#x3D;&gt; &#123;\n                        console.log(&#39;请求失败：&#39; + err.status + &#39;,&#39; + err.statusText);\n                    &#125;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"其他问题：\"><a href=\"#其他问题：\" class=\"headerlink\" title=\"其他问题：\"></a>其他问题：</h2><h3 id=\"tornado跨域问题\"><a href=\"#tornado跨域问题\" class=\"headerlink\" title=\"tornado跨域问题\"></a>tornado跨域问题</h3><p>创建一个BaseHandler，然后其他Handler继承此handler即可</p>\n<h2 id=\"Referenced\"><a href=\"#Referenced\" class=\"headerlink\" title=\"Referenced\"></a>Referenced</h2><p><a href=\"https://www.jb51.net/article/52209.htm\">1、高性能web服务器框架Tornado简单实现restful接口及开发实例</a><br><a href=\"https://www.jb51.net/article/166225.htm\">2、Tornado实现多进程&#x2F;多线程的HTTP服务详解</a><br><a href=\"https://www.jianshu.com/p/36d3d3b759ad\">3、Tornado Websocket + Redis ：实现“填鸭式”推送</a><br><a href=\"https://www.jb51.net/article/148485.htm\">4、vue发送ajax请求详解</a><br><a href=\"https://www.cnblogs.com/tiger666/articles/7155156.html\">5、tornado 添加请求头进行允许跨域</a><br><a href=\"https://huadou145.lofter.com/post/205d4db3_1c88691ff\">5、封面图源</a></p>\n","more":"<h2 id=\"运行环境\"><a href=\"#运行环境\" class=\"headerlink\" title=\"运行环境\"></a>运行环境</h2><p>OS:Ubuntu 18.04<br>开发工具:Vs code<br>Tornado:6.0.3<br>Python:3.7.4 </p>\n<h2 id=\"Tornado简介\"><a href=\"#Tornado简介\" class=\"headerlink\" title=\"Tornado简介\"></a>Tornado简介</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">Tornado是一种 Web 服务器软件的开源版本。Tornado 和主流Web 服务器框架（包括大多数 Python 的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。\n得利于其非阻塞的方式和对epoll的运用，Tornado 每秒可以处理数以千计的连接，因此 Tornado 是实时 Web 服务的一个 理想框架。【百度百科】<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h2 id=\"创建简单的Rest服务\"><a href=\"#创建简单的Rest服务\" class=\"headerlink\" title=\"创建简单的Rest服务\"></a>创建简单的Rest服务</h2><h3 id=\"安装tornado\"><a href=\"#安装tornado\" class=\"headerlink\" title=\"安装tornado\"></a>安装tornado</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">pip install tornado -i https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"创建服务\"><a href=\"#创建服务\" class=\"headerlink\" title=\"创建服务\"></a>创建服务</h3><p>这里创建了一个支持get、post、options请求的服务，请求地址：&#x2F;videoservice&#x2F;rest&#x2F;index</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class IndexHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(&quot;Hello world&quot;)\n    def post(self):\n        req&#x3D; json.loads(self.request.body)\n        print(&#39;记录编号:&#39;+str(req[&#39;rid&#39;]))\n        self.write(str(req[&quot;rid&quot;]))\n    def options(self):\n        self.set_status(204)\n        self.finish()\n\nclass Application(tornado.web.Application):\n    def __init__(self):\n        handlers &#x3D; [\n            (r&#39;&#x2F;videoservice&#x2F;rest&#x2F;index&#39;, IndexHandler)\n        ]\n        tornado.web.Application.__init__(self, handlers,autoreload&#x3D;False, debug&#x3D;False)\nif __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    app &#x3D; Application()\n    app.listen(8866)  \n    tornado.ioloop.IOLoop.current().start()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"创建多进程-x2F-多线程的Http服务\"><a href=\"#创建多进程-x2F-多线程的Http服务\" class=\"headerlink\" title=\"创建多进程&#x2F;多线程的Http服务\"></a>创建多进程&#x2F;多线程的Http服务</h2><p>有时候，我们需要接口直接返回数据，但服务端继续执行一些耗时的应用，此时可以采用线程池的方式实现，当一个现成阻塞在时，其他线程继续执行。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import tornado.gen\nfrom tornado.concurrent import run_on_executor\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass VideoAnalyseStartHandler(tornado.web.RequestHandler):\n    executor &#x3D; ThreadPoolExecutor(20)\n    @tornado.gen.coroutine\n    def post(self):\n        req&#x3D; json.loads(self.request.body)\n        yield self.block_task(result_queue,last_image_id)\n        self.write(str(req[&#39;rid&#39;]))\n\n    @run_on_executor\n    def block_task(self,result_queue,last_image_id):\n        print(&#39;block task&#39;)\n        vAnaylyse&#x3D;VAnalyseSocket(result_queue,last_image_id)\n        vAnaylyse.start(&#123;&quot;id&quot;:&quot;3678f935-5916-4b30-8d2a-11bcc8ef0f63&quot;&#125;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里的耗时操作在block_task中完成，在post中返回数据之后，如果block_task没有返回数据，会继续执行block_task中的工作，此线程(这里到底是线程还是进程表述的可能不准确，但应该是线程)包含其启动的子线程的任务都会继续执行执行。</p>\n<p><strong>其他说明</strong>:  </p>\n<p>1.修饰符@run_on_executor。这个修饰符将同步函数改造为在executor（这里是线程池）上运行的异步函数，内部实现是将被修饰的函数submit到executor，返回一个Future对象。</p>\n<p>2.修饰符@tornado.gen.coroutine。被这个修饰符修饰的函数，是一个以同步函数方式编写的异步函数。原本通过callback方式编写的异步代码，有了这个修饰符，可以通过yield一个Future的方式来写。被修饰的函数在yield了一个Future对象后将会被挂起，Future对象的结果返回后继续执行。</p>\n<h2 id=\"Websocket实时向前端发送数据\"><a href=\"#Websocket实时向前端发送数据\" class=\"headerlink\" title=\"Websocket实时向前端发送数据\"></a>Websocket实时向前端发送数据</h2><h3 id=\"创建基本的websocket\"><a href=\"#创建基本的websocket\" class=\"headerlink\" title=\"创建基本的websocket\"></a>创建基本的websocket</h3><p>在handlers中添加：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">(r&#39;&#x2F;videoservice&#x2F;ws&#39;, ConnectHandler)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>创建ConnectHandler</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class ProStatus():\n    connector &#x3D; &#123;&#125;  # 记录当前连接的user\n\n    def user_connect(self, user):\n        if user not in self.connector:\n            self.connector[user] &#x3D; set()\n\n    def user_remove(self, user):\n        # self.connector.remove(user)\n        self.connector.pop(user)\n\n    def trigger(self, message):\n        &#39;&#39;&#39; 向所有被记录的客户端推送最新内容 &#39;&#39;&#39;\n        for user in self.connector:\n            user.write_message(message)\nclass ConnectHandler(tornado.websocket.WebSocketHandler):\n    def check_origin(self,t):\n        &#39;&#39;&#39;重写同源检查 解决跨域问题&#39;&#39;&#39;\n        return True\n\n    def open(self):\n        &#39;&#39;&#39;新的websocket连接后被调动&#39;&#39;&#39;\n        ProStatus().user_connect(self) # 用户连接后记录\n        self.write_message(&#39;Welcome&#39;)\n\n    def on_close(self):\n        &#39;&#39;&#39;websocket连接关闭后被调用&#39;&#39;&#39;\n        ProStatus().user_remove(self)  # 断开连接后remove\n\n    def on_message(self, message):\n        &#39;&#39;&#39;接收到客户端消息时被调用&#39;&#39;&#39;\n        self.write_message(&#39;new message :&#39; + message)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这样一个基本的websocket服务就创建完成了，然后创建前端页面：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n   &lt;head&gt;\n   &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n   &lt;title&gt;websocket的简单使用&lt;&#x2F;title&gt;\n    \n      &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;\n         function WebSocketTest()\n         &#123;\n            if (&quot;WebSocket&quot; in window)\n            &#123;\n               &#x2F;&#x2F;alert(&quot;您的浏览器支持 WebSocket!&quot;);\n               \n               &#x2F;&#x2F; 打开一个 web socket\n               var ws &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;127.0.0.1:8866&#x2F;ws&quot;);\n                \n               ws.onopen &#x3D; function()\n               &#123;\n                  &#x2F;&#x2F; Web Socket 已连接上，使用 send() 方法发送数据\n                  ws.send(&quot;发送数据&quot;);\n                  console.log(&#39;ws onopen&#39;)\n               &#125;;\n                \n               ws.onmessage &#x3D; function (evt) \n               &#123; \n                  var received_msg &#x3D; evt.data;\n                  console.log(&#39;收到数据:&#39;+received_msg)\n               &#125;;\n                \n               ws.onclose &#x3D; function()\n               &#123; \n                  &#x2F;&#x2F; 关闭 websocket\n                  console.log(&quot;连接已关闭...&quot;); \n               &#125;;\n            &#125;\n            \n            else\n            &#123;\n               &#x2F;&#x2F; 浏览器不支持 WebSocket\n               alert(&quot;您的浏览器不支持 WebSocket!&quot;);\n            &#125;\n         &#125;\n      &lt;&#x2F;script&gt;\n        \n   &lt;&#x2F;head&gt;\n   &lt;body&gt;\n   \n      &lt;div id&#x3D;&quot;sse&quot;&gt;\n         &lt;a href&#x3D;&quot;javascript:WebSocketTest()&quot;&gt;运行 WebSocket&lt;&#x2F;a&gt;\n      &lt;&#x2F;div&gt;\n      \n   &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>如果后端有消息发送回来，直接在ws.onmessage中进行处理，另外如果websocket长期无数据发送，连接可能会被自动关闭，需要使用心跳检测保持一直连接。</p>\n<h3 id=\"websocket实时向前端推送数据\"><a href=\"#websocket实时向前端推送数据\" class=\"headerlink\" title=\"websocket实时向前端推送数据\"></a>websocket实时向前端推送数据</h3><p>基本的websocket完成之后，我们接下来就可以考虑如何实时向前端推送数据了，推送数据这里肯定是要在主线程中进行的,由于前面我们的耗时操作在子线程中进行，那我们的数据直接通过调用ProStatus().trigger()就发送到前端的。</p>\n<p>这里参考了<a href=\"https://www.jianshu.com/p/36d3d3b759ad\">Tornado Websocket + Redis ：实现“填鸭式”推送</a>,通过子线程中调用rest服务，来实现实时向websocket推送数据，也就是我们在章节：创建多进程&#x2F;多线程的Http服务 中的block_task中，还需要再单独创建一个子线程，在此线程中定时调用rest服务，实现数据的推送。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">from tornado import ioloop, web, websocket, httpclient\n\nclass sendMsgTools(threading.Thread):\n    def __init__(self, result_queue,last_img_id):\n        threading.Thread.__init__(self, name&#x3D;&#39;sendMsgTools&#39;)\n        self.proc_result&#x3D;result_queue\n        self.last_image_id&#x3D;last_img_id\n         \n    def run(self) -&gt; None:\n        while True:\n            try:\n                out_msg &#x3D; self.proc_result.get()\n                img_id&#x3D;out_msg[&#39;id&#39;]\n                img_data&#x3D;out_msg[&#39;img&#39;]\n                # ProStatus().trigger(str(img_id))\n                url &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:8866&#x2F;videoservice&#x2F;rest&#x2F;sendMsg&quot;\n                data &#x3D; &#123;&quot;id&quot;: img_id,&quot;img&quot;:img_data&#125;\n                print(&#39;sendMsgTools:&#39;+str(data[&quot;id&quot;]))\n                http_request &#x3D; httpclient.HTTPRequest(url, method&#x3D;&quot;POST&quot;,\n                                                    body&#x3D;json.dumps(data))\n                http_client &#x3D; httpclient.HTTPClient()\n                http_client.fetch(http_request)\n\n                if img_id &#x3D;&#x3D; self.last_image_id:\n                    break\n            except Exception as e:\n                print(traceback.format_exc())\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>block_task中内容如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">@run_on_executor\n    def block_task(self,result_queue,last_image_id):\n        smTools&#x3D;sendMsgTools(result_queue,last_image_id)\n        smTools.start()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这里和另一个耗时操作用的是一个队列Queue,按引用传递，故耗时操作做修改了Queue，sendMsgTools这里可以实时获取到数据更新。<br>然后在前端调用时，先和websocket建立连接，之后调用执行耗时任务的接口，就基本能够做到websocket实时向前端推送数据了。</p>\n<h3 id=\"前端发起post请求\"><a href=\"#前端发起post请求\" class=\"headerlink\" title=\"前端发起post请求\"></a>前端发起post请求</h3><p>前端页面使用了vue，故post请求这里使用axios来发送，</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">axios.post(&#39;http:&#x2F;&#x2F;127.0.0.1:8088&#x2F;videoservice&#x2F;rest&#x2F;video&#x2F;start&#39;, &#123;\n                        &quot;rid&quot;: &quot;3678f935-5916-4b30-8d2a-11bcc8ef0f63&quot;\n                    &#125;)\n                    .then(resp &#x3D;&gt; &#123;\n                        console.log(resp.data);\n                    &#125;).catch(err &#x3D;&gt; &#123;\n                        console.log(&#39;请求失败：&#39; + err.status + &#39;,&#39; + err.statusText);\n                    &#125;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"其他问题：\"><a href=\"#其他问题：\" class=\"headerlink\" title=\"其他问题：\"></a>其他问题：</h2><h3 id=\"tornado跨域问题\"><a href=\"#tornado跨域问题\" class=\"headerlink\" title=\"tornado跨域问题\"></a>tornado跨域问题</h3><p>创建一个BaseHandler，然后其他Handler继承此handler即可</p>\n<h2 id=\"Referenced\"><a href=\"#Referenced\" class=\"headerlink\" title=\"Referenced\"></a>Referenced</h2><p><a href=\"https://www.jb51.net/article/52209.htm\">1、高性能web服务器框架Tornado简单实现restful接口及开发实例</a><br><a href=\"https://www.jb51.net/article/166225.htm\">2、Tornado实现多进程&#x2F;多线程的HTTP服务详解</a><br><a href=\"https://www.jianshu.com/p/36d3d3b759ad\">3、Tornado Websocket + Redis ：实现“填鸭式”推送</a><br><a href=\"https://www.jb51.net/article/148485.htm\">4、vue发送ajax请求详解</a><br><a href=\"https://www.cnblogs.com/tiger666/articles/7155156.html\">5、tornado 添加请求头进行允许跨域</a><br><a href=\"https://huadou145.lofter.com/post/205d4db3_1c88691ff\">5、封面图源</a></p>","categories":[{"name":"Python","path":"api/categories/Python.json"}],"tags":[{"name":"Tornado","path":"api/tags/Tornado.json"},{"name":"Python","path":"api/tags/Python.json"},{"name":"Websocket","path":"api/tags/Websocket.json"}]}