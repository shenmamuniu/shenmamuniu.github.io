{"title":"Python使用pika操作RabbitMQ","slug":"122","date":"2022-06-13T13:53:35.000Z","updated":"2022-06-13T13:53:35.000Z","comments":true,"path":"api/articles/122.json","excerpt":"本文对pika的使用中遇到的几个问题做了简单的介绍：具体包括长连接、消息确认、连接断开的处理等。","covers":null,"content":"<p>本文对pika的使用中遇到的几个问题做了简单的介绍：具体包括长连接、消息确认、连接断开的处理等。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"应用版本\"><a href=\"#应用版本\" class=\"headerlink\" title=\"应用版本\"></a>应用版本</h2><p>OS:win10<br>Python:3.9<br>Pika:1.2.1<br>RabbitMQ:3.10.5</p>\n<h2 id=\"为什么要用消息队列\"><a href=\"#为什么要用消息队列\" class=\"headerlink\" title=\"为什么要用消息队列\"></a>为什么要用消息队列</h2><p>直接写入数据库效率比较低，时间稍微长一点，就会导致接收到的数据无法被及时处理。</p>\n<h2 id=\"为什么要使用RabbitMQ\"><a href=\"#为什么要使用RabbitMQ\" class=\"headerlink\" title=\"为什么要使用RabbitMQ\"></a>为什么要使用RabbitMQ</h2><p>相比ActiveMQ、RocketMQ、Kafka,更喜欢RabbitMQ的文档,且有可视化界面，学习成本低。</p>\n<h2 id=\"pika操作RabbitMQ\"><a href=\"#pika操作RabbitMQ\" class=\"headerlink\" title=\"pika操作RabbitMQ\"></a>pika操作RabbitMQ</h2><p><a href=\"https://www.rabbitmq.com/getstarted.html\">RabbitMQ Tutorials</a>对RabbitMQ有非常详细的讲解，如果有比较深入的应用，可以具体了解，本文仅介绍基本使用以及几个比较重要的参数。</p>\n<h3 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><p>这里以简单的代码为例，仅对其中几个重要的参数进行说明</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import pika\n\ntry:\n    connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(host&#x3D;&#39;localhost&#39;,heartbeat&#x3D;0))\n    channel &#x3D; connection.channel()\n    channel.queue_declare(queue&#x3D;&#39;hello&#39;,durable&#x3D;True)\n    channel.basic_publish(exchange&#x3D;&#39;&#39;,\n                        routing_key&#x3D;&#39;hello&#39;,\n                        body&#x3D;self.request.body,\n                        properties&#x3D;pika.BasicProperties(\n                            delivery_mode &#x3D; 2, # make message persistent\n                        ))\n    channel.close()\n    connection.close()\nexcept:\n    print(&quot;连接异常&quot;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>几个参数:<br>connection:heartbeat：心跳监测,0时为一直保持连接<br>channel:durable:是否持久化,即使Rabbitmq意外关闭时依旧可以恢复，同时还需要设置delivery_mode&#x3D;2</p>\n</blockquote>\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><p>这里主要设置auto_ack为false,表示消息只有得到了确认之后才算消费完成，如果没有得到确认，还会收到此消息</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(host&#x3D;&#39;localhost&#39;))\nchannel &#x3D; connection.channel()\nchannel.queue_declare(queue&#x3D;&#39;hello&#39;)\n\ndef callback(ch, method, properties, body):\n    print(&quot; [x] Received %r&quot; % body)\n    ch.basic_ack(delivery_tag &#x3D; method.delivery_tag)\n\nchannel.basic_consume(queue&#x3D;&#39;hello&#39;, on_message_callback&#x3D;callback, auto_ack&#x3D;False)\nchannel.start_consuming()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"关于连接断开的问题\"><a href=\"#关于连接断开的问题\" class=\"headerlink\" title=\"关于连接断开的问题\"></a>关于连接断开的问题</h3><p>在遇到网络中断的情况下，需要能够重新连接，<a href=\"https://pypi.org/project/pika/\">pika的介绍页面</a>提供了2中方法：1种使用while循环，第二种是使用retry组件，具体如下:</p>\n<h3 id=\"使用While循环\"><a href=\"#使用While循环\" class=\"headerlink\" title=\"使用While循环\"></a>使用While循环</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">import pika\nwhile True:\n    try:\n        connection &#x3D; pika.BlockingConnection()\n        channel &#x3D; connection.channel()\n        channel.basic_consume(&#39;test&#39;, on_message_callback)\n        channel.start_consuming()\n    # Don&#39;t recover if connection was closed by broker\n    except pika.exceptions.ConnectionClosedByBroker:\n        break\n    # Don&#39;t recover on channel errors\n    except pika.exceptions.AMQPChannelError:\n        break\n    # Recover on all other connection errors\n    except pika.exceptions.AMQPConnectionError:\n        continue\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"使用retry\"><a href=\"#使用retry\" class=\"headerlink\" title=\"使用retry\"></a>使用retry</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">from retry import retry\n\n@retry(pika.exceptions.AMQPConnectionError, delay&#x3D;5, jitter&#x3D;(1, 3))\ndef consume():\n    connection &#x3D; pika.BlockingConnection()\n    channel &#x3D; connection.channel()\n    channel.basic_consume(&#39;test&#39;, on_message_callback)\n\n    try:\n        channel.start_consuming()\n    # Don&#39;t recover connections closed by server\n    except pika.exceptions.ConnectionClosedByBroker:\n        pass\n        \nconsume()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Referenced\"><a href=\"#Referenced\" class=\"headerlink\" title=\"Referenced\"></a>Referenced</h2><p><a href=\"https://melare.lofter.com/post/1f010e23_1c71032c6\">1、封面图</a></p>\n","more":"<h2 id=\"应用版本\"><a href=\"#应用版本\" class=\"headerlink\" title=\"应用版本\"></a>应用版本</h2><p>OS:win10<br>Python:3.9<br>Pika:1.2.1<br>RabbitMQ:3.10.5</p>\n<h2 id=\"为什么要用消息队列\"><a href=\"#为什么要用消息队列\" class=\"headerlink\" title=\"为什么要用消息队列\"></a>为什么要用消息队列</h2><p>直接写入数据库效率比较低，时间稍微长一点，就会导致接收到的数据无法被及时处理。</p>\n<h2 id=\"为什么要使用RabbitMQ\"><a href=\"#为什么要使用RabbitMQ\" class=\"headerlink\" title=\"为什么要使用RabbitMQ\"></a>为什么要使用RabbitMQ</h2><p>相比ActiveMQ、RocketMQ、Kafka,更喜欢RabbitMQ的文档,且有可视化界面，学习成本低。</p>\n<h2 id=\"pika操作RabbitMQ\"><a href=\"#pika操作RabbitMQ\" class=\"headerlink\" title=\"pika操作RabbitMQ\"></a>pika操作RabbitMQ</h2><p><a href=\"https://www.rabbitmq.com/getstarted.html\">RabbitMQ Tutorials</a>对RabbitMQ有非常详细的讲解，如果有比较深入的应用，可以具体了解，本文仅介绍基本使用以及几个比较重要的参数。</p>\n<h3 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h3><p>这里以简单的代码为例，仅对其中几个重要的参数进行说明</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import pika\n\ntry:\n    connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(host&#x3D;&#39;localhost&#39;,heartbeat&#x3D;0))\n    channel &#x3D; connection.channel()\n    channel.queue_declare(queue&#x3D;&#39;hello&#39;,durable&#x3D;True)\n    channel.basic_publish(exchange&#x3D;&#39;&#39;,\n                        routing_key&#x3D;&#39;hello&#39;,\n                        body&#x3D;self.request.body,\n                        properties&#x3D;pika.BasicProperties(\n                            delivery_mode &#x3D; 2, # make message persistent\n                        ))\n    channel.close()\n    connection.close()\nexcept:\n    print(&quot;连接异常&quot;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote>\n<p>几个参数:<br>connection:heartbeat：心跳监测,0时为一直保持连接<br>channel:durable:是否持久化,即使Rabbitmq意外关闭时依旧可以恢复，同时还需要设置delivery_mode&#x3D;2</p>\n</blockquote>\n<h3 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h3><p>这里主要设置auto_ack为false,表示消息只有得到了确认之后才算消费完成，如果没有得到确认，还会收到此消息</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(host&#x3D;&#39;localhost&#39;))\nchannel &#x3D; connection.channel()\nchannel.queue_declare(queue&#x3D;&#39;hello&#39;)\n\ndef callback(ch, method, properties, body):\n    print(&quot; [x] Received %r&quot; % body)\n    ch.basic_ack(delivery_tag &#x3D; method.delivery_tag)\n\nchannel.basic_consume(queue&#x3D;&#39;hello&#39;, on_message_callback&#x3D;callback, auto_ack&#x3D;False)\nchannel.start_consuming()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"关于连接断开的问题\"><a href=\"#关于连接断开的问题\" class=\"headerlink\" title=\"关于连接断开的问题\"></a>关于连接断开的问题</h3><p>在遇到网络中断的情况下，需要能够重新连接，<a href=\"https://pypi.org/project/pika/\">pika的介绍页面</a>提供了2中方法：1种使用while循环，第二种是使用retry组件，具体如下:</p>\n<h3 id=\"使用While循环\"><a href=\"#使用While循环\" class=\"headerlink\" title=\"使用While循环\"></a>使用While循环</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">import pika\nwhile True:\n    try:\n        connection &#x3D; pika.BlockingConnection()\n        channel &#x3D; connection.channel()\n        channel.basic_consume(&#39;test&#39;, on_message_callback)\n        channel.start_consuming()\n    # Don&#39;t recover if connection was closed by broker\n    except pika.exceptions.ConnectionClosedByBroker:\n        break\n    # Don&#39;t recover on channel errors\n    except pika.exceptions.AMQPChannelError:\n        break\n    # Recover on all other connection errors\n    except pika.exceptions.AMQPConnectionError:\n        continue\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"使用retry\"><a href=\"#使用retry\" class=\"headerlink\" title=\"使用retry\"></a>使用retry</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">from retry import retry\n\n@retry(pika.exceptions.AMQPConnectionError, delay&#x3D;5, jitter&#x3D;(1, 3))\ndef consume():\n    connection &#x3D; pika.BlockingConnection()\n    channel &#x3D; connection.channel()\n    channel.basic_consume(&#39;test&#39;, on_message_callback)\n\n    try:\n        channel.start_consuming()\n    # Don&#39;t recover connections closed by server\n    except pika.exceptions.ConnectionClosedByBroker:\n        pass\n        \nconsume()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Referenced\"><a href=\"#Referenced\" class=\"headerlink\" title=\"Referenced\"></a>Referenced</h2><p><a href=\"https://melare.lofter.com/post/1f010e23_1c71032c6\">1、封面图</a></p>","categories":[{"name":"Python","path":"api/categories/Python.json"}],"tags":[{"name":"Python","path":"api/tags/Python.json"},{"name":"消息队列","path":"api/tags/消息队列.json"}]}