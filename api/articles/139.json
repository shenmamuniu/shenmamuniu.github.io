{"title":"WebGL系列之三：ThreeJS webgl or CesiumJS Webgl","slug":"139","date":"2022-08-28T08:00:44.000Z","updated":"2022-08-28T08:00:44.000Z","comments":true,"path":"api/articles/139.json","excerpt":"本文主要是来自cesium论坛的一个回答，问题是CesiumJS的shader是否和ThreejS中的兼容。","covers":null,"content":"<p>本文主要是来自cesium论坛的一个回答，问题是CesiumJS的shader是否和ThreejS中的兼容。</p>\n<span id=\"more\"></span>\n<h2 id=\"Q\"><a href=\"#Q\" class=\"headerlink\" title=\"Q\"></a>Q</h2><p>Is shader of CesiumJS compatible with threeJs’s GLSL?</p>\n<h2 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A:\"></a>A:</h2><p>@Marco13<br>The shader code itself is written in GLSL. So you can use all the built-in functionality of GLSL in your vertex- or fragment shader.</p>\n<p>Using “pure” GLSL in WebGL can be a bit cumbersome. Even simple things require a lot of effort and care. That’s why libraries usually introduce structures for simplifying the use of custom shaders.</p>\n<p>You mentioned three.js. You can have a look at an example of how they set up the shader for a ShaderMaterial in one of the examples: You have to say, for example, that the object has vertex colors 1 so that you can use the color in the shader 1. Similarly, values like the modelViewMatrix will automatically be filled with sensible values. If you wanted to do that with plain WebGL, you’d have to use low-level functions like gl.getUniformLocation and gl.uniformMatrix4fv just to set this single matrix! Or for short: three.js is doing a lot of work for you behind the scenes!</p>\n<p>Similarly, the CustomShader of CesiumJS is simplifying the setup for you, so that you can focus on the “core” part that should be customized. And this part is exactly the implementation of the vertexMain or fragmentMain function: CesiumJS is setting up all the attributes and uniforms that are required, and collects them in the VertexInput and FragmentInput structures. These structures are passed to the vertexMain&#x2F;fragmentMain functions, where you can use them to implement custom behavior.</p>\n<p>The following is overly simplified, but it can roughly be imagined like that:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; Many attributes that are part of the model:\nattribute float position;\nattribute float color;\nattribute float texCoord;\n...\n\n&#x2F;&#x2F; Many uniforms that are part of the rendering setup\n...\n\n\nvoid main() &#123;\n\n    &#x2F;&#x2F; Collect all attributes in the VertexInput\n    VertexInput vertexInput;\n    vertexInput.attributes.positionMC &#x3D; position;\n    vertexInput.attributes.color &#x3D; color;\n    vertexInput.attributes.texCoord &#x3D; texCoord;\n    \n    &#x2F;&#x2F; Pass the attributes to your main function:\n    vertexMain(vertexInput, ...)\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; You only have to write this part:\n\nvoid vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput)\n&#123;\n    float customFactor &#x3D; 12.34;\n    vsOutput.positionMC &#x3D; vsInput.attributes.positionMC * customFactor;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>All the work that is required for setting up the attributes and uniforms with low-level WebGL calls is done by CesiumJS. You can focus on the part below the &#x3D;&#x3D;&#x3D;&#x3D; line in the example.</p>\n<p>Further documentation, for example, for the VertexInput structure, can be found in the <a href=\"https://github.com/CesiumGS/cesium/tree/main/Documentation/CustomShaderGuide\">CustomShaderGuide</a> 6</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>ThreeJS webgl和CesiumJS中的webgl都是更高层级的实现，封装了WebGL API中写法，简化了写法。因此在某些情况下，可能会显得不够用。</p>\n<h2 id=\"Referenced\"><a href=\"#Referenced\" class=\"headerlink\" title=\"Referenced\"></a>Referenced</h2><p><a href=\"https://community.cesium.com/t/is-shader-of-cesiumjs-compatible-with-threejss-glsl/17458\">Is shader of CesiumJS compatible with threeJs’s GLSL</a><br><a href=\"https://huadou145.lofter.com/post/205d4db3_1c7247e32\">封面图</a></p>\n","more":"<h2 id=\"Q\"><a href=\"#Q\" class=\"headerlink\" title=\"Q\"></a>Q</h2><p>Is shader of CesiumJS compatible with threeJs’s GLSL?</p>\n<h2 id=\"A\"><a href=\"#A\" class=\"headerlink\" title=\"A:\"></a>A:</h2><p>@Marco13<br>The shader code itself is written in GLSL. So you can use all the built-in functionality of GLSL in your vertex- or fragment shader.</p>\n<p>Using “pure” GLSL in WebGL can be a bit cumbersome. Even simple things require a lot of effort and care. That’s why libraries usually introduce structures for simplifying the use of custom shaders.</p>\n<p>You mentioned three.js. You can have a look at an example of how they set up the shader for a ShaderMaterial in one of the examples: You have to say, for example, that the object has vertex colors 1 so that you can use the color in the shader 1. Similarly, values like the modelViewMatrix will automatically be filled with sensible values. If you wanted to do that with plain WebGL, you’d have to use low-level functions like gl.getUniformLocation and gl.uniformMatrix4fv just to set this single matrix! Or for short: three.js is doing a lot of work for you behind the scenes!</p>\n<p>Similarly, the CustomShader of CesiumJS is simplifying the setup for you, so that you can focus on the “core” part that should be customized. And this part is exactly the implementation of the vertexMain or fragmentMain function: CesiumJS is setting up all the attributes and uniforms that are required, and collects them in the VertexInput and FragmentInput structures. These structures are passed to the vertexMain&#x2F;fragmentMain functions, where you can use them to implement custom behavior.</p>\n<p>The following is overly simplified, but it can roughly be imagined like that:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; Many attributes that are part of the model:\nattribute float position;\nattribute float color;\nattribute float texCoord;\n...\n\n&#x2F;&#x2F; Many uniforms that are part of the rendering setup\n...\n\n\nvoid main() &#123;\n\n    &#x2F;&#x2F; Collect all attributes in the VertexInput\n    VertexInput vertexInput;\n    vertexInput.attributes.positionMC &#x3D; position;\n    vertexInput.attributes.color &#x3D; color;\n    vertexInput.attributes.texCoord &#x3D; texCoord;\n    \n    &#x2F;&#x2F; Pass the attributes to your main function:\n    vertexMain(vertexInput, ...)\n&#125;\n\n&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x2F;&#x2F; You only have to write this part:\n\nvoid vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput)\n&#123;\n    float customFactor &#x3D; 12.34;\n    vsOutput.positionMC &#x3D; vsInput.attributes.positionMC * customFactor;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>All the work that is required for setting up the attributes and uniforms with low-level WebGL calls is done by CesiumJS. You can focus on the part below the &#x3D;&#x3D;&#x3D;&#x3D; line in the example.</p>\n<p>Further documentation, for example, for the VertexInput structure, can be found in the <a href=\"https://github.com/CesiumGS/cesium/tree/main/Documentation/CustomShaderGuide\">CustomShaderGuide</a> 6</p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>ThreeJS webgl和CesiumJS中的webgl都是更高层级的实现，封装了WebGL API中写法，简化了写法。因此在某些情况下，可能会显得不够用。</p>\n<h2 id=\"Referenced\"><a href=\"#Referenced\" class=\"headerlink\" title=\"Referenced\"></a>Referenced</h2><p><a href=\"https://community.cesium.com/t/is-shader-of-cesiumjs-compatible-with-threejss-glsl/17458\">Is shader of CesiumJS compatible with threeJs’s GLSL</a><br><a href=\"https://huadou145.lofter.com/post/205d4db3_1c7247e32\">封面图</a></p>","categories":[{"name":"图形图像","path":"api/categories/图形图像.json"}],"tags":[{"name":"WebGL","path":"api/tags/WebGL.json"}]}