{"title":"NodeJS+Turfjs实现缓冲区分析接口","slug":"48","date":"2020-03-25T09:54:00.000Z","updated":"2020-03-27T13:01:13.000Z","comments":true,"path":"api/articles/48.json","realPath":null,"excerpt":"为了使用turfjs中的缓冲区工具，需要在c# 中调用turfjs,考虑到涉及包的引用，可能会比较复杂，故采用nodejs中调用turfjs做服务，通过服务的方式在c# 中调用。","covers":null,"cover":null,"content":"<p>为了使用turfjs中的缓冲区工具，需要在c# 中调用turfjs,考虑到涉及包的引用，可能会比较复杂，故采用nodejs中调用turfjs做服务，通过服务的方式在c# 中调用。</p>\n<span id=\"more\"></span>\n<h2 id=\"操作环境\"><a href=\"#操作环境\" class=\"headerlink\" title=\"操作环境\"></a>操作环境</h2><p>**OS:**win10<br>**NodeJS:**12.16.1<br>**开发工具:**Visual studio 2019<br><strong>package.json</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&quot;dependencies&quot;: &#123;\n    &quot;body-parser&quot;: &quot;^1.19.0&quot;,\n    &quot;express&quot;: &quot;^4.17.1&quot;,\n    &quot;@turf&#x2F;turf&quot;: &quot;^5.1.6&quot;,\n  &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"NodeJS配置全局淘宝镜像\"><a href=\"#NodeJS配置全局淘宝镜像\" class=\"headerlink\" title=\"NodeJS配置全局淘宝镜像\"></a>NodeJS配置全局淘宝镜像</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>检测是否配置成功</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm info express<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"使用Express\"><a href=\"#使用Express\" class=\"headerlink\" title=\"使用Express\"></a>使用Express</h2><p>Express 是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架。<br>安装</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm install express<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"基本配置：\"><a href=\"#基本配置：\" class=\"headerlink\" title=\"基本配置：\"></a>基本配置：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">var express &#x3D; require(&#39;express&#39;);\nvar app &#x3D; express();\nvar port &#x3D; process.env.PORT || 8080;\n\nvar server &#x3D; app.listen(port, function () &#123;\n    var host &#x3D; server.address().address;\n    var port &#x3D; server.address().port;\n    console.log(&quot;应用实例，访问地址为 http:&#x2F;&#x2F;%s:%s&quot;, host, port)\n&#125;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"创建Get接口\"><a href=\"#创建Get接口\" class=\"headerlink\" title=\"创建Get接口\"></a>创建Get接口</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">app.get(&#39;&#x2F;all&#39;,function(req,res)&#123;\n    res.send(&quot;nodejs express...&quot;);\n&#125;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"创建Post接口\"><a href=\"#创建Post接口\" class=\"headerlink\" title=\"创建Post接口\"></a>创建Post接口</h3><p>这里要注意的是，Request Payload 是数据流类型的，所以需要监听 data 事件来获取数据，最后拼接出POST信息：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">app.post(&#39;&#x2F;postRoomInfo&#39;, (req, res) &#x3D;&gt; &#123;\n    console.log(&quot;请求体：&quot; + req.body);&#x2F;&#x2F;此处会输出undefined\n    var str &#x3D; &quot;&quot;;\n    req.on(&quot;data&quot;, function (chunk) &#123;\n        str +&#x3D; chunk\n    &#125;)\n    req.on(&quot;end&quot;, function () &#123;\n        console.log(&quot;请求内容:&quot;+str);&#x2F;&#x2F;此时会输出请求体的完整内容\n        res.send(&#39;ok&#39;);\n    &#125;)\n&#125;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>或者直接使用express的中间件body-parser，这样就可以直接获取请求的参数</p>\n<h3 id=\"使用body-parser\"><a href=\"#使用body-parser\" class=\"headerlink\" title=\"使用body-parser\"></a>使用body-parser</h3><p>配置body-parser</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var bodyParser &#x3D; require(&#39;body-parser&#39;);\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded(&#123; extended: true &#125;))<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>post接口：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">app.post(&#39;&#x2F;buffer&#39;, function (req, res) &#123;    \n\tvar geoType &#x3D; req.body.geoType;\n    var geoData &#x3D; req.body.geoData;\n&#125;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这样就可以直接获取到请求体中的参数了，Ajax请求如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$.ajax(&#123;\n\turl:&quot;xxx&#x2F;buffer&quot;,\n\tdata:&#123;\n\t\t&quot;geoType&quot;:&quot;polyline&quot;,\n\t\t&quot;bufferWidth&quot;:0.2\n\t&#125;,\n\ttype: &quot;post&quot;,\n\tcontentType:&quot;application&#x2F;x-www-form-urlencoded&quot;,\n\tsuccess:function(result)&#123;\n\t\t\n\t&#125;\n&#125;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"调用turfjs中的缓冲区分析工具\"><a href=\"#调用turfjs中的缓冲区分析工具\" class=\"headerlink\" title=\"调用turfjs中的缓冲区分析工具\"></a>调用turfjs中的缓冲区分析工具</h3><ol>\n<li>添加引用<pre class=\"line-numbers language-none\"><code class=\"language-none\">var turf &#x3D; require(&#39;@turf&#x2F;turf&#39;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li>使用缓冲区分析工具<br>然后直接使用turf的buffer方法即可：如下<pre class=\"line-numbers language-none\"><code class=\"language-none\">point &#x3D; turf.point(JSON.parse(geoData));\nvar buffered &#x3D; turf.buffer(point, bufferWidth, &#123; units: &#39;kilometers&#39; &#125;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ol>\n<h2 id=\"nodejs-express跨域问题\"><a href=\"#nodejs-express跨域问题\" class=\"headerlink\" title=\"nodejs express跨域问题\"></a>nodejs express跨域问题</h2><p>响应头中添加</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\nres.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,Access-Token&quot;);\nres.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"Referenced\"><a href=\"#Referenced\" class=\"headerlink\" title=\"Referenced\"></a>Referenced</h2><p><a href=\"https://www.cnblogs.com/tengrl/p/10729277.html\">1、nodejs 实现跨域</a><br><a href=\"https://blog.csdn.net/u012925833/article/details/86738913\">2、nodeJs设计GET、POST接口</a><br><a href=\"https://blog.csdn.net/boonyaxnn/article/details/91394702\">3、nodejs中常见的接口定义（get、post）</a><br><a href=\"https://www.cnblogs.com/xy404/p/7344805.html\">4、nodejs的POST两种type类型提交（原生）</a><br><a href=\"https://blog.csdn.net/gis_zzu/article/details/102812294\">5、openlayers+turf.js实现缓冲区的绘制</a><br><a href=\"https://huadou145.lofter.com/post/205d4db3_1c84a2eba\">6、封面图源</a></p>\n","more":"<h2 id=\"操作环境\"><a href=\"#操作环境\" class=\"headerlink\" title=\"操作环境\"></a>操作环境</h2><p>**OS:**win10<br>**NodeJS:**12.16.1<br>**开发工具:**Visual studio 2019<br><strong>package.json</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&quot;dependencies&quot;: &#123;\n    &quot;body-parser&quot;: &quot;^1.19.0&quot;,\n    &quot;express&quot;: &quot;^4.17.1&quot;,\n    &quot;@turf&#x2F;turf&quot;: &quot;^5.1.6&quot;,\n  &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"NodeJS配置全局淘宝镜像\"><a href=\"#NodeJS配置全局淘宝镜像\" class=\"headerlink\" title=\"NodeJS配置全局淘宝镜像\"></a>NodeJS配置全局淘宝镜像</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>检测是否配置成功</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm info express<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"使用Express\"><a href=\"#使用Express\" class=\"headerlink\" title=\"使用Express\"></a>使用Express</h2><p>Express 是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架。<br>安装</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm install express<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"基本配置：\"><a href=\"#基本配置：\" class=\"headerlink\" title=\"基本配置：\"></a>基本配置：</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">var express &#x3D; require(&#39;express&#39;);\nvar app &#x3D; express();\nvar port &#x3D; process.env.PORT || 8080;\n\nvar server &#x3D; app.listen(port, function () &#123;\n    var host &#x3D; server.address().address;\n    var port &#x3D; server.address().port;\n    console.log(&quot;应用实例，访问地址为 http:&#x2F;&#x2F;%s:%s&quot;, host, port)\n&#125;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"创建Get接口\"><a href=\"#创建Get接口\" class=\"headerlink\" title=\"创建Get接口\"></a>创建Get接口</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">app.get(&#39;&#x2F;all&#39;,function(req,res)&#123;\n    res.send(&quot;nodejs express...&quot;);\n&#125;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"创建Post接口\"><a href=\"#创建Post接口\" class=\"headerlink\" title=\"创建Post接口\"></a>创建Post接口</h3><p>这里要注意的是，Request Payload 是数据流类型的，所以需要监听 data 事件来获取数据，最后拼接出POST信息：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">app.post(&#39;&#x2F;postRoomInfo&#39;, (req, res) &#x3D;&gt; &#123;\n    console.log(&quot;请求体：&quot; + req.body);&#x2F;&#x2F;此处会输出undefined\n    var str &#x3D; &quot;&quot;;\n    req.on(&quot;data&quot;, function (chunk) &#123;\n        str +&#x3D; chunk\n    &#125;)\n    req.on(&quot;end&quot;, function () &#123;\n        console.log(&quot;请求内容:&quot;+str);&#x2F;&#x2F;此时会输出请求体的完整内容\n        res.send(&#39;ok&#39;);\n    &#125;)\n&#125;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>或者直接使用express的中间件body-parser，这样就可以直接获取请求的参数</p>\n<h3 id=\"使用body-parser\"><a href=\"#使用body-parser\" class=\"headerlink\" title=\"使用body-parser\"></a>使用body-parser</h3><p>配置body-parser</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var bodyParser &#x3D; require(&#39;body-parser&#39;);\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded(&#123; extended: true &#125;))<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>post接口：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">app.post(&#39;&#x2F;buffer&#39;, function (req, res) &#123;    \n\tvar geoType &#x3D; req.body.geoType;\n    var geoData &#x3D; req.body.geoData;\n&#125;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这样就可以直接获取到请求体中的参数了，Ajax请求如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$.ajax(&#123;\n\turl:&quot;xxx&#x2F;buffer&quot;,\n\tdata:&#123;\n\t\t&quot;geoType&quot;:&quot;polyline&quot;,\n\t\t&quot;bufferWidth&quot;:0.2\n\t&#125;,\n\ttype: &quot;post&quot;,\n\tcontentType:&quot;application&#x2F;x-www-form-urlencoded&quot;,\n\tsuccess:function(result)&#123;\n\t\t\n\t&#125;\n&#125;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"调用turfjs中的缓冲区分析工具\"><a href=\"#调用turfjs中的缓冲区分析工具\" class=\"headerlink\" title=\"调用turfjs中的缓冲区分析工具\"></a>调用turfjs中的缓冲区分析工具</h3><ol>\n<li>添加引用<pre class=\"line-numbers language-none\"><code class=\"language-none\">var turf &#x3D; require(&#39;@turf&#x2F;turf&#39;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li>使用缓冲区分析工具<br>然后直接使用turf的buffer方法即可：如下<pre class=\"line-numbers language-none\"><code class=\"language-none\">point &#x3D; turf.point(JSON.parse(geoData));\nvar buffered &#x3D; turf.buffer(point, bufferWidth, &#123; units: &#39;kilometers&#39; &#125;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n</ol>\n<h2 id=\"nodejs-express跨域问题\"><a href=\"#nodejs-express跨域问题\" class=\"headerlink\" title=\"nodejs express跨域问题\"></a>nodejs express跨域问题</h2><p>响应头中添加</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\nres.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,Access-Token&quot;);\nres.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"Referenced\"><a href=\"#Referenced\" class=\"headerlink\" title=\"Referenced\"></a>Referenced</h2><p><a href=\"https://www.cnblogs.com/tengrl/p/10729277.html\">1、nodejs 实现跨域</a><br><a href=\"https://blog.csdn.net/u012925833/article/details/86738913\">2、nodeJs设计GET、POST接口</a><br><a href=\"https://blog.csdn.net/boonyaxnn/article/details/91394702\">3、nodejs中常见的接口定义（get、post）</a><br><a href=\"https://www.cnblogs.com/xy404/p/7344805.html\">4、nodejs的POST两种type类型提交（原生）</a><br><a href=\"https://blog.csdn.net/gis_zzu/article/details/102812294\">5、openlayers+turf.js实现缓冲区的绘制</a><br><a href=\"https://huadou145.lofter.com/post/205d4db3_1c84a2eba\">6、封面图源</a></p>","categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"NodeJS","path":"api/tags/NodeJS.json"},{"name":"缓冲区分析","path":"api/tags/缓冲区分析.json"},{"name":"TurfJS","path":"api/tags/TurfJS.json"}]}